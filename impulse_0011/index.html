<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>impulse-0011: We Are The Robots Baby!</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v1.js" type="text/javascript"></script>
    <link href='https://fonts.googleapis.com/css?family=Josefin Slab' rel='stylesheet'>
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs-default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;

        v_texcoord = a_texcoord;
      }
    </script>

    <script id="fs-red-scene" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 col = vec3(0.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs-glow-fields" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE - BEGIN
      // -----------------------------------------------------------------------------
      precision highp float;

      #define DEMO_MODE


      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      #ifdef DEMO_MODE
      uniform ivec3 g_state;
      #else
      ivec3 g_state;
      #endif

      float g_ntime;
      float g_ftime;
      float g_btime;

      mat2  g_rot0;
      mat2  g_rot1;

      #define TIME        time
      #define RESOLUTION  resolution
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         60.

      #define NONE        0

      #define COMPUTER    1
      #define FREQ1       2
      #define FREQ2       3

      #define EFFECT0     1
      #define EFFECT1     2
      #define EFFECT2     3
      #define EFFECT3     4
      #define EFFECT4     5
      #define EFFECT5     6

      #define FLASH       1

      #define SCRIPT(a,b,c) ((a << 3)+(b<<1)+c)

      #ifdef DEMO_MODE
      #else
      const int g_scriptCount = 29;

      const int[] g_script = int[g_scriptCount](
          SCRIPT(NONE   , COMPUTER, NONE)
        , SCRIPT(EFFECT0, FREQ1   , FLASH)
        , SCRIPT(EFFECT4, FREQ1   , FLASH)
        , SCRIPT(EFFECT1, FREQ1   , FLASH)
        , SCRIPT(EFFECT1, FREQ1   , FLASH)
        , SCRIPT(EFFECT5, FREQ2   , FLASH)
        , SCRIPT(EFFECT5, FREQ2   , FLASH)
        , SCRIPT(EFFECT0, COMPUTER, FLASH)
        , SCRIPT(EFFECT0, COMPUTER, FLASH)
        , SCRIPT(EFFECT4, COMPUTER, FLASH)
        , SCRIPT(EFFECT4, COMPUTER, FLASH)
        , SCRIPT(EFFECT1, FREQ1   , FLASH)
        , SCRIPT(EFFECT1, FREQ1   , FLASH)
        , SCRIPT(EFFECT4, FREQ2   , FLASH)
        , SCRIPT(EFFECT3, FREQ2   , FLASH)
        , SCRIPT(EFFECT2, FREQ2   , FLASH)
        , SCRIPT(EFFECT2, FREQ2   , FLASH)
        , SCRIPT(EFFECT1, FREQ2   , FLASH)
        , SCRIPT(EFFECT1, FREQ2   , FLASH)
        , SCRIPT(EFFECT4, FREQ1   , FLASH)
        , SCRIPT(EFFECT0, FREQ1   , FLASH)
        , SCRIPT(EFFECT3, COMPUTER, FLASH)
        , SCRIPT(EFFECT3, COMPUTER, FLASH)
        , SCRIPT(EFFECT2, FREQ2   , FLASH)
        , SCRIPT(EFFECT2, FREQ2   , FLASH)
        , SCRIPT(EFFECT1, FREQ2   , FLASH)
        , SCRIPT(EFFECT1, FREQ2   , FLASH)
        , SCRIPT(NONE   , COMPUTER, NONE )
        , SCRIPT(NONE   , COMPUTER, NONE )
        );
      #endif

      const float
          PI        = acos(-1.)
        , TAU       = 2.*PI
        , ExpBy     = log2(4.1)
        , Radius    = 0.3
        ;


      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      const vec3 lightDir0    = normalize(vec3(-1.,-1., 0.));
      const vec3 lightCol0    = HSV2RGB(vec3(0.6, .2, 1E-2));
      const vec3 lightDir1    = normalize(vec3(1.,1., -1.));
      const vec3 lightCol1    = HSV2RGB(vec3(0.6, 0.2, 2E-3));
      const vec3 bottomBoxCol = HSV2RGB(vec3(0.7, 0.5, 0.25));
      const vec3 topBoxCol    = HSV2RGB(vec3(0.6, 0.2, 0.95));
      const vec3 sbase        = HSV2RGB(vec3(0.0, 0.9, 1.));
      const vec3 seye         = HSV2RGB(vec3(0.03, 0.75, 16.));
      const vec3 sbase4       = HSV2RGB(vec3(0.6, 0.6, 1.));
      const vec3 glowCol      = HSV2RGB(vec3(0.0, 0.9, 1E-3));

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float modPolar(inout vec2 p, float repetitions) {
        float angle = 2.*PI/repetitions;
        float a = atan(p.y, p.x) + angle/2.;
        float r = length(p);
        float c = floor(a/angle);
        a = mod(a,angle) - angle/2.;
        p = vec2(cos(a), sin(a))*r;
        // For an odd number of repetitions, fix cell index of the cell in -x direction
        // (cell index would be e.g. -5 and 5 in the two halves of the cell):
        if (abs(c) >= (repetitions/2.)) c = abs(c);
        return c;
      }


      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6;
        float a = 2.51;
        float b = 0.03;
        float c = 2.43;
        float d = 0.59;
        float e = 0.14;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);

      }

      // License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }
      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      float pabs(float a, float k) {
        return -pmin(a, -a, k);
      }

      float segmenty(vec2 p, float h, float w) {
        float hh = 0.5*h;
        p.y = abs(p.y);
        p.y -= hh;
        float d0 = length(p);
        float d1 = abs(p.x);
        float d = p.y > 0.0 ? d0 : d1;
        d -= w;
        return d;
      }

      float segmentx(vec2 p, vec2 dim) {
        p.x = abs(p.x);
        float o = 0.5*max(dim.x-dim.y, 0.0);
        if (p.x < o) {
          return abs(p.y) - dim.y;
        }
        return length(p-vec2(o, 0.0))-dim.y;
      }

      const int[16] digits = int[16](
        0x7D // 0
      , 0x50 // 1
      , 0x4F // 2
      , 0x57 // 3
      , 0x72 // 4
      , 0x37 // 5
      , 0x3F // 2
      , 0x51 // 7
      , 0x7F // 8
      , 0x77 // 9
      , 0x7B // A
      , 0x3E // B
      , 0x2D // C
      , 0x5E // D
      , 0x2F // E
      , 0x2B // F
      );


      float sphere(vec3 p, float t) {
        return length(p)-t;
      }

      float circle(vec2 p, float r) {
        return length(p) - r;
      }

      float circle4(vec2 p, float r) {
        p *= p;
        return pow(dot(p, p), 0.25) - r;
      }

      float plane(vec2 p, vec3 pp) {
        return dot(p, pp.xy)+pp.z;
      }


      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/
      float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      void sphere(vec2 p, float r, out vec3 sp, out vec3 sn) {
        float z2 = (r*r-dot(p, p));
        if (z2 > 0.0) {
          float z = sqrt(z2);
          vec3 cp = vec3(p, z);
          vec3 cn = normalize(cp);
          sp = cp;
          sn = cn;
        } else {
          sp = vec3(p, 0.);
          sn = vec3(0.);
        }

      }

      // The normal here is not correct, but the effect is designed around it being buggy
      void buggySphere4(vec2 p, float r, out vec3 sp, out vec3 sn) {
        vec2 p2 = p;
        p2 *= p;
        float z4 = (r*r*r*r-dot(p2, p2));
        if (z4 > 0.0) {
          float z = pow(z4, 0.25);
          vec3 cp = vec3(p, z);
          vec3 cn = normalize(cp);
          sp = cp;
          sn = cn;
        } else {
          sp = vec3(p, 0.);
          sn = vec3(0.);
        }

      }

      float digit(vec2 p, float n) {
        const vec2 dim = vec2(0.75, 0.075);
        const float eps = 0.01;
        vec2 ap = abs(p);
        if (ap.x > (1.+dim.y+eps)) return 1E3;
        if (ap.y > (1.5+dim.y+eps)) return 1E3;
        float m = mod(floor(n), 16.0);
        int digit = digits[int(m)];

        vec2 cp = (p-0.5);
        vec2 cn = round(cp);

        vec2 p0 = p;
        p0.y -= 0.5;
        p0.y = p0.y-0.5;
        float n0 = round(p0.y);
        p0.y -= n0;
        float d0 = segmentx(p0, dim);

        vec2 p1 = p;
        vec2 n1 = sign(p1);
        p1 = abs(p1);
        p1 -= 0.5;
        p1 = p1.yx;
        float d1 = segmentx(p1, dim);

        vec2 p2 = p;
        p2.y = abs(p.y);
        p2.y -= 0.5;
        p2 = abs(p2);
        float d2 = dot(normalize(vec2(1.0, -1.0)), p2);

        float d = d0;
        d = min(d, d1);

        float sx = 0.5*(n1.x+1.0) + (n1.y+1.0);
        float sy = -n0;
        float s  = d2 > 0.0 ? (3.0+sx) : sy;
        // Praying bit shift operations aren't TOO slow
        return ((digit & (1 << int(s))) == 0) ? 1E3 : d;
      }

      vec4 dthecomputer(vec2 p, float f) {
        const float sm = 0.015;
        const vec3 pp = vec3(normalize(vec2(1., 1.)), -0.1);
        float d0 = circle4(p, 0.48);
        float d1 = plane(p, pp);
        float d2 = circle(p, 0.225);
        float d3 = abs(d2-0.05-f*4.)-0.02;
        d3 = abs(d3-f*2.)-0.01;
        d3 = abs(d3-f);
        float d4 = d1;
        float d5 = abs(d0-0.015);
        d1 = abs(d1)-0.2;
        d1 = abs(d1)-0.1;
        float d = d0;
        d =  pmax(d, -d1, sm);
        d2 = max(d2, d4);
        d3 = max(d3, d4);
        d2 = pmax(d2, -(d-0.01), sm);
        d3 = pmax(d3, -(d-0.01), sm);
        d = min(d, d2);
        d = min(d, d5);

        return vec4(d, d2, d0, min(d5, d3));
      }

      vec3 render0(vec3 ro, vec3 rd) {
        vec3 col = vec3(0.0);

        const vec4 pp0 = vec4(normalize(vec3(0.0, -1.0, 0.0)), -5.0);
        const vec4 pp1 = vec4(normalize(vec3(-2., 2.0, 1.0)), -6.);
        float tp0  = rayPlane(ro, rd, pp0);
        float tp1  = rayPlane(ro, rd, pp1);

        if (tp0 > 0.0) {
          vec3 bcol = bottomBoxCol*exp(-0.5*(1.+length((ro + tp0*rd).xz)));
          bcol /=  0.05*(tp0*tp0);;
          col += bcol;
        }

        if (tp1 > 0.0) {
          vec3 pos  = ro + tp1*rd;
          vec2 pp = pos.xz;
          float db = box(pp, vec2(8.0, 1.))-2.;
          vec3 tcol = vec3(0.);
          tcol += topBoxCol*smoothstep(0.25, 0.0, db);
          col += 0.2*topBoxCol*exp(-max(db, 0.0));
      //    tcol += 0.25*(topBoxCol)*max(-db, 0.0);
          tcol /= 0.025*(tp1*tp1);
          col += tcol;
        }

        col += lightCol0/(1.0090-dot(lightDir0, rd));
        col += lightCol1/(1.0025-dot(lightDir1, rd));
        return clamp(col, 0., 10.);
      }

      vec3 thecomputer(vec3 col, vec2 p, vec2 pp) {
        float voice = 0.;
        const float vc = 4.0;
        for (float i = 0.; i<vc;++i) {
          voice += max((texture(frequency_data, vec2(0.05+0.05*i, 0.0)).x-0.3), 0.0);
        }
        voice *= 1./vc;
        voice *= voice;
        voice = smoothstep(0.0, 0.2, voice);
        float ntime = g_ntime;
        float ftime = g_ftime;
        float time = ntime+ftime;
        // HARDCODED TIMING - LOVE EM!
        float va =
              smoothstep(3., 2., time)
            +  step(8., time)
            -  step(168., time)
            +  step(172., time)
            ;
        voice *= va;


        float aa = sqrt(2.)/RESOLUTION.y;

        vec4 d = dthecomputer(p, 0.025*voice);
        const vec3 ro = vec3(0., 0., 8.);
        vec3 sn;
        vec3 sp;
        sphere(p, 0.225, sp, sn);
        vec3 srd  = normalize(sp-ro);
        vec3 sr   = reflect(srd, sn);
        vec3 srcol= render0(sp, sr);
        float sfre= 1.+dot(srd, sn);
        sfre *= sfre;
        vec3 sfre3 = mix(2.*sbase, vec3(2.), sfre);
        vec3 scol = vec3(0.);
        scol = srcol*sfre3;
        scol += pow(-dot(srd,sn), 10.)*sbase;
        scol += pow(-dot(srd,sn), mix(20., 10., voice))*seye*(voice);

        vec3 scol4 = vec3(0.);
        vec3 sn4;
        vec3 sp4;
        buggySphere4(p, 0.48, sp4, sn4);

        vec3 srd4  = normalize(sp4-ro);
        vec3 sr4   = reflect(srd4, sn4);
        vec3 srcol4= render0(sp4, sr4);
        float sfre4= 1.+dot(srd4, sn4);
        sfre4 *= sfre4;
        vec3 sfre34 = mix(2.*sbase4, vec3(2.), sfre4);

        scol4 += srcol4*sfre34;
        vec3 gcol = 0.0001*sbase/(1.00003+dot(srd, vec3(0.0, 0.0, 1.)))*smoothstep(aa, -aa, d.z);
      //  gcol += srcol4*sqrt(sbase)*sfre4*0.5;

        vec3 ccol = gcol;

        ccol = mix(ccol, scol4, smoothstep(aa, -aa, d.x));
        ccol = mix(ccol, scol, smoothstep(aa, -aa, d.y));
        ccol -= 6E-2*vec3(2.,3.,1.)*dot(p, p);
        col *= 1.-exp(-50.*max(d.z*d.z, 0.));
        col = mix(col, ccol, smoothstep(aa, -aa, d.z));
        col += glowCol/max(d.w, 1E-3);
        col += 2E-3*seye*(pow(voice, 3.))/max((dot(p,p)), 1E-1);
        return col;
      }

      float dvumeters(vec2 p, float off) {
        vec2 p3 = p;
        p3.y = abs(p3.y);
        p3.y -= off;
        const float cw = 0.1;
        float n3 = mod1(p3.x, cw);
        n3 = abs(n3);
        n3 += 3.0;
        float fft = texture(frequency_data, vec2(0.02*n3, 0.0)).x;
        fft -= 0.3;
        fft = max(fft, 0.0);
        fft *= fft;
        fft *= 3.;
        float d3 = segmenty(p3, fft, 0.4*cw);
        float d = d3;
        return d;
      }

      vec3 vumeters(vec3 col, vec2 p, vec2 pp, float off) {
        float ftime = g_ftime;
        float aa = sqrt(2.)/RESOLUTION.y;
        float df = dvumeters(p, off);
        float sy = sign(p.y);
        vec3 fcol = 2.*(1.5+0.5*sy)*(0.5+0.5*sin(vec3(0.,1.,2.)+abs(p.x)+TIME+0.125*sy));
        col = mix(col, mix(fcol, col, ftime*ftime*ftime), smoothstep(aa, -aa, df));
        return col;
      }


      void setup() {
        const float off          = 16.;
        float beat    = (BPM/60.)*(TIME);
        float ntime   = floor(beat);
        float ftime   = fract(beat);
        float btime   = (TIME+(ntime+log2(1.+(off-1.)*ftime)/log2(off)));
        g_ntime       = ntime;
        g_ftime       = ftime;
        g_btime       = btime;
      #ifdef DEMO_MODE
      #else
        int script    = g_script[int(ntime/8.)];
        g_state       = ivec3(script>>3, (script>>1)&0x3, script&0x1);
      #endif
        float t       = TAU*btime;
        float a       = t*TAU/107.0;
        g_rot0        = ROT(a);
        g_rot1        = ROT(1.234*a);
      }

      // -----------------------------------------------------------------------------
      // PRELUDE - END
      // -----------------------------------------------------------------------------


      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/
      float torus(vec3 p, vec2 t) {
        vec2 q = vec2(length(p.xz)-t.x,p.y);
        return length(q)-t.y;
      }

      float dfeffect0(vec2 p, vec2 pp) {
        float csz = 0.3;
        csz /= 1.-0.5*length(pp)*sqrt(0.5)*(g_ftime*g_ftime*g_ftime);
        float sm = csz+.4*csz;
        vec2 dp = p;
        vec2 dn = mod2(dp, vec2(csz));
        float ddots = length(dp);
        vec2 adp = abs(dp);
        float dgrid = min(adp.x, adp.y);
        float tm = sqrt(0.5)*g_btime;
        float dblobs = 1E3;
        for (float i = 0.; i < 5.; ++i) {
          vec2 a = vec2(1., sqrt(0.5))*tm+vec2(i, i*i);
          vec2 o = csz*vec2(sin(a))*4.;
          float dd = circle(p-o, csz*0.5);
          dblobs = pmin(dblobs, dd, sm);
        }

        float d = 1E6;
        d = min(d, ddots);
        d = pmin(d, (dblobs), sm);
        return d;
      }

      // From Evil Ryu Mandelbox - https://www.shadertoy.com/view/XdlSD4

      const float fixed_radius2 = 1.9;
      const float min_radius2   = 0.5;
      const float folding_limit = 1.0;
      const float scale         = -2.8;

      vec3 pmin(vec3 a, vec3 b, vec3 k) {
        vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);

        return mix(b, a, h) - k*h*(1.0-h);
      }

      void sphere_fold(inout vec3 z, inout float dz) {
          float r2 = dot(z, z);
          if(r2 < min_radius2) {
              float temp = (fixed_radius2 / min_radius2);
              z *= temp;
              dz *= temp;
          } else if(r2 < fixed_radius2) {
              float temp = (fixed_radius2 / r2);
              z *= temp;
              dz *= temp;
          }
      }

      void box_fold(inout vec3 z, inout float dz) {
        const float k = 0.05;
        // Soft clamp after suggestion from ollij
        vec3 zz = sign(z)*pmin(abs(z), vec3(folding_limit), vec3(k));
        // Hard clamp
        // z = clamp(z, -folding_limit, folding_limit);
        z = zz * 2.0 - z;
      }


      float mb(vec3 z) {
          vec3 offset = z;
          float dr = 1.0;
          float fd = 0.0;
          for(int n = 0; n < 5; ++n) {
              box_fold(z, dr);
              sphere_fold(z, dr);
              z = scale * z + offset;
              dr = dr * abs(scale) + 1.0;
              float r1 = sphere(z, 5.0);
              float r2 = torus(z, vec2(8.0, 1));
              r2 = abs(r2) - 0.25;
              float r = n < 4 ? r2 : r1;
              float dd = r / abs(dr);
              if (n < 3 || dd < fd) {
                fd = dd;
              }
          }
          return (fd);
      }

      vec2 toPolar(vec2 p) {
        return vec2(length(p), atan(p.y, p.x));
      }

      vec2 toRect(vec2 p) {
        return vec2(p.x*cos(p.y), p.x*sin(p.y));
      }

      float modMirror1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize,size) - halfsize;
        p *= mod(c, 2.0)*2.0 - 1.0;
        return c;
      }
      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float smoothKaleidoscope(inout vec2 p, float sm, float rep) {
        vec2 hp = p;

        vec2 hpp = toPolar(hp);
        float rn = modMirror1(hpp.y, TAU/rep);

        float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);
        hpp.y = sign(hpp.y)*(sa);

        hp = toRect(hpp);

        p = hp;

        return rn;
      }

      float dfeffect1(vec2 p, vec2 pp) {
        const float s = sqrt(.5);
        p /= s;
        float rep = 20.0;
        float ss = 0.05*6.0/rep;
        vec3 p3 = vec3(p.x, p.y, 0.5+g_ftime*g_ftime);
        p3.xz*=g_rot0;
        p3.yz*=g_rot1;
        float n = smoothKaleidoscope(p3.xy, ss, rep);
        float d = mb(p3)*s;
        return abs(d);
      }


      float apollonian(vec3 p, float s) {
        vec3 op = p;
        float scale = 1.;
        float sc = 0.55*s;
        float tsc = sc;
        float ssc = 1.;
        for(int i=0; i < 5; ++i) {
          p = -1.0 + 2.0*fract(0.5*p+0.5);
          float r2 = tanh_approx(dot(p,p)/tsc)*tsc;
          float k  = s/r2;
          p       *= k;
          scale   *= k;
        }

        vec3 ap = abs(p/scale);
      #define X1
      #if defined(X0)
        float d = ap.x;
        d = min(d, length(ap.yz));
      #elif defined(X1)
        float d = ap.x;
        d = min(d, abs(length(ap.yz-0.08*(g_ftime))-0.0025));
      #else
        float d = ap.x;
        d = min(d, ap.y);
        d = min(d, ap.z);
      #endif
        return d;
      }

      float dfeffect2(vec2 p, vec2 pp) {
        float fz = mix(0.75, 1., smoothstep(-0.9, 0.9, cos(TAU*TIME/33.0)));
        float z = 2.*fz;
        p /= z;
        vec3 p3 = vec3(p,0.1);
        p3.xz*=g_rot0;
        p3.yz*=g_rot1;
        float ifz = 1.0/fz;
        float d = apollonian(p3, ifz);
        d *= z;
        return d-5E-4;
      }

      float dfeffect3(vec2 p, vec2 pp) {
        float d = 1E3;
        float nb = mod(g_ntime-1., 4.0);
        float sc =  0.33*mix(0.25, 1., nb/3.);
        p *= ROT(1.5*(hash(g_ntime)-0.5)*(nb-3.)/3.);
        sc /= 1.-0.5*length(pp)*sqrt(0.5)*sin(g_btime*PI);
        vec2 p0 = p;
        p0 /= sc;
        p0.x -= 3.;
        float nx = mod1(p0.x, 3.);
        float sx = 1.-2.*mod(nx, 2.0);
        p0.y += sx*(g_ntime+pow(g_ftime, 4.))*12.;
        float ny = sx*mod1(p0.y, 3.);
        vec2 n2 = vec2(nx, ny);
        float n = (-n2.x+n2.y);
        float sdig = mod(n, 4.);
        n = abs(120.-floor(n/4.));
        float dig0 = mod(n, 10.);
        float dig1 = mod(n/10., 10.);
        float dig2 = mod(n/100., 10.);
        float dig = dig0;
        if (sdig == 1.) dig = dig1;
        if (sdig == 2.) dig = dig2;
        float d0 = digit(p0, dig);
        if (sdig == 3.) d0 = abs(length(p0)-0.5)-0.01;
        d0 *= sc;
        d = pmax(d, -(d0-0.01), 0.01);
        d = min(d, d0);
        return d;
      }

      float forward(float l) {
        return exp2(ExpBy*l);
      }

      float reverse(float l) {
        return log2(l)/ExpBy;
      }

      float dfeffect4(vec2 p, vec2 pp) {
        float ppf = 0.4*dot(pp, pp);
        p /= 1.+ppf;
        float tm = 0.5*g_btime;
        mat2 rot0 = ROT(-tm-ppf*(g_ftime*g_ftime*g_ftime));
        float py = p.y;

        float h = 10.0/RESOLUTION.y;
        mod1(py, h);

        float d = 1E3;
        for (float i = 0.0; i < 2.0; ++i) {
          float ltm = tm+0.5*i;
          mat2 rot1 = ROT(i*0.5*TAU/8.0);
          float mtm = fract(ltm);
          float ntm = floor(ltm);
          float zz = forward(mtm);

          vec2 p0 = p;
          p0 *= rot0;
          p0 *= rot1;
          p0 /= zz;

          float l0 = length(p0);

          float n0 = ceil(reverse(l0));
          float r0 = forward(n0);
          float r1 = forward(n0-1.0);
          float r = (r0+r1)/2.0;
          float w = r0-r1;
          float nn = n0;
          n0 -= ntm;
          vec2 p1 = p0;
          float n1 = modPolar(p1, 8.0);
          p1.x -= r;

          float a = 0.5*ltm+n1/8.0;
          a = fract(a);
          float d1 = length(p1)-Radius*w;
          float d2 = length(p1)-Radius*w*smoothstep(0.0, 0.45, mod(a, 0.5));
          d1 *= zz;
          d2 *= zz;
          if (a >= 0.5) {
            d1 = max(d1, -d2);
            d = min(d, d1);
          } else {
            d = min(d, d2);
          }
        }
        return d;
      }

      const float
        pi    = acos(-1.)
      , tau   = pi*2.
      , phi   = (1.+sqrt(5.))*0.5
      , phi2  = phi*phi
      , phi4  = phi2*phi2
      , iphi4 = 1./phi4
      ;

      float superCircle4(vec2 p, float r) {
        p *= p;
        return pow(dot(p,p), 1./4.)-r;
      }

      float superCircle8(vec2 p, float r) {
        p *= p;
        p *= p;
        return pow(dot(p,p), 1./8.)-r;
      }

      float geometric(float a, float r) {
        return a/(1.-r);
      }

      float igeometric(float a, float r, float x) {
        return log2(1.-x*(1.-r)/a)/log2(r);
      }

      vec2 geometric2(float a, float r, float n) {
        float rn = pow(r, n);
        float rn1 = rn*r;
        return (a/(1.-r))*(1.-vec2(rn, rn1));
      }

      vec4 boxySpiralCoord(vec2 p, float z) {
        float px = p.x;
        float ax = abs(px);
        float sx = sign(px);
        float a = px > 0. ? phi2 : 1.;
        a *= z;
        float gdx     = geometric(a, iphi4);
        ax            -= gdx;
        float x       = igeometric(a, iphi4, -ax);
        float nx      = floor(x);
        vec2  lx      = geometric2(a, iphi4, nx)-gdx;
        float minx    = lx.x;
        float maxx    = lx.y;
        float radiusx = (maxx-minx)*0.5;
        float meanx   = minx+radiusx;

        p -= vec2(-1.,1./3.)*meanx*sx;
        return vec4(p, radiusx, 2.*nx+(sx>0.?0.:1.));
      }

      float dfeffect5(vec2 p, vec2 pp) {
        float ppf = 0.4*dot(pp, pp);
        p /= 1.+ppf;
        float tm = 0.5*g_btime;
        float pft = fract(tm);
        float nft = floor(tm);
        float piz = exp2(log2(phi4)*pft);
        mat2 rot0 = ROT(-tm-ppf*(g_ftime*g_ftime*g_ftime));
        p *= rot0;
        vec4 gcx = boxySpiralCoord(p, piz);
        vec4 gcy = boxySpiralCoord(vec2(p.y,-p.x), phi*piz);

        vec2 l = vec2(1.,0.)+2.*vec2(1.+gcx.w, gcy.w);

        vec2 n = l+4.*nft;
        vec2 a = -0.634*n+tm;
        vec2 na = floor(a);
        vec2 fa = fract(a);
        vec2 gc = vec2(gcx.z, gcy.z);

        const float msz = 0.99;
        vec2 br0 = gc*msz*fa;
        vec2 lw = 0.5*(1.0-fa);
        vec2 br1 = gc*(msz-lw);
        vec2 ol1 = lw*gc;

        vec2 dbb = vec2(
            superCircle4(gcx.xy, 0.)
          , superCircle4(gcy.xy, 0.)
          );

        vec2 db0 = dbb-br0;
        vec2 db1 = abs(dbb-br1)-ol1;


        vec2 db = mix(db0, db1, mod(na, vec2(2.0)));

      /*
      */
        float d = min(db.x, db.y);
        return d;
      }

      float df(vec2 p, vec2 pp) {
        switch(g_state.x) {
        case EFFECT0:
          return dfeffect0(p, p);
        case EFFECT1:
          return dfeffect1(p, p);
        case EFFECT2:
          return dfeffect2(p, p);
        case EFFECT3:
          return dfeffect3(p, p);
        case EFFECT4:
          return dfeffect4(p, p);
        case EFFECT5:
          return dfeffect5(p, p);
        default:
          return 1E3;
        }
      }

      vec3 mainEffect(vec3 col, vec2 p, vec2 pp) {
        const vec3 glowCol  = HSV2RGB(vec3(0.55, 0.7, 1E-3));
        float ftime         = g_ftime;

        float d = df(p, pp);
        col += glowCol/max(d, 1E-4);
        float sy = sign(p.y);

        if (g_state.z == 1) {
          col += smoothstep(0.25, 0., ftime)*2E5*glowCol*glowCol/max(dot(p, p), 1E-2);
        }

        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        setup();
        vec3 col;
        col = mainEffect(col, p, pp);
        col *= smoothstep(1.5, sqrt(0.5), length(pp));
        switch(g_state.y) {
        case COMPUTER:
          col = thecomputer(col, p, pp);
          break;
        case FREQ1:
          col = vumeters(col, p, pp, 0.);
          break;
        case FREQ2:
          col = vumeters(col, p, pp, 1.);
          break;
        default:
          break;
        }

        col = aces_approx(col);
        // HARDCODED TIMING - LOVE EM!
        float ca = step(g_ntime, 117.)+step(120.,g_ntime);
        col *= ca;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p, pp);
        frag_color = vec4(col,1.0);
      }
      // -----------------------------------------------------------------------------

    </script>

    <script type = "text/javascript">
      const analyze_audio   = true;
      const demo_system     = new DemoSystemV1(analyze_audio);

      const global_uniforms = [];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {};

      const all_scenes = {
        red_scene : {
          vs: "vs-default"  ,
          fs: "fs-red-scene",
        },
        glow_fields : {
          vs: "vs-default"  ,
          fs: "fs-glow-fields",
          uniforms: ["g_state"],
        },
      };

      const bpm   = 60.0;
      const beat  = 60.0/bpm;
      const start = 0.0*beat;
      function btime(b) {
        return (b*beat-start);
      }

      const max_time_slots  = 400;
      const time_slots      = new Array(max_time_slots);

      const EFFECT_NONE     = 0;
      const EFFECT_BLOBS    = 1;
      const EFFECT_MANDEL   = 2;
      const EFFECT_APOLLO   = 3;
      const EFFECT_DIGITS   = 4;
      const EFFECT_CIRCLES  = 5;
      const EFFECT_BOXES    = 6;

      const OVERLAY_NONE     = 0;
      const OVERLAY_COMPUTER = 1;
      const OVERLAY_VUMETER1 = 2;
      const OVERLAY_VUMETER2 = 3;

      const FLASH_OFF        = 0;
      const FLASH_ON         = 1;

      function glow_fields_slot(begin, effect, overlay, flash) {
        return         {
          begin   : begin                   ,
          scene   : all_scenes.glow_fields  ,
          g_state : [effect, overlay, flash],
        };
      }

      const script = [
        /*{
          begin       : 0                                 ,
          scene       : all_scenes.we_are_the_robots_baby ,
        },
        */
        glow_fields_slot(  0, EFFECT_NONE   , OVERLAY_COMPUTER, FLASH_OFF ),
        glow_fields_slot(  8, EFFECT_BLOBS  , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot( 16, EFFECT_CIRCLES, OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot( 24, EFFECT_MANDEL , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot( 32, EFFECT_MANDEL , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot( 40, EFFECT_BOXES  , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot( 48, EFFECT_BOXES  , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot( 56, EFFECT_BLOBS  , OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot( 64, EFFECT_BLOBS  , OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot( 72, EFFECT_CIRCLES, OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot( 80, EFFECT_CIRCLES, OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot( 88, EFFECT_MANDEL , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot( 96, EFFECT_MANDEL , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot(104, EFFECT_CIRCLES, OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(112, EFFECT_DIGITS , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(120, EFFECT_APOLLO , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(128, EFFECT_APOLLO , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(136, EFFECT_MANDEL , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(144, EFFECT_MANDEL , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(152, EFFECT_CIRCLES, OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot(160, EFFECT_BLOBS  , OVERLAY_VUMETER1, FLASH_ON  ),
        glow_fields_slot(168, EFFECT_DIGITS , OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot(176, EFFECT_DIGITS , OVERLAY_COMPUTER, FLASH_ON  ),
        glow_fields_slot(184, EFFECT_APOLLO , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(192, EFFECT_APOLLO , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(200, EFFECT_MANDEL , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(208, EFFECT_MANDEL , OVERLAY_VUMETER2, FLASH_ON  ),
        glow_fields_slot(216, EFFECT_NONE   , OVERLAY_COMPUTER, FLASH_OFF ),
        glow_fields_slot(224, EFFECT_NONE   , OVERLAY_COMPUTER, FLASH_OFF ),
      ];


      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
          time_slots[slot] = current_script;
          ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        const i = clamp(Math.floor(time/beat), 0, max_time_slots-1);
        return time_slots[i];
      }

      // Called after initialization of all shaders are complete
      function on_init_complete() {
        const label = document.getElementById("info-label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }

      function on_loading_scene(key) {
        const label = document.getElementById("info-label");
        label.textContent = "Compiling: " + key;
      }

      function on_select_scene(gl, time) {
        if (time > start) {
          const gtime = time - start;
          const slot = get_slot(gtime);
          if(slot && slot.scene) {
            return [slot.scene, slot];
          } else {
            return [all_scenes.red_scene, null];
          }
        } else {
          return [all_scenes.red_scene, null];
        }
      }

      function on_render_scene(gl, time, scene, payload) {
        if (scene.uniformLocations.g_state && Array.isArray(payload.g_state) && payload.g_state.length === 3) {
          const v = payload.g_state;
          gl.uniform3i(scene.uniformLocations.g_state, v[0], v[1], v[2]);
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" preload="auto" style="visibility: hidden;" controls src="neon-workout--we-are-the-robots-baby.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>impulse-0011: We Are The Robots Baby</h1>

      <p>Music <a target="_blank" href="https://soundcloud.com/no-om-uo-n/we-are-the-robots-baby">We Are The Robots Baby</a> by <a target="_blank" href="https://soundcloud.com/no-om-uo-n">Neon Workout</a>.</p>

      <p id="info-label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="glcanvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <canvas id="offscreen-canvas" width="512" height="512" style="display: none"></canvas>
</html>