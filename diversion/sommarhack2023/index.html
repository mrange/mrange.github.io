<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Sommarhack 2023</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.1;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_star_travelling" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.1;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         146.0

      const float planeDist = 1.0-0.825;

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash3(vec3 r)  {
        return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      vec2 soff(float h0) {
        float h1 = fract(h0*8677.0);
        return -1.0+2.0*vec2(h0, h1);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return (offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/dot(pp, pp);
      }

      vec3 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {
        float l = distance(ro, pp);
        vec3 hn;
        vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;

        p *= 1.0+l*l;

        const float csz = 0.15;
        const float co  = 0.33*csz;

        vec3 col = vec3(0.0);

        const float cnt = 5.0;
        const float icnt = 1.0/cnt;
        for (float i = 0.0; i < 1.0; i += icnt) {
          vec2 cp = p;
          vec2 cn = mod2(cp, vec2(csz));

          float h0 = hash3(vec3(cn, n)+123.4+i);
          float h1 = fract(3677.0*h0);

          cp += soff(h0)*co;

          float cl = length(cp);
          float d = (cl-0.0005);
          d = max(d, 0.0001);

          vec3 bcol = 0.000005*(1.0+sin(vec3(0.0, 1.0, 2.0)+ TAU*h1));
          bcol *= smoothstep(0.17*csz, 0.05*csz, cl)*0.15/(d*d*(l*l+0.01));

          col += bcol;
          p += icnt;
          p *= ROT(1.0);
        }


        return col;
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 1.0/RESOLUTION.xy;
        float rdd = 3.0;

        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 9;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 col = skyColor(ro, rd);

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0) {
            vec3 pp = ro + rd*pd;
            vec3 npp = ro + nrd*pd;

            float aa = 3.0*length(pp - npp);

            vec3 off = offset(pp.z);

            vec3 pcol = plane(ro, rd, pp, off, aa, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
            pcol *= fadeOut*fadeIn;

            col += pcol;
          }
        }

        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float tm  = planeDist*TIME*BPM/60.0;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        vec3 col = color(ww, uu, vv, ro, p);
        col -= .1*vec3(0.0, 1.0, 2.0).zyx*length(pp);
        col *= smoothstep(1.5, 0.5, length(pp));
        col = aces_approx(col);
        col = sRGB(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, pp);

        frag_color = vec4(col, 1.0);
      }

    </script>

    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        sommarhack2023__the_crew : {
          image : (gl) => document.getElementById("sommarhack2023__the_crew"),
        },
      }

      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red"    ,
            },
          ],
        },
        star_travelling_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_000_star_travelling"  ,
            },
          ],
        }
      };

      const bpm   = 146.0;
      const bhz   = bpm/60.0;
      const start = 2.153;
      function btime(b) {
        return (8.0*b/bhz+start);
      }

      const max_time_slots  = 64;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.star_travelling_scene ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        if (time < start) {
          return all_scenes.red_scene;
        }
        const i = clamp(Math.floor((time-start)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function on_init_complete(width, height) {
        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.red_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="space_buddha__mental_hotline.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Sommarhack 2023</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="sommarhack2023__the_crew" src="sommarhack2023__the_crew.png" style="display: none"/>
  </body>
</html>