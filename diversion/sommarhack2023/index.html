<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Sommarhack 2023</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_star_travelling" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         146.0

      const float planeDist = 1.0-0.825;

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash3(vec3 r)  {
        return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      vec2 soff(float h0) {
        float h1 = fract(h0*8677.0);
        return -1.0+2.0*vec2(h0, h1);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return (offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0001);
      }

      vec3 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {
        float l = distance(ro, pp);
        vec3 hn;
        vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;

        p *= 1.0+l*l;

        const float csz = 0.15;
        const float co  = 0.33*csz;

        vec3 col = vec3(0.0);

        const float cnt = 5.0;
        const float icnt = 1.0/cnt;
        for (float i = 0.0; i < 1.0; i += icnt) {
          vec2 cp = p;
          vec2 cn = mod2(cp, vec2(csz));

          float h0 = hash3(vec3(cn, n)+123.4+i);
          float h1 = fract(3677.0*h0);

          cp += soff(h0)*co;

          float cl = length(cp);
          float d = (cl-0.0005);
          d = max(d, 0.0001);

          vec3 bcol = 0.000005*(1.0+sin(vec3(0.0, 1.0, 2.0)+ TAU*h1));
          bcol *= smoothstep(0.17*csz, 0.05*csz, cl)*0.15/(d*d*(l*l+0.01));

          col += bcol;
          p += icnt;
          p *= ROT(1.0);
        }


        return col;
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 1.0/RESOLUTION.xy;
        float rdd = 3.0;

        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 9;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 col = skyColor(ro, rd);

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0) {
            vec3 pp = ro + rd*pd;
            vec3 npp = ro + nrd*pd;

            float aa = 3.0*length(pp - npp);

            vec3 off = offset(pp.z);

            vec3 pcol = plane(ro, rd, pp, off, aa, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
            pcol *= fadeOut*fadeIn;

            col += pcol;
          }
        }

        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float tm  = planeDist*TIME*BPM/60.0;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        float fi = smoothstep(BTIME(0.25), BTIME(0.0), TIME);
        vec3 col = color(ww, uu, vv, ro, p);
        col -= .1*vec3(0.0, 1.0, 2.0).zyx*length(pp);
        col *= smoothstep(1.5, 0.5, length(pp));
        col = aces_approx(col);
        col += fi;
        col = sqrt(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_002_hexler_march" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         146.0

      const float planeDist = 1.0-0.5;

      // License: Unknown, author: Unknown, found: don't remember
      vec4 alphaBlend(vec4 back, vec4 front) {
        float w = front.w + back.w*(1.0-front.w);
        vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;
        return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec3 alphaBlend(vec3 back, vec4 front) {
        return mix(back, front.xyz, front.w);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(in vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.3*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toPolar(vec2 p) {
        return vec2(length(p), atan(p.y, p.x));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toRect(vec2 p) {
        return vec2(p.x*cos(p.y), p.x*sin(p.y));
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec4 effect(vec2 p, float aa, float h) {
        vec2 hhn = hextile(p);
        const float w = 0.02;
        vec2 pp = toPolar(p);
        float a = pp.y;
        float hn = mod1(pp.y, TAU/6.0);
        vec2 hp = toRect(pp);
        float hd = hp.x-(w*10.0);

        float x = hp.x-0.5*w;
        float n = mod1(x, w);
        float d = abs(x)-(0.5*w-aa);

        float h0 = hash(10.0*hhn+2.0*h+n);
        float h1 = fract(8667.0*h0);
        float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));
        const float coln = 6.0;
        float t = smoothstep(aa, -aa, d)*smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*time+h1*TAU))*exp(-150.0*abs(x));
        vec3 col = (1.0+cos(1.5*vec3(0.0, 1.0, 2.0)+TAU*floor(h0*coln)/coln))*t;

        t = mix(0.9, 1.0, t);
        t *= smoothstep(aa, -aa, -hd);
        if (hd < 0.0) {
          col = vec3(0.0);
          t = 15.*dot(p, p);
        }
        return vec4(col, t);
      }

      vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {
        float h0 = hash(n);
        float h1 = fract(3677.0*h0);
        float h2 = fract(8677.0*h0);

        vec3 hn;
        vec2 p  = (pp-off*vec3(1.0, 1.0, 0.0)).xy;
        p *= ROT(TAU*h0);
        p.x -= 0.25*(pp.z-ro.z)*h2*h2;
        const float z = 0.5;
        p /= z;
        float aa = distance(pp,npp)*sqrt(1.0/3.0)/z;
        vec4 col = effect(p, aa, h1);

        return col;
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0025);

      //  return vec3(0.0);
      }


      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 2.0/RESOLUTION.y;
        float rdd = (2.5-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions
      //  float rdd = 2.0;

        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 4;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 skyCol = skyColor(ro, rd);


        vec4 acol = vec4(0.0);
        const float cutOff = 0.95;
        bool cutOut = false;

        float maxpd = 0.0;

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0 && acol.w < cutOff) {
            vec3 pp = ro + rd*pd;
            maxpd = pd;
            vec3 npp = ro + nrd*pd;

            vec3 off = offset(pp.z);

            vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
      //      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
            pcol.w *= fadeOut*fadeIn;
            pcol = clamp(pcol, 0.0, 1.0);

            acol = alphaBlend(pcol, acol);
          } else {
            cutOut = true;
            acol.w = acol.w > cutOff ? 1.0 : acol.w;
            break;
          }

        }

        vec3 col = alphaBlend(skyCol, acol);
      // To debug cutouts due to transparency
      //  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);
        return col;
      }

      vec3 effect(vec2 p, vec2 q) {
        float tm  = planeDist*0.5*TIME*BPM/60.0;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        vec3 col = color(ww, uu, vv, ro, p);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, q);

        frag_color = vec4(col, 1.0);
      }

    </script>

    <script id="fs_002_hexler_march_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame;
      uniform sampler2D prev_pass;

      #define RESOLUTION  resolution

      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const mat2 brot = ROT(2.399);
      //  simplyfied version of Dave Hoskins blur
      vec3 dblur(vec2 q,float rad) {
        vec3 acc=vec3(0);
        const float m = 0.0025;
        vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);
        vec2 angle=vec2(0,rad);
        rad=1.;
        const int iter = 30;
        for (int j=0; j<iter; ++j) {
          rad += 1./rad;
          angle*=brot;
          vec4 col=texture(prev_frame,q+pixel*(rad-1.)*angle);
          col.xyz*=col.xyz;
          acc+=col.xyz;
        }
        return acc*(1.0/float(iter));
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec4 pcol = texture(prev_pass,q);
        vec3 bcol = dblur(q, .75);

        vec3 col = pcol.xyz;
        col += vec3(0.9, .8, 1.2)*mix(0.5, 0.8, length(pp))*(vec3(0.05)+bcol);
        float fi = smoothstep(BTIME(4.25), BTIME(4.0), TIME);
        col = overlay(col, p, 1.0);
        col += fi;
        col = sqrt(col);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_003_hyper_space" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define TIME            time
      #define RESOLUTION      resolution
      #define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))


      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0001);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
      vec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {
        vec3  oc = ro - cb;
        float card = dot(ca,rd);
        float caoc = dot(ca,oc);
        float a = 1.0 - card*card;
        float b = dot( oc, rd) - caoc*card;
        float c = dot( oc, oc) - caoc*caoc - cr*cr;
        float h = b*b - a*c;
        if( h<0.0 ) return vec2(-1.0); //no intersection
        h = sqrt(h);
        return vec2(-b-h,-b+h)/a;
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float fo = smoothstep(BTIME(12.0), BTIME(10.0), TIME);
        float rdd = mix(0.1, 2.0, fo);
        const float mm  = 5.0;
        const float rep = 26.0;

        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);

        vec3 skyCol = skyColor(ro, rd);

        vec2 etc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), 1.0);
        vec3 etcp = ro+rd*etc.y;
        rd.yx *= ROT(0.3*etcp.z);

        vec3 col = skyCol;

        // I read somewhere that if you call atan in a shader you got no business writing shader code.
        float a = atan(rd.y, rd.x);
        for(float i = 0.0; i < mm; ++i) {
          float ma = a;
          float sz = rep+i*9.0;
          float slices = TAU/sz;
          float na = mod1(ma, slices);

          float h1 = hash(na+13.0*i+123.4);
          float h2 = fract(h1*3677.0);
          float h3 = fract(h1*8677.0);
          float h5 = fract(h1*9677.0);

          float tr = mix(0.5, 3.0, h1);
          vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);
          vec3 tcp = ro + tc.y*rd;
          vec2 tcp2 = vec2(tcp.z, a);

          float zz = mix(0.025, 0.05, sqrt(h1))*rep/sz;
          float tnpy = mod1(tcp2.y, slices);
          float fo = smoothstep(0.5*slices, 0.25*slices, abs(tcp2.y));
          tcp2.x += 0.5*h2*TIME;
          tcp2.y *= tr*(PI/3.0);
          vec2 tcp3 = tcp2;
          float w = mix(.2, 1.0, h2);
          float tnpx = mod1(tcp3.x, w);
          float h4 = hash(tnpx+123.4);

          tcp2/=zz;
          tcp3/=zz;
          float d1 = abs(tcp2.y);

          float d2 = length(tcp3) - 2.0*h4;
          d2 = abs(d2)-1.0*h4;
          d2 = abs(d2)-0.5*h4;
          float d = h5 > 0.5 ? d2 : d1;
          d *= zz;

          vec3 bcol = (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*h3+0.5*h2*h2*tcp.z))*0.00005;
          bcol /= max(d*d, 0.00001+5E-7*tc.y*tc.y);
          bcol *= exp(-0.04*tc.y*tc.y);
          bcol *= smoothstep(-0.5, 1.0, sin(mix(0.125, 1.0, h2)*tcp.z));
          bcol *= fo;
          col += bcol;
        }

        return col;
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 effect(vec2 p, vec2 pp) {
        float tm  = 3.5*TIME;
        vec3 ro   = vec3(0.0, 0.0, tm);
        vec3 dro  = normalize(vec3(1.0, 0.0, 3.0));
        dro.xz *= ROT(0.2*sin(0.05*tm));
        dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));
        const vec3 up = vec3(0.0,1.0,0.0);
        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(up, ww));
        vec3 vv = (cross(ww, uu));
        vec3 col = color(ww, uu, vv, ro, p);
        col -= 0.125*vec3(0.0, 1.0, 2.0).yzx*length(pp);
        float fi = smoothstep(BTIME(8.25), BTIME(8.0), TIME);
        float fo = smoothstep(BTIME(12.0), BTIME(11.5), TIME);
        col *= sqrt(fo);
        col = aces_approx(col);
        col = overlay(col, p, 2.0);
        col += fi;
        col = sqrt(col);
        return col;
      }

      void main(void) {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, pp);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_004_cables" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define TOLERANCE       0.0001
      #define NORMTOL         0.00125
      #define MAX_RAY_LENGTH  20.0
      #define MAX_RAY_MARCHES 90
      #define TIME            time
      #define RESOLUTION      resolution
      #define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define MAX_ITER        3

      // https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      #define PATHA vec2(0.1147, 0.2093)
      #define PATHB vec2(13.0, 3.0)

      const float cam_amp =1.;

      mat2 g_rot = mat2(1.0);
      float g_quad = 0.0;
      int g_hit = 0;

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float roundedX(vec2 p, float w, float r) {
        p = abs(p);
        return length(p-min(p.x+p.y,w)*0.5) - r;
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions
      float sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
          float ndbuffer = dbuffer/sph.w;
          vec3  rc = (ro - sph.xyz)/sph.w;

          float b = dot(rd,rc);
          float c = dot(rc,rc) - 1.0;
          float h = b*b - c;
          if( h<0.0 ) return 0.0;
          h = sqrt( h );
          float t1 = -b - h;
          float t2 = -b + h;

          if( t2<0.0 || t1>ndbuffer ) return 0.0;
          t1 = max( t1, 0.0 );
          t2 = min( t2, ndbuffer );

          float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
          float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
          return (i2-i1)*(3.0/4.0);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 cam_path(float z) {
        return vec3(cam_amp*sin(z*PATHA)*PATHB, z);
      }

      vec3 dcam_path(float z) {
        return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);
      }

      vec3 ddcam_path(float z) {
        return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);
      }

      float cables(vec3 p3) {
        const float cylr = 0.2;
        vec2 p = p3.xy;
        float t = p3.z;

        const float ss = 1.5;
        mat2 pp = ss*ROT(1.0+0.5*p3.z);

        p *= g_rot;
        float s = 1.0;

        float d = 1E6;
        float quad = 1.0;
        int hit = 0;
        for (int i = 0; i < MAX_ITER; ++i) {
          p *= pp;
          p = abs(p);
          p -= 1.35*s;
          s *= 1.0/ss;
          const float sz = 1.0;

          float dd = roundedX(p, sz*1.5*cylr, sz*0.25*cylr)*s;
          vec2 s = sign(p);
          float q = s.x*s.y;

          if (dd < d) {
            d = dd;
            quad = q;
            hit = i;
          }

        }

        g_quad = quad;
        g_hit = hit;

        return d;
      }

      float df(vec3 p) {
        // Found this world warping technique somewhere but forgot which shader :(
        vec3 cam = cam_path(p.z);
        vec3 dcam = normalize(dcam_path(p.z));
        p.xy -= cam.xy;
        p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);
        float d = cables(p);

        return d;
      }

      float rayMarch(in vec3 ro, in vec3 rd, out int iter) {
        float t = 0.0;
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          t += d;
        }
        iter = i;
        return t;
      }

      vec3 normal(in vec3 pos) {
        vec3  eps = vec3(NORMTOL,0.0,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {
        const float minShadow = 0.25;
        float res = 1.0;
        float t = mint;
        for (int i=0; i<25; ++i) {
          float distance = df(pos + ld*t);
          res = min(res, k*distance/t);
          if (ll <= t) break;
          if(res <= minShadow) break;
          t += max(mint*0.2, distance);
        }
        return clamp(res,minShadow,1.0);
      }

      vec3 render(vec3 ro, vec3 rd, float tm) {
        vec3 lightPos0  = cam_path(tm-0.5);
        vec3 lightPos1  = cam_path(tm+6.5);

        vec3 skyCol = vec3(0.0);

        int iter = 0;
        float t = rayMarch(ro, rd, iter);
        float quad = g_quad;
        float hit  = float(g_hit);

        float tt = float(iter)/float(MAX_RAY_MARCHES);
        float bs = 1.0-tt*tt*tt*tt;

        vec3 pos = ro + t*rd;

        float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);
        float beat  = beat(TIME);
        const float hoff = 0.;
        const vec3 bcol0 = HSV2RGB(vec3(hoff+0.6, 0.7, 3.0));
        const vec3 bcol1 = HSV2RGB(vec3(hoff+0.55, 0.5, 7.0));
        vec3 bcol   = mix(bcol0, bcol1, beat);
        vec3 gcol   = lsd1*bcol;

        if (t >= MAX_RAY_LENGTH) {
          return skyCol+gcol;
        }

        vec3 nor    = normal(pos);

        vec3 lv0    = lightPos0 - pos;
        float ll20  = dot(lv0, lv0);
        float ll0   = sqrt(ll20);
        vec3 ld0    = lv0 / ll0;
        float dm0   = 8.0/ll20;
        float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);
        float dif0  = max(dot(nor,ld0),0.0)*dm0;

        vec3 lv1    = lightPos1 - pos;
        float ll21  = dot(lv1, lv1);
        float ll1   = sqrt(ll21);
        vec3 ld1    = lv1 / ll1;
        float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);

        vec3 col = vec3(0.0);

        const vec3 black = vec3(0.0);
        const vec3 dcol0 = black;
        const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));
        col += dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);
        col += spe1*bcol*bs;
        col += gcol;

        return col;
      }

      vec3 effect3d(vec2 p, vec2 pp) {
        float tm = 2.0*TIME;
        g_rot = ROT(-0.2*tm);
        vec3 cam  = cam_path(tm);
        vec3 dcam = dcam_path(tm);
        vec3 ddcam= ddcam_path(tm);

        vec3 ro = cam;
        vec3 ww = normalize(dcam);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));
        vec3 vv = normalize(cross(ww,uu));
        float rdd = (2.0+0.75*tanh_approx(dot(p, p)));
        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);

        vec3 col = render(ro, rd, tm);
        col -= 0.075*vec3(0.0, 1.0, 2.0);
        col = aces_approx(col);
        float fi = smoothstep(BTIME(12.25), BTIME(12.0), TIME);
        float fo = smoothstep(BTIME(16.00), BTIME(15.5), TIME);
        col = overlay(col, p, 3.0);
        col += fi;
        col *= fo;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect3d(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_005_the_crew" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D the_crew        ;

      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      const float hoff = 0.59;
      const vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));
      const vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));
      const vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));
      const vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));

      // License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);

      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pabs(float a, float k) {
        return -pmin(a, -a, k);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      float dot2(vec2 p) {
        return dot(p, p);
      }

      vec2 hash(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return -1. + 2.*fract (sin (p)*43758.5453123);
      }

      float noise(vec2 p) {
        const float K1 = .366025404;
        const float K2 = .211324865;

        vec2 i = floor (p + (p.x + p.y)*K1);

        vec2 a = p - i + (i.x + i.y)*K2;
        vec2 o = step (a.yx, a.xy);
        vec2 b = a - o + K2;
        vec2 c = a - 1. + 2.*K2;

        vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);

        vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));

        return dot (n, vec3 (70.));
      }

      float fbm(vec2 pos, float tm) {
        vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));
        float aggr = 0.0;

        aggr += noise(pos);
        aggr += noise(pos + offset) * 0.5;
        aggr += noise(pos + offset.yx) * 0.25;
        aggr += noise(pos - offset) * 0.125;
        aggr += noise(pos - offset.yx) * 0.0625;

        aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;

        float f = (aggr * 0.5) + 0.5;

        return f;
      }

      float divf(float offset, float f) {
        const float goff = 0.2;
        const float gfloor = 0.001;
        float r = abs(goff + offset - f);
        r = max(r, gfloor);
        return r;
      }

      vec3 lightning(vec2 pos, vec2 pp, float offset) {
        vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);

        float time = TIME+123.4;
        float stime = time/200.0;
        vec3 col = vec3(0.0);
        vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;
        const float glow = 0.0125;
        const float goff = 0.2;
        const float gfloor = 0.001;
        for (float i = 0.0; i < 3.0; ++i) {
          vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));
          vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));
          float btime = stime*85.0 + (i);
          float rtime = stime*75.0 + (i);
          float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));
          float div2 = divf(offset, fbm((pos + f) * 2.0, btime));
          float d1 = offset * glow / div1;
          float d2 = offset * glow / div2;
          col += (d1 * gcol0)-sub;
          col += (d2 * gcol1)-sub;
        }

        return col;
      }

      vec3 theCrew(vec3 col, float d, vec2 p) {
        if (d > 0.0) return col;
        vec2 sgn = sign(p);
        float q = (0.5*(sgn.x+1.0)+(-sgn.y+1.0))*0.125;
        const float off = 17.125;
        float fi0 = smoothstep(BTIME(off+q), BTIME(off + 0.125+ q), TIME);
        float fi1 = smoothstep(BTIME(off + .05+q), BTIME(off+q), TIME)*step(BTIME(off+q), TIME);
        p *= 0.5;
        p += 0.5;
        p.y = 1.0-p.y;
        vec4 tcol = texture(the_crew, p);

        col = mix(col, tcol.xyz, tcol.w*fi0)+fi1;
        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float aa = 4.0/RESOLUTION.y;
        float fi0 = smoothstep(BTIME(16.25), BTIME(16.0), TIME);
        float fi1 = smoothstep(BTIME(16.0), BTIME(17.0), TIME);
        vec2 ip = p;
        ip *= ROT(mix(1.55*TAU, -0.1, fi1));
        float z = mix(0.1, 1.0, fi1);
        ip /= z;
        float d = box(ip, vec2(1.0));
        d *= z;
        const vec3 lp = vec3(-4.0, -5.0, 3.0);
        const vec3 ro = vec3(0.0, 0.0, 10.0);
        float gd = d+0.0;
        vec2 gp = p;
        vec3 gcol = lightning(gp, pp, gd);
        vec3 col = vec3(0.0);
        col += gbcol/max(0.025*(d), 0.0001);
        col += gcol;
        col *= smoothstep(1.75, 0.5, length(pp));

        col = aces_approx(col);
        col += fi0;
        col = sqrt(col);
        col = theCrew(col, d, ip);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p, pp);
        frag_color = vec4(col.xyz, 1.0);
      }
    </script>

    <script id="fs_006_moire" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D     font        ;

      float box(vec2 p, vec2 b) {
          vec2 d = abs(p)-b;
          return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float modRadial(inout vec2 p, float o, float m) {
        float l = length(p);
        float k = l;
        l -= o;
        float n = mod1(l, m);

        p = (l/k)*p;
        return n;
      }

      float df(vec2 p) {
        vec2 pr = p;
        const float m = 0.25;
        modRadial(pr, 0.0, m);
        float l = length(pr);
        return abs(l)-(m*0.25);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      vec3 beatCol(vec2 p) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        return 2.0*mix(gcol0, gcol1, b)/max(dot(p, p), 0.00025);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      const vec2 SZ = 32.0/vec2(320.0, 200.0);
      const vec2 HSZ= 0.5*SZ;
      const vec2 A    = vec2(00.0, 00.0)*SZ;
      const vec2 B    = vec2(01.0, 00.0)*SZ;
      const vec2 C    = vec2(02.0, 00.0)*SZ;
      const vec2 D    = vec2(03.0, 00.0)*SZ;
      const vec2 E    = vec2(04.0, 00.0)*SZ;
      const vec2 F    = vec2(05.0, 00.0)*SZ;
      const vec2 G    = vec2(06.0, 00.0)*SZ;
      const vec2 H    = vec2(07.0, 00.0)*SZ;
      const vec2 I    = vec2(08.0, 00.0)*SZ;
      const vec2 J    = vec2(09.0, 00.0)*SZ;
      const vec2 K    = vec2(00.0, 01.0)*SZ;
      const vec2 L    = vec2(01.0, 01.0)*SZ;
      const vec2 M    = vec2(02.0, 01.0)*SZ;
      const vec2 N    = vec2(03.0, 01.0)*SZ;
      const vec2 O    = vec2(04.0, 01.0)*SZ;
      const vec2 P    = vec2(05.0, 01.0)*SZ;
      const vec2 Q    = vec2(06.0, 01.0)*SZ;
      const vec2 R    = vec2(07.0, 01.0)*SZ;
      const vec2 S    = vec2(08.0, 01.0)*SZ;
      const vec2 T    = vec2(09.0, 01.0)*SZ;
      const vec2 U    = vec2(00.0, 02.0)*SZ;
      const vec2 V    = vec2(01.0, 02.0)*SZ;
      const vec2 W    = vec2(02.0, 02.0)*SZ;
      const vec2 X    = vec2(03.0, 02.0)*SZ;
      const vec2 Y    = vec2(04.0, 02.0)*SZ;
      const vec2 Z    = vec2(05.0, 02.0)*SZ;
      const vec2 _0   = vec2(06.0, 02.0)*SZ;
      const vec2 _1   = vec2(07.0, 02.0)*SZ;
      const vec2 _2   = vec2(08.0, 02.0)*SZ;
      const vec2 _3   = vec2(09.0, 02.0)*SZ;
      const vec2 _4   = vec2(00.0, 03.0)*SZ;
      const vec2 _5   = vec2(01.0, 03.0)*SZ;
      const vec2 _6   = vec2(02.0, 03.0)*SZ;
      const vec2 _7   = vec2(03.0, 03.0)*SZ;
      const vec2 _8   = vec2(04.0, 03.0)*SZ;
      const vec2 _9   = vec2(05.0, 03.0)*SZ;
      const vec2 _A   = vec2(06.0, 03.0)*SZ;
      const vec2 _PO  = vec2(07.0, 03.0)*SZ;
      const vec2 _PC  = vec2(08.0, 03.0)*SZ;
      const vec2 _E   = vec2(09.0, 03.0)*SZ;
      const vec2 _C   = vec2(00.0, 04.0)*SZ;
      const vec2 _D   = vec2(01.0, 04.0)*SZ;
      const vec2 _P   = vec2(02.0, 04.0)*SZ;
      const vec2 _CO  = vec2(03.0, 04.0)*SZ;
      const vec2 _   = vec2(04.0, 04.0)*SZ;

      const vec2[] ScrollText = vec2[](
        _
        ,P,R,O,T,O,N
        ,_,_
        ,T,H,E,_,C,A,P,T,A,I,N,_,C,O,D,E,R
        ,_,_
        ,T,H,E,_,G,R,U,M,P,Y,_,G,A,M,E,_,D,E,V
        ,_,_
        ,B,I,G,_,W,I,N,G,S
        ,_,_
        ,B,Y,T,_3,M,_3,C,H,A,N,I,C
        ,_,_
        ,D,A,V,E,_,H,O,S,K,I,N,S
        ,_,_
        ,E,V,I,L,R,Y,U
        ,_,_
        ,E,V,V,V,I,L
        ,_,_
        ,I,Q
        ,_,_
        ,K,A,L,I
        ,_,_
        ,N,I,M,I,T,Z
        ,_,_
        ,S,H,A,N,E
        ,_,_
        ,T,H,I,N,D,A,L
        ,_,_
        ,T,O,T,E,T,M,A,T,T
        );
      const float ScrollMod = float(ScrollText.length())-1.0;

      float scrollText(vec2 p) {

        float gd = min(abs(p.x), abs(p.y));
        vec2 tp = p;
        tp.x *= 1.0/(320.0/200.0);
        tp.y = -tp.y;
        float n = mod(mod1(tp.x, SZ.x), ScrollMod);
        vec2 cp = ScrollText[int(n)];
        float a = step(abs(tp.x), HSZ.x)*step(abs(tp.y), HSZ.y);
        tp += HSZ;
        tp += cp;
        float t = texture(font, tp).w*a;

        return t;
      }

      vec2 toSmith(vec2 p)  {
        // z = (p + 1)/(-p + 1)
        // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)
        float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;
        float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;
        float y = 2.0*p.y;
        return vec2(x,y)/d;
      }

      vec2 fromSmith(vec2 p)  {
        // z = (p - 1)/(p + 1)
        // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)
        float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;
        float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;
        float y = 2.0*p.y;
        return vec2(x,y)/d;
      }


      vec2 transform(vec2 p) {
        p *= ROT(-0.2);
        float tm = TIME-BTIME(20.0)-10.0;
        vec2 sp0 = toSmith(p-0.);
        vec2 sp1 = toSmith(p+vec2(1.0)*ROT(0.12*tm));
        vec2 sp2 = toSmith(p-vec2(1.0)*ROT(0.23*tm));
        p = fromSmith(sp0+(sp1-sp2));
        p += TIME*vec2(0.0, -0.5);
        return p;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      vec3 scrollText(vec3 col, vec2 p) {
        const float bsz = 0.01;
        const float msz = bsz*0.1;
        const float csz = 2.0*(bsz+msz);
        const float rnd = bsz*0.5;
        vec2 tp = transform(p);
        float delta = (8.0/sqrt(2.0))/RESOLUTION.y;
        vec2 ntp = transform(p+delta);
        float aa = distance(ntp, tp);
        vec2 cp = tp;
        float tm = TIME - BTIME(20.0);
        float ny = mod1(cp.y, 0.5*36.0*csz);
        float hy = hash(ny+1234.5);
        float h0 = hash(ny+123.4);
        cp.x += 0.5*mix(1.0, 3.0, hy*hy)*TIME+hy*128.0;
        vec2 cn = mod2(cp, vec2(csz));
        float ch0 = hash(cn);
        float ch1 = fract(3677.0*ch0);
        float ch2 = fract(8677.0*ch0);

        vec2 sp = cn*vec2(2.0/200.0);

        float cd0 = box(cp, vec2(bsz-rnd))-rnd;
        float cd1 = dot(cp, cp);

        float t = scrollText(sp);
        vec3 scol = (1.0+cos(PI+PI*h0+vec3(0.0, 1.0, 2.0)+0.25*TAU*ch0));
        scol = mix(col, scol, clamp(delta/aa, 0.0, 1.0));
        scol *= mix(1.0, sqrt(ch1), beat(ch2*TIME+10.0*ch2));
        col = mix(col, scol, smoothstep(0.0, -aa, cd0)*t);
        col += 2.0*sqrt(aa)*beat(TIME)*HSV2RGB(vec3(0.55, 0.7, 1.0));

        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float aa = 4.0/RESOLUTION.y;
        float tm = TIME*0.5;
        vec2 p0 = p+sin(vec2(1.0, sqrt(0.5)).yx*(tm+100.0));
        vec2 p1 = p+sin(1.3*vec2(1.0, sqrt(0.5))*(tm+300.0));
        vec2 p2 = 0.5*(p0+p1);
        float sm = 0.0666*length(p);
        float d0 = df(p0);
        float d1 = df(p1);
        float d = d0;
        d = pmax(d, d1, sm);
        float dd = -d0;
        dd = pmax(dd, -d1, sm);
        d =  min(d, dd);
        const float so = 8.0;
        const float co = 0.5;
        vec3 bcol0 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p0)+1.0-TIME))/(so*dot(p0, p0)+0.0001);
        vec3 bcol1 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p1)+3.0+TIME))/(so*dot(p1, p1)+0.0001);
        vec3 bcol2 = beatCol(p2);

        vec3 bcol = (bcol0+bcol1);
        vec3 col = vec3(0.0);
        col += 0.005*bcol/(max(dd+0.005, 0.0)+0.0001);
        col = mix(col, bcol, smoothstep(0.0, -aa, d));
        col += bcol2;
        col -= 0.25*vec3(0.0, 1.0, 2.0).zyx*length(pp);
        col *= smoothstep(1.5, 0.5, length(pp));
        col = scrollText(col, p);
        col = aces_approx(col);
        float fi = smoothstep(BTIME(20.25), BTIME(20.00), TIME);
        float fo = smoothstep(BTIME(24.0), BTIME(23.50), TIME);
        col += fi;
        col *= fo;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_007_bounce" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D font  ;

      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define TIME            time
      #define RESOLUTION      resolution
      #define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PCOS(x)         (0.5+0.5*cos(x))

      #define TOLERANCE       0.00001
      #define MAX_RAY_LENGTH  10.0
      #define MAX_RAY_MARCHES 50
      #define NORM_OFF        0.0001

      #define TBEAT           (-(TIME-bstart)*bpm/60.0)
      #define TTBEAT          (TAU*TBEAT)

      const vec3  std_gamma  = vec3(2.2);
      const float smoothing  = 0.066;

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      float boxf(vec3 p, vec3 b, float e) {
        p = abs(p  )-b;
        vec3 q = abs(p+e)-e;
        return min(min(
            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
      }

      float pmin(float a, float b, float k) {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      vec3 pmin(vec3 a, vec3 b, float k) {
        vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      vec3 pabs(vec3 a, float k) {
        return -pmin(a, -a, k);
      }

      vec3 refl(vec3 p, vec3 n) {
        p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;
        return p;
      }

      float sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
          float ndbuffer = dbuffer/sph.w;
          vec3  rc = (ro - sph.xyz)/sph.w;

          float b = dot(rd,rc);
          float c = dot(rc,rc) - 1.0;
          float h = b*b - c;
          if( h<0.0 ) return 0.0;
          h = sqrt( h );
          float t1 = -b - h;
          float t2 = -b + h;

          if( t2<0.0 || t1>ndbuffer ) return 0.0;
          t1 = max( t1, 0.0 );
          t2 = min( t2, ndbuffer );

          float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
          float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
          return (i2-i1)*(3.0/4.0);
      }

      float df(vec3 p) {
        vec3 op = p;
        const float zf = 2.5;
        const int mid  = 1;
        const int end  = 3;
        const vec3 n0  = normalize(vec3(-1.0,  1.0,  1.0));
        const vec3 n1  = normalize(vec3( 1.0, -1.0,  1.0));
        const vec3 n2  = normalize(vec3( 1.0,  1.0, -1.0));
        const vec3 off = normalize(vec3(1.0, 1.0, 1.0));

        float d = 1E6;
        float z = 1.0;
        vec3  cp = off;

        mat2 rxy = ROT(0.5*time*sqrt(0.5));
        mat2 ryz = ROT(0.5*time);

        for (int i = 0; i < mid; ++i) {
          p.xy *= rxy;
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*0.33;
          p *= zf;
          z *= zf;
        }

        float sb = smoothstep(-0.75, 0.75, cos(PI+TTBEAT+4.0*length(op)+4.0*op.x));
        float rr = mix(0.24, 0.33, sb);
        for (int i = mid; i < end; ++i) {
          p.xy *= ROT(1.0);
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*rr;
          p *= zf;
          z *= zf;

          vec3 pp = p;
          float dd0 = boxf(pp, 0.1*vec3(1.0), 0.0125)-0.0125;
          float dd1 = length(pp)- 0.075;
          float dd = dd0;
          dd = min(dd, dd1);
          dd /= z;
          d = min(d, dd);
        }

        return d;
      }

      float rayMarch(vec3 ro, vec3 rd, out int iter) {
        float t = 0.0;
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          t += d;
        }
        iter = i;
        return t;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {
        const float minShadow = 0.25;
        float res = 1.0;
        float t = mint;
        for (int i=0; i<24; i++) {
          float d = df(pos + ld*t);
          res = min(res, k*d/t);
          if (ll <= t) break;
          if(res <= minShadow) break;
          t += max(mint*0.2, d);
        }
        return clamp(res,minShadow,1.0);
      }

      vec3 render(vec3 col, vec3 ro, vec3 rd) {
        vec3 lightPos = vec3(1.0);
        float alpha   = 0.05*TIME;

        int iter    = 0;
        float t     = rayMarch(ro, rd, iter);

        float sb    = smoothstep(-0.5, 0.5, cos(TTBEAT));
        float sr    = mix(0.4, 0.45, sb);
        vec3 gf     = mix(1.5*vec3(2., 1.0, 0.75), 3.5*vec3(1.75, 1.5, 1.5), sb);
        float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);

        vec3 gcol   = sd*gf;

        if (t >= MAX_RAY_LENGTH) {
          return gcol+col;
        }

        vec3 pos    = ro + t*rd;
        vec3 nor    = normal(pos);
        vec3 refl   = reflect(rd, nor);
        float ii    = float(iter)/float(MAX_RAY_MARCHES);
        float ifade = 1.0-tanh_approx(1.25*ii);
        float h     = fract(-1.0*length(pos)+0.1);
        float s     = 0.25;
        float v     = tanh_approx(0.4/(1.0+40.0*sd));
        vec3 color  = hsv2rgb(vec3(h, s, v));

        vec3 lv   = lightPos - pos;
        float ll2 = dot(lv, lv);
        float ll  = sqrt(ll2);
        vec3 ld   = lv / ll;
        float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);

        float dm  = 4.0/ll2;
        float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;
        float spe = pow(max(dot(refl, ld), 0.), 20.);
        float ao  = smoothstep(0.5, 0.1 , ii);
        float l   = mix(0.2, 1.0, dif*sha*ao);

        col = l*color + 2.0*spe*sha;
        col *= ifade;
        col += gcol;
        return col;
      }

      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      const vec2 SZ = 32.0/vec2(320.0, 200.0);
      const vec2 HSZ= 0.5*SZ;
      const vec2 A    = vec2(00.0, 00.0)*SZ;
      const vec2 B    = vec2(01.0, 00.0)*SZ;
      const vec2 C    = vec2(02.0, 00.0)*SZ;
      const vec2 D    = vec2(03.0, 00.0)*SZ;
      const vec2 E    = vec2(04.0, 00.0)*SZ;
      const vec2 F    = vec2(05.0, 00.0)*SZ;
      const vec2 G    = vec2(06.0, 00.0)*SZ;
      const vec2 H    = vec2(07.0, 00.0)*SZ;
      const vec2 I    = vec2(08.0, 00.0)*SZ;
      const vec2 J    = vec2(09.0, 00.0)*SZ;
      const vec2 K    = vec2(00.0, 01.0)*SZ;
      const vec2 L    = vec2(01.0, 01.0)*SZ;
      const vec2 M    = vec2(02.0, 01.0)*SZ;
      const vec2 N    = vec2(03.0, 01.0)*SZ;
      const vec2 O    = vec2(04.0, 01.0)*SZ;
      const vec2 P    = vec2(05.0, 01.0)*SZ;
      const vec2 Q    = vec2(06.0, 01.0)*SZ;
      const vec2 R    = vec2(07.0, 01.0)*SZ;
      const vec2 S    = vec2(08.0, 01.0)*SZ;
      const vec2 T    = vec2(09.0, 01.0)*SZ;
      const vec2 U    = vec2(00.0, 02.0)*SZ;
      const vec2 V    = vec2(01.0, 02.0)*SZ;
      const vec2 W    = vec2(02.0, 02.0)*SZ;
      const vec2 X    = vec2(03.0, 02.0)*SZ;
      const vec2 Y    = vec2(04.0, 02.0)*SZ;
      const vec2 Z    = vec2(05.0, 02.0)*SZ;
      const vec2 _0   = vec2(06.0, 02.0)*SZ;
      const vec2 _1   = vec2(07.0, 02.0)*SZ;
      const vec2 _2   = vec2(08.0, 02.0)*SZ;
      const vec2 _3   = vec2(09.0, 02.0)*SZ;
      const vec2 _4   = vec2(00.0, 03.0)*SZ;
      const vec2 _5   = vec2(01.0, 03.0)*SZ;
      const vec2 _6   = vec2(02.0, 03.0)*SZ;
      const vec2 _7   = vec2(03.0, 03.0)*SZ;
      const vec2 _8   = vec2(04.0, 03.0)*SZ;
      const vec2 _9   = vec2(05.0, 03.0)*SZ;
      const vec2 _A   = vec2(06.0, 03.0)*SZ;
      const vec2 _PO  = vec2(07.0, 03.0)*SZ;
      const vec2 _PC  = vec2(08.0, 03.0)*SZ;
      const vec2 _E   = vec2(09.0, 03.0)*SZ;
      const vec2 _C   = vec2(00.0, 04.0)*SZ;
      const vec2 _D   = vec2(01.0, 04.0)*SZ;
      const vec2 _P   = vec2(02.0, 04.0)*SZ;
      const vec2 _CO  = vec2(03.0, 04.0)*SZ;
      const vec2 _   = vec2(04.0, 04.0)*SZ;

      const vec2[] ScrollText = vec2[](
         _
        ,D,E,L,T,A,_,F,O,R,C,E
        ,_,_
        ,L,E,O,N,A,R,D
        ,_,_
        ,L,O,T,E,K,_,S,T,Y,L,E
        ,_,_
        ,N,O,_,C,R,E,W
        ,_,_
        ,O,M,E,G,A
        ,_,_
        ,O,X,Y,G,E,N,E
        ,_,_
        ,T,H,E,_,C,A,R,E,B,E,A,R,S
        ,_,_
        ,T,H,E,_,L,O,S,T,_,B,O,Y,S
        ,_,_
        ,T,H,E,_,O,V,E,R,L,A,N,D,E,R,S
        ,_,_
        ,T,H,E,_,U,N,I,O,N
        ,_,_
        ,X,I,A
        ,_,_
        ,Y,M,_,R,O,C,K,E,R,Z
        );
      const float ScrollMod = float(ScrollText.length())-1.0;

      float scrollText(vec2 p) {

        float gd = min(abs(p.x), abs(p.y));
         vec2 tp = p;
        tp.x *= 1.0/(320.0/200.0);
        tp.y = -tp.y;
        float n = mod(mod1(tp.x, SZ.x), ScrollMod);
        vec2 cp = ScrollText[int(n)];
        float a = step(abs(tp.x), HSZ.x)*step(abs(tp.y), HSZ.y);
        tp += HSZ;
        tp += cp;
        float t = texture(font, tp).w*a;

        return t;
      }

      vec2 toSmith(vec2 p)  {
        // z = (p + 1)/(-p + 1)
        // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)
        float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;
        float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;
        float y = 2.0*p.y;
        return vec2(x,y)/d;
      }

      vec2 fromSmith(vec2 p)  {
        // z = (p - 1)/(p + 1)
        // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)
        float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;
        float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;
        float y = 2.0*p.y;
        return vec2(x,y)/d;
      }


      vec2 transform(vec2 p) {
        p *= ROT(-0.2);
        float tm = TIME-BTIME(20.0)-10.0;
        vec2 sp0 = toSmith(p-0.);
        vec2 sp1 = toSmith(p+vec2(1.0)*ROT(0.12*tm));
        vec2 sp2 = toSmith(p-vec2(1.0)*ROT(0.23*tm));
        p = fromSmith(sp0+(sp1-sp2));
        p += TIME*vec2(0.0, -0.5);
        return p;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      vec3 scrollText(vec3 col, vec2 p) {
        const float bsz = 0.01;
        const float msz = bsz*0.1;
        const float csz = 2.0*(bsz+msz);
        const float rnd = bsz*0.5;
        vec2 tp = transform(p);
        float delta = (8.0/sqrt(2.0))/RESOLUTION.y;
        vec2 ntp = transform(p+delta);
        float aa = distance(ntp, tp);
        vec2 cp = tp;
        float tm = TIME - BTIME(20.0);
        float ny = mod1(cp.y, 0.5*36.0*csz);
        float hy = hash(ny+1234.5);
        float h0 = hash(ny+123.4);
        cp.x += 0.5*mix(1.0, 3.0, hy*hy)*TIME+hy*128.0;
        vec2 cn = mod2(cp, vec2(csz));
        float ch0 = hash(cn);
        float ch1 = fract(3677.0*ch0);
        float ch2 = fract(8677.0*ch0);

        vec2 sp = cn*vec2(2.0/200.0);

        float cd0 = box(cp, vec2(bsz-rnd))-rnd;
        float cd1 = dot(cp, cp);

        float t = scrollText(sp);
        vec3 scol = mix(col, vec3(.5), clamp(delta/aa, 0.0, 1.0));
        col = mix(col, scol, smoothstep(0.0, -aa, cd0)*t);

        return col;
      }

      vec3 effect3d(vec2 p, vec2 pp) {
        float z   = TIME;
        vec3 cam  = 1.2*vec3(1.0, 0.5, 0.0);

        const float slowbeatp = bperiod*1.0/16.0;
        float slowbeatf = 1.0-mod(TIME-bstart, slowbeatp)/slowbeatp;

        float rt  = TAU*TIME/20.0;
        cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);
        cam.xz   *= ROT(sin(rt)*1.0-0.75);
        vec3 la   = vec3(0.0);
        vec3 dcam = normalize(la - cam);
        vec3 ddcam= vec3(0.0);

        vec3 ro = cam;
        vec3 ww = normalize(dcam);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));
        vec3 vv = (cross(ww,uu));
        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );

        vec3 col = vec3(0.0);
        col = scrollText(col, p);
        col = render(col, ro, rd);
        col -= (0.025*dot(pp,pp)+0.025);
        float fi = smoothstep(BTIME(24.25), BTIME(24.0), TIME);
        col = clamp(col, 0.0, 1.0);
        if (TIME > BTIME(27.0+5.0/8.0)) {
          col *= slowbeatf*slowbeatf;
        }

        col += fi;
        col = sqrt(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect3d(p, pp);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_008_crazy" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      #define NORM_OFF    0.001

      const int   max_iter      = 90;

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotX(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          1.0 , 0.0 , 0.0
        , 0.0 , +c  , +s
        , 0.0 , -s  , +c
        );
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotY(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          +c  , 0.0 , +s
        , 0.0 , 1.0 , 0.0
        , -s  , 0.0 , +c
        );
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotZ(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          +c  , +s  , 0.0
        , -s  , +c  , 0.0
        , 0.0 , 0.0 , 1.0
        );
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      float sphere4(vec3 p, float r) {
        p *= p;
        return pow(dot(p, p), 0.25)-r;
      }

      float box(vec4 p, vec4 b) {
        vec4 q = abs(p) - b;
        return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);
      }

      const float fixed_radius2 = 1.8;
      float min_radius2   = 0.5;
      const vec4  folding_limit = vec4(1.0);
      const float scale         = -2.9-0.;

      mat3 g_rot;
      float g_off;
      float g_col;


      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);

        return mix(b, a, h) - k*h*(1.0-h);
      }

      vec4 pmin(vec4 a, vec4 b, vec4 k) {
        vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      void sphere_fold(inout vec4 z, inout float dz) {
        float r2 = dot(z, z);

        float t1 = (fixed_radius2 / min_radius2);
        float t2 = (fixed_radius2 / r2);

        if (r2 < min_radius2) {
          z  *= t1;
          dz *= t1;
        } else if (r2 < fixed_radius2) {
          z  *= t2;
          dz *= t2;
        }
      }

      void box_fold(float k, inout vec4 z, inout float dz) {
        // Soft clamp after suggestion from ollij
        vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));
        z = zz * 2.0 - z;
      }

      float mb(vec4 z, out float ss) {
        float k = 0.1;
        vec4 offset = z;
        float dr = 1.0;
        for(int n = 0; n < 5; ++n) {
          box_fold(k/dr, z, dr);
          sphere_fold(z, dr);
          z = scale * z + offset;
          dr = dr * abs(scale) + 1.0;
        }

        float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);
        ss = dr;
        return d0;
      //  return pmin(d0, d, 0.05);
      }

      float df(vec3 p, out float ss) {
        const float z = 0.1;
        p /= z;
        vec4 p4 = vec4(p, g_off);
        p4.yzw *= g_rot;

        float d0 = mb(p4, ss);
        float d = d0;
        return d*z;
      }

      vec3 glow(vec3 ro, vec3 rd, out float tt) {
        float res;
        float t = 0.+0.2;
        int iter = max_iter;

        vec3 col = vec3(0.0);
        for(int i = 0; i < max_iter; ++i) {
          vec3 p = ro + rd * t;
          float ss;
          res = df(p, ss);
          float lss = log(ss);
          float lum = 0.4*exp(-0.5*t-5.0*res*float(i*i));
          vec3 gcol = ((0.5+0.5*cos(g_col -0.5*vec3(0.0, 1.0, 2.0)+2.0*(lss))))*lum;
          col += gcol;
          if(res < 0.0003 * t || res > 20.) {
            iter = i;
            break;
          }
          t += res;
        }

        tt = t;

        return col;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        float ss;
        nor.x = df(pos+eps.xyy, ss) - df(pos-eps.xyy, ss);
        nor.y = df(pos+eps.yxy, ss) - df(pos-eps.yxy, ss);
        nor.z = df(pos+eps.yyx, ss) - df(pos-eps.yyx, ss);
        return normalize(nor);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      float raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
        float ndbuffer = dbuffer/sph.w;
        vec3  rc = (ro - sph.xyz)/sph.w;

        float b = dot(rd,rc);
        float c = dot(rc,rc) - 1.0;
        float h = b*b - c;
        if( h<0.0 ) return 0.0;
        h = sqrt( h );
        float t1 = -b - h;
        float t2 = -b + h;

        if( t2<0.0 || t1>ndbuffer ) return 0.0;
        t1 = max( t1, 0.0 );
        t2 = min( t2, ndbuffer );

        float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
        float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
        return (i2-i1)*(3.0/4.0);
      }


      vec3 render(vec2 p, vec2 pp) {
        const float slowbeat0 = BTIME(31.0);
        const float slowbeat1 = BTIME(31.5);
        const float slowbeatp = bperiod/8.0;
        float slowbeatf = (1.0-mod((TIME-bstart), slowbeatp)/slowbeatp);
        float slowbeat = 1.0;
        if (TIME > slowbeat0 && TIME <= slowbeat1) {
          slowbeat = slowbeatf*slowbeatf;
        }

        const float superbeat0 = BTIME(31.5);
        const float superbeat1 = BTIME(31.5+0.125);
        const float superbeat2 = BTIME(31.75);
        const float superbeat3 = BTIME(31.75+0.125);
        const float superbeatp = bperiod/32.0;
        float superbeatf = 1.0-mod((TIME-bstart), superbeatp)/superbeatp;
        float superbeat = 0.0;
        if (TIME > superbeat0 && TIME <= superbeat1 || TIME > superbeat2 && TIME <= superbeat3) {
          superbeat = superbeatf;
        }

        float tm = TIME*0.5;
        vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));
        mat2 rot= ROT(TIME/3.0+0.125*superbeat);
        vec3 ro = 0.4*vec3(-1.0, 0.5, -0.0);
        lightDir.xz *= rot;
        ro.xz  *= rot;
        vec3 la = vec3(0.0, 0.0, 0.0);
        vec3 ww = normalize(la-ro);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));
        vec3 vv = (cross(ww,uu));
        const float fov = 3.0;
        vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );

        g_col = mix(3.5, 5.5, superbeat);
        float bt = beat(TIME+0.125*rd.z);
        float b = beat(TIME);

        min_radius2 = mix(0.5, 1., bt);
        g_off = sin(tm*0.53)+0.25*bt;

        g_rot = rotX(0.1*tm)*rotY(0.23*tm)*rotZ(0.31*tm);

        float tt = 0.0;
        vec3 col = vec3(0.0);
        vec3 gcol = glow(ro, rd, tt);

        float sd = raySphereDensity(ro, rd, vec4(vec3(0.0), mix(0.3, 0.5, b)), tt);
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.7, 1.));
        const vec3 gcol1 = HSV2RGB(vec3(0.55, 0.35, 2.0));
        vec3 ccol = mix(gcol0, gcol1, b);

        vec3 pos = ro+rd*tt;
        vec3 nor = normal(pos);
        vec3 ref = reflect(rd, nor);

        float ttt = tanh_approx(0.3*tt);
        float diff  = max(dot(lightDir, nor), 0.0);
        float spe   = pow(max(dot(lightDir, ref), 0.0), 40.0);
        float fre   = dot(rd, nor) + 1.0;
        fre *= fre;

        float fog = exp(-0.75*tt);
        float sfog = exp(-2.0*0.5*tt);
        const vec3 dcol = HSV2RGB(vec3(0.9, 0.5, 0.9));
        const vec3 scol = HSV2RGB(vec3(0.15, 0.5, 4.0));
        col += gcol;
        col += spe*sfog*scol;
        col += sd*sd*ccol;
        col -= 0.025*vec3(0.0, 1.0, 2.0).zyx*(1.0+length(pp));
        col = aces_approx(col);
        float fi = smoothstep(BTIME(28.25), BTIME(28.0), TIME);
        col += superbeat;
        col *= slowbeat;
        col += fi;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q  = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        vec2 pp = p;
        p.x*=RESOLUTION.x/RESOLUTION.y;

        vec3 col = render(p, pp);

        frag_color=vec4(col,1.0);
      }
    </script>

    <script id="vs_009_the_tree" type="x-shader/x-vertex">
      precision highp float;

      uniform float time;
      uniform mat4 mvp;

      in vec4 a_position;
      in vec3 a_normal;
      in vec2 a_texcoord;

      out vec2  v_texcoord    ;
      flat out float v_lf     ;
      flat out float v_ratio  ;
      flat out int   v_level  ;

      #define TIME        time

      #define PI          3.141592654
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      void tree3D(int i, out int level, out float lw, out vec3 p0, out vec3 p1) {
        vec3 p  = vec3(0.0, 2.0,0.0);
        float a = 0.085*sin(TIME*0.5);
        vec3 d  = vec3(0.0, -0.9, 0.0);
        const float fa = PI/8.0;

        float fs = 0.85;
        mat2 lr = fs*ROT(fa+a);
        mat2 rr = 0.90*fs*ROT(-fa+a);
        mat2 fr = fs*ROT(fa);
        mat2 nr = 0.9*fs*ROT(-fa);
        int ii  = i - 1;
        float l = 0.2;
        int lvl = 0;
        int c = int(ceil(log(3.0*(float(i+1)))/log(4.0)-1.0));
        for(int j = 0; j < c; ++j) {
          ++lvl;
          p += d;
          int di = ii & 3;
          switch(di) {
          case 0:
            d.xy *= lr;
            break;
          case 1:
            d.xy *= rr;
            break;
          case 2:
            d.zy *= fr;
            break;
          case 3:
            d.zy *= nr;
            break;
          }
          ii = ii >> 2;
          l *= (fs);
        }

        level = lvl;
        lw = l;
        p0 = p;
        p1 = p + d;
      }

      void main() {
        int  level= 0;
        float lw  = 0.0;
        vec3 p0   = vec3(0.0, 0.0, 0.0);
        vec3 p1   = vec3(0.0, 0.0, 0.0);

        tree3D(gl_InstanceID, level, lw, p0, p1);
        const float period = 20.0;
        float h0  = hash(float(gl_InstanceID)+123.4);
        float h1  = fract(h0*1667.0);
        float st  = h0*period;
        float te  = mod(0.5*TIME-st, period);
        float ef  = smoothstep(0.0, 10.0, te);
        float doff = 0.25*sin(h1*20.0*ef)*ef;
        vec3 woff = vec3(5.0*ef+doff, 10.0*ef*ef, doff)*step(te, 5.0);
        if (level > 6) {
          p0 += woff;
          p1 += woff;
        }
        const mat2 r = ROT(3.5);
        vec3 off = vec3(0.0, 0.0, 2.0);
        p0.xz *= r;
        p1.xz *= r;
        p0 += off;
        p1 += off;
        vec3 c  = (p0+p1)*0.5;
        vec3 d  = p1-p0;
        float l = length(d);

        vec3 up = vec3(0.0, 0.0, -1.0);
        vec3 ww = d/l;
      //  vec3 uu = normalize(cross(ww, up));
        // Bug, should be like above
        vec3 uu = (cross(ww, up));
        vec3 vv = cross(uu, ww);

        vec4 p = a_position;
        mat3 m = mat3(ww, uu, vv);
        float lf = step(float(level), 6.0);
        float gl = min(l*lf+lw,l);
        vec2 rr= vec2(gl, lw);
        p.xy  *= 0.5*rr;
        p.xyz *= transpose(m);
        p.xyz -= c;

        gl_Position = mvp * p;

        v_texcoord  = a_texcoord;
        v_lf        = lf;
        v_ratio     = rr.x/rr.y;
        v_level     = level;
      }
    </script>

    <script id="fs_009_the_tree" type="x-shader/x-fragment">
      precision highp float;

      in vec2  v_texcoord    ;
      flat in float v_lf     ;
      flat in float v_ratio  ;
      flat in int   v_level  ;

      out vec4 frag_color;

      #define PI      3.141592654
      #define TAU     (2.0*PI)

      float segmentx(vec2 p, float w) {
        p = abs(p);
        float d0 = p.y;
        float d1 = length(p-vec2(w, 0.0));
        return p.x > w ? d1 : d0;
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      void main() {
        vec4 fc = gl_FragCoord;
        float originalZ = fc.z / gl_FragCoord.w;
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;

        float r     = v_ratio;
        int   level = v_level;
        float lf    = v_lf;
        p.x *= r;

        vec3 col = vec3(0.0);
        float l = length(p);
        float h = 0.44+float(level)/10.0;;
        float s = 1.0;
      #define HSVCOLOR
      #if defined(HSVCOLOR)
        vec3 gcol0 = hsv2rgb(vec3(h, 0.55, s));
        vec3 gcol1 = hsv2rgb(vec3(h, 0.95, s));
      #else
        float tt = 3.5;
        vec3 gcol0 = s*(1.0+cos(tt+0.25*vec3(0.0, 1.0, 2.0).zyx+TAU*h));
        vec3 gcol1 = s*(1.0+cos(tt+0.5*vec3(0.0, 1.0, 2.0).zyx+TAU*h));
      #endif
        float ds = segmentx(p, lf*r);
        float g = exp(-3.0*ds);
        col += 1.0*gcol0*g*g*g;
        col += 0.5*gcol1*g*g;
        col /= mix(1.0, float(level*level)+1.0, lf);
        col *= 9.0*exp(-0.5*originalZ);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_009_the_tree_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D texts             ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      vec3 overlay(vec3 col, vec2 p, float n) {
        p.y += 2.0/3.0;
        float bd = abs(p.y)-0.14;

        float od = abs(bd-0.03)-0.01;
        float d = min(bd, od);
        float aa = 4.0/RESOLUTION.y;

        vec3 ocol = vec3(0.0);

        col = mix(col, ocol, smoothstep(0.0, -aa, d));
        vec2 tp = p;
        tp *= 1.0;
        tp.x /= 1440./448.0;
        tp.x += 0.5;
        tp.y += 0.115;
        tp.y = 1.0-tp.y;
        float t = step(0.75, tp.y)*step(tp.y, 1.0);
        tp.y += 0.0-n*0.25;
        vec4 tcol = texture(texts, tp*t);
        col = mix(col, tcol.xyz, tcol.w);

        return col;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame;
      uniform sampler2D prev_pass;

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec2 pp = p;
        pp *= 0.9+0.05;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec2 pq = 0.5+0.5*pp;

        const int c = 3;

        vec2 aa = 6.0/RESOLUTION.xy;
        vec2 start = pq-float(c)*aa;
        vec3 bcol = vec3(0.0);
        for (int y = -c; y <= c; ++y) {
          vec2 pp = start;
          for (int x = -c; x <= c; ++x) {
            vec4 fcol = texture(prev_frame, pp);
            bcol += fcol.xyz;
            pp.x += aa.x;
          }
          start.y += aa.y;
        }

        bcol /= float((2*c+1)*(2*c+1));

        vec4 pcol = texture(prev_pass,q);
        vec3 col = pcol.xyz;
      //  col -= 0.075*length(p);
        float aaa = 4.0/RESOLUTION.y;
        col = clamp(col, 0.0, 1.0);
        col = sqrt(col);
        col = mix(col, bcol, 0.6)*1.25;
        float fi = smoothstep(BTIME(33.0), BTIME(32.0), TIME+length(p));
        float ofi = smoothstep(BTIME(33.5), BTIME(33.0), TIME);
        vec2 op = p+vec2(0.0, 0.5*ofi);
        col = overlay(col, op, 0.0);
        col += 0.5*fi*vec3(1.0, 0.75, 0.875);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
        "texts"
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
//          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        sommarhack2023__font : {
          image : (gl) => override_nearest(document.getElementById("sommarhack2023__font")),
        },
        sommarhack2023__texts : {
          image : (gl) => document.getElementById("sommarhack2023__texts"),
        },
        sommarhack2023__the_crew : {
          image : (gl) => document.getElementById("sommarhack2023__the_crew"),
        },
      }

      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red"    ,
            },
          ],
        },
        star_travelling_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_000_star_travelling"  ,
            },
          ],
        },
        hexler_march_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_002_hexler_march"     ,
            },
            {
              vs: "vs_default"              ,
              fs: "fs_002_hexler_march_post",
            },
          ],
        },
        hyper_space_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_003_hyper_space"      ,
            },
          ],
        },
        cables_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_004_cables"           ,
            },
          ],
        },
        the_crew_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_005_the_crew"         ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__the_crew.texture);
                gl.uniform1i(pass.uniformLocations.the_crew, 4);
              },
            },
          ],
          uniforms: ["the_crew"],
        },
        moire_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_006_moire"            ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__font.texture);
                gl.uniform1i(pass.uniformLocations.font, 4);
              },
            },
          ],
          uniforms: ["font"],
        },
        bounce_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_007_bounce"           ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__font.texture);
                gl.uniform1i(pass.uniformLocations.font, 4);
              },
            },
          ],
          uniforms: ["font"],
        },
        crazy_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_008_crazy"            ,
            },
          ],
        },
        tree_scene : {
          passes:[
            {
              vs: "vs_009_the_tree"         ,
              fs: "fs_009_the_tree"         ,
              requires_clear: true          ,
              instances: 21845              ,
              pre_render: (gl, time, scene, pass) => {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.MAX);

                gl.uniformMatrix4fv(pass.uniformLocations.mvp, false, mvp_009);
              },
            },
            {
              vs: "vs_default"              ,
              fs: "fs_009_the_tree_post"    ,
              pre_render: (gl, time, scene, pass) => {
                gl.disable(gl.BLEND);
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__texts.texture);
                gl.uniform1i(pass.uniformLocations.texts, 4);
              },
            },
          ],
          uniforms: ["mvp"],
        },
      };

      const bpm   = 146.0;
      const bhz   = bpm/60.0;
      const start = 2.153;
      function btime(b) {
        return (8.0*b/bhz+start);
      }

      const max_time_slots  = 128;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.star_travelling_scene ,
        },
        {
          begin       :  4                                ,
          scene       :  all_scenes.hexler_march_scene    ,
        },
        {
          begin       :  8                                ,
          scene       :  all_scenes.hyper_space_scene     ,
        },
        {
          begin       :  12                               ,
          scene       :  all_scenes.cables_scene          ,
        },
        {
          begin       :  16                               ,
          scene       :  all_scenes.the_crew_scene        ,
        },
        {
          begin       :  20                               ,
          scene       :  all_scenes.moire_scene           ,
        },
        {
          begin       :  24                               ,
          scene       :  all_scenes.bounce_scene          ,
        },
        {
          begin       :  28                               ,
          scene       :  all_scenes.crazy_scene           ,
        },
        {
          begin       :  32                               ,
          scene       :  all_scenes.tree_scene            ,
        },
        {
          begin       :  36                               ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        if (time < start) {
          return all_scenes.red_scene;
        }
        const i = clamp(Math.floor((time-start)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function on_init_complete(width, height) {
        globalThis.projection_009 = projection_matrix4(Math.PI/3.0, width/height, 1, 1000);
        globalThis.view_009       = look_at_matrix4(vector3(0,0,3), vector3(0,0,0), vector3(0,1,0));
        globalThis.mvp_009        = multiply_matrix4(view_009, projection_009);

        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
        gl.activeTexture(gl.TEXTURE4);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__texts.texture);
        gl.uniform1i(pass.uniformLocations.texts, 4);
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.red_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="space_buddha__mental_hotline.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Impulse Sommarhack 2023</h1>

      <p id="info_label">Please wait... </p>

      Hello! We wanted to do a demo contribution for the <a target="_blank" href="https://sommarhack.se/2023/compo.php#regular5">Wild competion</a> for <a target="_blank" href="https://sommarhack.se/2023/">Sommarhack 2023</a>.

      Unfortunately, we lack musical talent and "borrowed" a great tune which disqualifies us from the competition. However, we wanted to shared this demo in the hope someone likes it.

      <h2>Contributors</h2>

      <p>Haiku by ChatGPT</p>

      <p>Code by Lance!</p>

      <p>Art by GlimGlam and Bing Create</p>

      <p>Font by an unknown <a target="_blank" href="http://christophekohler.epizy.com/AmigaBlogWp/1991/11/15/step40-bitmap-font/">Amiga</a> pixel god</p>

      <p>Music <a target="_blank" href="https://soundcloud.com/spacebuddha/space-buddha-mental-hotline-2006?si=25f0035ca00b4fa4836a3f90fd484451&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing">Mental Hotline</a> by <a target="_blank" href="https://soundcloud.com/spacebuddha">Space Buddha</a><br/>(Borrowed without asking, we lack musical talent but are in admiration of those that have)</p>

      <p>The scroll text with greetings is unreadable as called to by tradition. Listing you here instead</p>

      <h2>Twitch buddies</h2>
      <ul>
        <li>PROTON</li>
        <li>THE CAPTAIN CODER</li>
        <li>THE GRUMPY GAME DEV</li>
        <li>THINDAL</li>
      </ul>

      <h2>Shader gods</h2>
      <ul>
        <li>BIG WINGS</li>
        <li>BYT3 M3CHANIC</li>
        <li>DAVE HOSKINS</li>
        <li>EVILRYU</li>
        <li>EVVVIL</li>
        <li>IQ</li>
        <li>KALI</li>
        <li>NIMITZ</li>
        <li>SHANE</li>
        <li>TOTETMATT</li>
      </ul>

      <h2>ATARI people</h2>
      <ul>
        <li>DELTA FORCE</li>
        <li>LEONARD</li>
        <li>LOTEK STYLE</li>
        <li>NO CREW</li>
        <li>OMEGA</li>
        <li>OXYGENE</li>
        <li>THE CAREBEARS</li>
        <li>THE LOST BOYS</li>
        <li>THE OVERLANDERS</li>
        <li>THE UNION</li>
        <li>XIA</li>
        <li>YM ROCKERZ</li>
      </ul>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="sommarhack2023__the_crew" src="sommarhack2023__the_crew.jpg" style="display: none"/>
    <img id="sommarhack2023__texts" src="sommarhack2023__texts.png" style="display: none"/>
    <img id="sommarhack2023__font" src="sommarhack2023__font.png" style="display: none"/>
  </body>
</html>