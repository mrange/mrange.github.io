<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Sommarhack 2023</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_star_travelling" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         146.0

      const float planeDist = 1.0-0.825;

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash3(vec3 r)  {
        return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      vec2 soff(float h0) {
        float h1 = fract(h0*8677.0);
        return -1.0+2.0*vec2(h0, h1);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.1*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return (offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return (doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0001);
      }

      vec3 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {
        float l = distance(ro, pp);
        vec3 hn;
        vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;

        p *= 1.0+l*l;

        const float csz = 0.15;
        const float co  = 0.33*csz;

        vec3 col = vec3(0.0);

        const float cnt = 5.0;
        const float icnt = 1.0/cnt;
        for (float i = 0.0; i < 1.0; i += icnt) {
          vec2 cp = p;
          vec2 cn = mod2(cp, vec2(csz));

          float h0 = hash3(vec3(cn, n)+123.4+i);
          float h1 = fract(3677.0*h0);

          cp += soff(h0)*co;

          float cl = length(cp);
          float d = (cl-0.0005);
          d = max(d, 0.0001);

          vec3 bcol = 0.000005*(1.0+sin(vec3(0.0, 1.0, 2.0)+ TAU*h1));
          bcol *= smoothstep(0.17*csz, 0.05*csz, cl)*0.15/(d*d*(l*l+0.01));

          col += bcol;
          p += icnt;
          p *= ROT(1.0);
        }


        return col;
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 1.0/RESOLUTION.xy;
        float rdd = 3.0;

        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 9;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 col = skyColor(ro, rd);

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0) {
            vec3 pp = ro + rd*pd;
            vec3 npp = ro + nrd*pd;

            float aa = 3.0*length(pp - npp);

            vec3 off = offset(pp.z);

            vec3 pcol = plane(ro, rd, pp, off, aa, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
            pcol *= fadeOut*fadeIn;

            col += pcol;
          }
        }

        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float tm  = planeDist*TIME*BPM/60.0;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        float fi = smoothstep(BTIME(0.25), BTIME(0.0), TIME);
        vec3 col = color(ww, uu, vv, ro, p);
        col -= .1*vec3(0.0, 1.0, 2.0).zyx*length(pp);
        col *= smoothstep(1.5, 0.5, length(pp));
        col = aces_approx(col);
        col += fi;
        col = sqrt(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_002_hexler_march" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define BPM         146.0

      const float planeDist = 1.0-0.5;

      // License: Unknown, author: Unknown, found: don't remember
      vec4 alphaBlend(vec4 back, vec4 front) {
        float w = front.w + back.w*(1.0-front.w);
        vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;
        return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec3 alphaBlend(vec3 back, vec4 front) {
        return mix(back, front.xyz, front.w);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(in vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.3*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toPolar(vec2 p) {
        return vec2(length(p), atan(p.y, p.x));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toRect(vec2 p) {
        return vec2(p.x*cos(p.y), p.x*sin(p.y));
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec4 effect(vec2 p, float aa, float h) {
        vec2 hhn = hextile(p);
        const float w = 0.02;
        vec2 pp = toPolar(p);
        float a = pp.y;
        float hn = mod1(pp.y, TAU/6.0);
        vec2 hp = toRect(pp);
        float hd = hp.x-(w*10.0);

        float x = hp.x-0.5*w;
        float n = mod1(x, w);
        float d = abs(x)-(0.5*w-aa);

        float h0 = hash(10.0*hhn+2.0*h+n);
        float h1 = fract(8667.0*h0);
        float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));
        const float coln = 6.0;
        float t = smoothstep(aa, -aa, d)*smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*time+h1*TAU))*exp(-150.0*abs(x));
        vec3 col = (1.0+cos(1.5*vec3(0.0, 1.0, 2.0)+TAU*floor(h0*coln)/coln))*t;

        t = mix(0.9, 1.0, t);
        t *= smoothstep(aa, -aa, -hd);
        if (hd < 0.0) {
          col = vec3(0.0);
          t = 15.*dot(p, p);
        }
        return vec4(col, t);
      }

      vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {
        float h0 = hash(n);
        float h1 = fract(3677.0*h0);
        float h2 = fract(8677.0*h0);

        vec3 hn;
        vec2 p  = (pp-off*vec3(1.0, 1.0, 0.0)).xy;
        p *= ROT(TAU*h0);
        p.x -= 0.25*(pp.z-ro.z)*h2*h2;
        const float z = 0.5;
        p /= z;
        float aa = distance(pp,npp)*sqrt(1.0/3.0)/z;
        vec4 col = effect(p, aa, h1);

        return col;
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0025);

      //  return vec3(0.0);
      }


      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 2.0/RESOLUTION.y;
        float rdd = (2.5-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions
      //  float rdd = 2.0;

        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 4;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 skyCol = skyColor(ro, rd);


        vec4 acol = vec4(0.0);
        const float cutOff = 0.95;
        bool cutOut = false;

        float maxpd = 0.0;

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0 && acol.w < cutOff) {
            vec3 pp = ro + rd*pd;
            maxpd = pd;
            vec3 npp = ro + nrd*pd;

            vec3 off = offset(pp.z);

            vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
      //      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
            pcol.w *= fadeOut*fadeIn;
            pcol = clamp(pcol, 0.0, 1.0);

            acol = alphaBlend(pcol, acol);
          } else {
            cutOut = true;
            acol.w = acol.w > cutOff ? 1.0 : acol.w;
            break;
          }

        }

        vec3 col = alphaBlend(skyCol, acol);
      // To debug cutouts due to transparency
      //  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);
        return col;
      }

      vec3 effect(vec2 p, vec2 q) {
        float tm  = planeDist*0.5*TIME*BPM/60.0;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        vec3 col = color(ww, uu, vv, ro, p);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, q);

        frag_color = vec4(col, 1.0);
      }

    </script>

    <script id="fs_002_hexler_march_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      uniform sampler2D prev_frame;
      uniform sampler2D prev_pass;


      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define RESOLUTION  resolution

      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const mat2 brot = ROT(2.399);
      //  simplyfied version of Dave Hoskins blur
      vec3 dblur(vec2 q,float rad) {
        vec3 acc=vec3(0);
        const float m = 0.0025;
        vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);
        vec2 angle=vec2(0,rad);
        rad=1.;
        const int iter = 30;
        for (int j=0; j<iter; ++j) {
          rad += 1./rad;
          angle*=brot;
          vec4 col=texture(prev_frame,q+pixel*(rad-1.)*angle);
          col.xyz*=col.xyz;
          acc+=col.xyz;
        }
        return acc*(1.0/float(iter));
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec4 pcol = texture(prev_pass,q);
        vec3 bcol = dblur(q, .75);

        vec3 col = pcol.xyz;
        col += vec3(0.9, .8, 1.2)*mix(0.5, 0.8, length(p))*(vec3(0.05)+bcol);
        float fi = smoothstep(BTIME(4.25), BTIME(4.0), TIME);
        col += fi;
        col = sqrt(col);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_003_hyper_space" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PCOS(a)     0.5*(cos(a)+1.0)


      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
      vec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {
        vec3  oc = ro - cb;
        float card = dot(ca,rd);
        float caoc = dot(ca,oc);
        float a = 1.0 - card*card;
        float b = dot( oc, rd) - caoc*card;
        float c = dot( oc, oc) - caoc*caoc - cr*cr;
        float h = b*b - a*c;
        if( h<0.0 ) return vec2(-1.0); //no intersection
        h = sqrt(h);
        return vec2(-b-h,-b+h)/a;
      }

      // License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where
      float dfcos(float x) {
        return sqrt(x*x+1.0)*0.8-1.8;
      }

      // License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where
      float dfcos(vec2 p, float freq) {
        float x = p.x;
        float y = p.y;
        x *= freq;

        float x1 = abs(mod(x+PI,TAU)-PI);
        float x2 = abs(mod(x   ,TAU)-PI);

        float a = 0.18*freq;

        x1 /= max( y*a+1.0-a,1.0);
        x2 /= max(-y*a+1.0-a,1.0);
        return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        vec2 pp = rd.xy;
        return mix(gcol0, gcol1, b)/dot(pp, pp);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      float sphere4(vec2 p, float r) {
        p *= p;
        return pow(dot(p, p), 0.25)-r;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
      //  const float rdd = 2.0;
        float lp = length(p);
        const float rdd_per   = 10.0;
        float rdd =  (1.75+0.75*pow(lp,1.5)*tanh_approx(lp+0.9*PCOS(rdd_per*p.x)*PCOS(rdd_per*p.y)));

        const float mm = 4.0;
        const float rep = 27.0;

        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);

        vec3 skyCol = skyColor(ro, rd);

        vec2 etc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), 1.0);
        vec3 etcp = ro+rd*etc.y;

        rd.yx *= ROT(0.5*TIME);

        vec3 col = skyCol;

        // I read somewhere that if you call atan in a shader you got no business writing shader code.
        //  I even call it in a loop :)
        float a = atan(rd.y, rd.x);
        for(float i = 0.0; i < mm; ++i) {
          float ma = a;
          float sz = rep+i*6.0;
          float slices = TAU/sz;
          float na = mod1(ma, slices);

          float h1 = hash(na+13.0*i+123.4);
          float h2 = fract(h1*3677.0);
          float h3 = fract(h1*8677.0);

          float tr = mix(0.5, 3.0, h1);
          vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);
          vec3 tcp = ro + tc.y*rd;
          vec2 tcp2 = vec2(tcp.z, atan(tcp.y, tcp.x));

          float zz = mix(0.025, 0.05, sqrt(h1))*rep/sz;
          float tnpy = mod1(tcp2.y, slices);
          float fo = smoothstep(0.5*slices, 0.25*slices, abs(tcp2.y));
          tcp2.x += -h2*TIME;
          tcp2.y *= tr*PI/3.0;
          tcp2/=zz;

          float d0 = abs(dfcos(tcp2, 2.0*zz));
          float d = d0;
          d *= zz;

          vec3 bcol = (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*h3+0.5*h2*h2*tcp.z))*0.00005;
          bcol /= max(d*d, 0.000+5E-7*tc.y*tc.y);
          bcol *= exp(-0.02*tc.y*tc.y);
          bcol *= smoothstep(-0.5, 1.0, sin(mix(0.125, 1.0, h2)*tcp.z));
          bcol *= fo;

          col += bcol;
        }

        return col;
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 effect(vec2 p, vec2 pp) {
        float tm  = TAU*TIME;
        vec3 ro   = vec3(0.0, 0.0, tm);
        vec3 dro  = normalize(vec3(1.0, 0.0, 3.0));
        dro.xz *= ROT(0.2*sin(0.05*tm));
        dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));
        const vec3 up = vec3(0.0,1.0,0.0);
        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(up, ww));
        vec3 vv = (cross(ww, uu));
        vec3 col = color(ww, uu, vv, ro, p);
        col -= 0.125*vec3(0.0, 1.0, 2.0).yzx*length(pp);
        col = aces_approx(col);
        float fi = smoothstep(BTIME(8.25), BTIME(8.0), TIME);
        col += fi;
        col = sqrt(col);
        return col;
      }

      void main(void) {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, pp);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_004_cables" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define TOLERANCE       0.0001
      #define NORMTOL         0.00125
      #define MAX_RAY_LENGTH  20.0
      #define MAX_RAY_MARCHES 90
      #define TIME            time
      #define RESOLUTION      resolution
      #define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define MAX_ITER        3

      // https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      #define PATHA vec2(0.1147, 0.2093)
      #define PATHB vec2(13.0, 3.0)

      const float cam_amp =1.;

      mat2 g_rot = mat2(1.0);
      float g_quad = 0.0;
      int g_hit = 0;

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float roundedX(vec2 p, float w, float r) {
        p = abs(p);
        return length(p-min(p.x+p.y,w)*0.5) - r;
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/spherefunctions
      float sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
          float ndbuffer = dbuffer/sph.w;
          vec3  rc = (ro - sph.xyz)/sph.w;

          float b = dot(rd,rc);
          float c = dot(rc,rc) - 1.0;
          float h = b*b - c;
          if( h<0.0 ) return 0.0;
          h = sqrt( h );
          float t1 = -b - h;
          float t2 = -b + h;

          if( t2<0.0 || t1>ndbuffer ) return 0.0;
          t1 = max( t1, 0.0 );
          t2 = min( t2, ndbuffer );

          float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
          float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
          return (i2-i1)*(3.0/4.0);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 cam_path(float z) {
        return vec3(cam_amp*sin(z*PATHA)*PATHB, z);
      }

      vec3 dcam_path(float z) {
        return vec3(cam_amp*PATHA*PATHB*cos(PATHA*z), 1.0);
      }

      vec3 ddcam_path(float z) {
        return cam_amp*vec3(cam_amp*-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);
      }

      float cables(vec3 p3) {
        const float cylr = 0.2;
        vec2 p = p3.xy;
        float t = p3.z;

        const float ss = 1.5;
        mat2 pp = ss*ROT(1.0+0.5*p3.z);

        p *= g_rot;
        float s = 1.0;

        float d = 1E6;
        float quad = 1.0;
        int hit = 0;
        for (int i = 0; i < MAX_ITER; ++i) {
          p *= pp;
          p = abs(p);
          p -= 1.35*s;
          s *= 1.0/ss;
          const float sz = 1.0;

          float dd = roundedX(p, sz*1.5*cylr, sz*0.25*cylr)*s;
          vec2 s = sign(p);
          float q = s.x*s.y;

          if (dd < d) {
            d = dd;
            quad = q;
            hit = i;
          }

        }

        g_quad = quad;
        g_hit = hit;

        return d;
      }

      float df(vec3 p) {
        // Found this world warping technique somewhere but forgot which shader :(
        vec3 cam = cam_path(p.z);
        vec3 dcam = normalize(dcam_path(p.z));
        p.xy -= cam.xy;
        p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);
        float d = cables(p);

        return d;
      }

      float rayMarch(in vec3 ro, in vec3 rd, out int iter) {
        float t = 0.0;
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          t += d;
        }
        iter = i;
        return t;
      }

      vec3 normal(in vec3 pos) {
        vec3  eps = vec3(NORMTOL,0.0,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {
        const float minShadow = 0.25;
        float res = 1.0;
        float t = mint;
        for (int i=0; i<25; ++i) {
          float distance = df(pos + ld*t);
          res = min(res, k*distance/t);
          if (ll <= t) break;
          if(res <= minShadow) break;
          t += max(mint*0.2, distance);
        }
        return clamp(res,minShadow,1.0);
      }

      vec3 render(vec3 ro, vec3 rd, float tm) {
        vec3 lightPos0  = cam_path(tm-0.5);
        vec3 lightPos1  = cam_path(tm+6.5);

        vec3 skyCol = vec3(0.0);

        int iter = 0;
        float t = rayMarch(ro, rd, iter);
        float quad = g_quad;
        float hit  = float(g_hit);

        float tt = float(iter)/float(MAX_RAY_MARCHES);
        float bs = 1.0-tt*tt*tt*tt;

        vec3 pos = ro + t*rd;

        float lsd1  = sphered(ro, rd, vec4(lightPos1, 2.5), t);
        float beat  = beat(TIME);
        const float hoff = 0.;
        const vec3 bcol0 = HSV2RGB(vec3(hoff+0.6, 0.7, 3.0));
        const vec3 bcol1 = HSV2RGB(vec3(hoff+0.55, 0.5, 7.0));
        vec3 bcol   = mix(bcol0, bcol1, beat);
        vec3 gcol   = lsd1*bcol;

        if (t >= MAX_RAY_LENGTH) {
          return skyCol+gcol;
        }

        vec3 nor    = normal(pos);

        vec3 lv0    = lightPos0 - pos;
        float ll20  = dot(lv0, lv0);
        float ll0   = sqrt(ll20);
        vec3 ld0    = lv0 / ll0;
        float dm0   = 8.0/ll20;
        float sha0  = softShadow(pos, ld0, ll0, 0.125, 32.0);
        float dif0  = max(dot(nor,ld0),0.0)*dm0;

        vec3 lv1    = lightPos1 - pos;
        float ll21  = dot(lv1, lv1);
        float ll1   = sqrt(ll21);
        vec3 ld1    = lv1 / ll1;
        float spe1  = pow(max(dot(reflect(ld1, nor), rd), 0.), 100.)*tanh_approx(3.0/ll21);

        vec3 col = vec3(0.0);

        const vec3 black = vec3(0.0);
        const vec3 dcol0 = black;
        const vec3 dcol1 = HSV2RGB(vec3(0.08, 1.0, 1.0));
        col += dif0*sha0*mix(dcol0, dcol1, 0.5+0.5*quad);
        col += spe1*bcol*bs;
        col += gcol;

        return col;
      }

      vec3 effect3d(vec2 p, vec2 pp) {
        float tm = 2.0*TIME;
        g_rot = ROT(-0.2*tm);
        vec3 cam  = cam_path(tm);
        vec3 dcam = dcam_path(tm);
        vec3 ddcam= ddcam_path(tm);

        vec3 ro = cam;
        vec3 ww = normalize(dcam);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*-2.0, ww ));
        vec3 vv = normalize(cross(ww,uu));
        float rdd = (2.0+0.75*tanh_approx(dot(p, p)));
        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);

        vec3 col = render(ro, rd, tm);
        col -= 0.075*vec3(0.0, 1.0, 2.0);
        col = aces_approx(col);
        float fi = smoothstep(BTIME(12.25), BTIME(12.0), TIME);
        col += fi;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect3d(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_005_the_crew" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D the_crew          ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------


      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      const float hoff = 0.59;
      const vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));
      const vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));
      const vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));
      const vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));

      // License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);

      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pabs(float a, float k) {
        return -pmin(a, -a, k);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      float dot2(vec2 p) {
        return dot(p, p);
      }

      vec2 hash(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return -1. + 2.*fract (sin (p)*43758.5453123);
      }

      float noise(vec2 p) {
        const float K1 = .366025404;
        const float K2 = .211324865;

        vec2 i = floor (p + (p.x + p.y)*K1);

        vec2 a = p - i + (i.x + i.y)*K2;
        vec2 o = step (a.yx, a.xy);
        vec2 b = a - o + K2;
        vec2 c = a - 1. + 2.*K2;

        vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);

        vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));

        return dot (n, vec3 (70.));
      }

      float fbm(vec2 pos, float tm) {
        vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));
        float aggr = 0.0;

        aggr += noise(pos);
        aggr += noise(pos + offset) * 0.5;
        aggr += noise(pos + offset.yx) * 0.25;
        aggr += noise(pos - offset) * 0.125;
        aggr += noise(pos - offset.yx) * 0.0625;

        aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;

        float f = (aggr * 0.5) + 0.5;

        return f;
      }

      float divf(float offset, float f) {
        const float goff = 0.2;
        const float gfloor = 0.001;
        float r = abs(goff + offset - f);
        r = max(r, gfloor);
        return r;
      }

      vec3 lightning(vec2 pos, vec2 pp, float offset) {
        vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);

        float time = TIME+123.4;
        float stime = time/200.0;
        vec3 col = vec3(0.0);
        vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;
        const float glow = 0.0125;
        const float goff = 0.2;
        const float gfloor = 0.001;
        for (float i = 0.0; i < 3.0; ++i) {
          vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));
          vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));
          float btime = stime*85.0 + (i);
          float rtime = stime*75.0 + (i);
          float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));
          float div2 = divf(offset, fbm((pos + f) * 2.0, btime));
          float d1 = offset * glow / div1;
          float d2 = offset * glow / div2;
          col += (d1 * gcol0)-sub;
          col += (d2 * gcol1)-sub;
        }

        return col;
      }

      vec3 theCrew(vec3 col, float d, vec2 p) {
        if (d > 0.0) return col;
        vec2 sgn = sign(p);
        float q = (0.5*(sgn.x+1.0)+(-sgn.y+1.0))*0.125;
        const float off = 17.125;
        float fi0 = smoothstep(BTIME(off+q), BTIME(off + 0.125+ q), TIME);
        float fi1 = smoothstep(BTIME(off + .05+q), BTIME(off+q), TIME)*step(BTIME(off+q), TIME);
        p *= 0.5;
        p += 0.5;
        p.y = 1.0-p.y;
        vec4 tcol = texture(the_crew, p);

        col = mix(col, tcol.xyz, tcol.w*fi0)+fi1;
        return col;
      }

      vec3 effect(vec2 p, vec2 pp) {
        float aa = 4.0/RESOLUTION.y;
        float fi0 = smoothstep(BTIME(16.25), BTIME(16.0), TIME);
        float fi1 = smoothstep(BTIME(16.0), BTIME(17.0), TIME);
        vec2 ip = p;
        ip *= ROT(mix(1.55*TAU, -0.1, fi1));
        float z = mix(0.1, 1.0, fi1);
        ip /= z;
        float d = box(ip, vec2(1.0));
        d *= z;
        const vec3 lp = vec3(-4.0, -5.0, 3.0);
        const vec3 ro = vec3(0.0, 0.0, 10.0);
        float gd = d+0.0;
        vec2 gp = p;
        vec3 gcol = lightning(gp, pp, gd);
        vec3 col = vec3(0.0);
        col += gbcol/max(0.025*(d), 0.0001);
        col += gcol;
        col *= smoothstep(1.75, 0.5, length(pp));

        col = aces_approx(col);
        col += fi0;
        col = sqrt(col);
        col = theCrew(col, d, ip);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p, pp);
        frag_color = vec4(col.xyz, 1.0);
      }
    </script>

    <script id="fs_006_moire" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      float box(vec2 p, vec2 b) {
          vec2 d = abs(p)-b;
          return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float modRadial(inout vec2 p, float o, float m) {
        float l = length(p);
        float k = l;
        l -= o;
        float n = mod1(l, m);

        p = (l/k)*p;
        return n;
      }

      float df(vec2 p) {
        vec2 pr = p;
        const float m = 0.25;
        modRadial(pr, 0.0, m);
        float l = length(pr);
        return abs(l)-(m*0.25);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      vec3 beatCol(vec2 p) {
        const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));
        const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));
        float b = beat(TIME);
        return 2.0*mix(gcol0, gcol1, b)/max(dot(p, p), 0.00025);
      }

      vec3 effect(vec2 p, vec2 pp) {
        float aa = 4.0/RESOLUTION.y;
        float tm = TIME;
        p *= ROT(-.33*tm);
        vec2 p0 = p+sin(vec2(1.0, sqrt(0.5)).yx*(tm+100.0));
        vec2 p1 = p+sin(1.3*vec2(1.0, sqrt(0.5))*(tm+334.0));
        vec2 p2 = 0.5*(p0+p1);
        float sm = 0.0666*length(p);
        float d0 = df(p0);
        float d1 = df(p1);
        float d = d0;
        d = pmax(d, d1, sm);
        float dd = -d0;
        dd = pmax(dd, -d1, sm);
        d =  min(d, dd);
        const float so = 8.0;
        const float co = 0.5;
        vec3 bcol0 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p0)+1.0-TIME))/(so*dot(p0, p0)+0.0001);
        vec3 bcol1 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p1)+3.0+TIME))/(so*dot(p1, p1)+0.0001);
        vec3 bcol2 = beatCol(p2);

        vec3 bcol = (bcol0+bcol1);
        vec3 col = vec3(0.0);
        col += 0.005*bcol/(max(dd+0.005, 0.0)+0.0001);
        col = mix(col, bcol, smoothstep(0.0, -aa, d));
        col += bcol2;
        col -= 0.25*vec3(0.0, 1.0, 2.0).zyx*length(pp);
        col *= smoothstep(1.5, 0.5, length(pp));
        col = aces_approx(col);
        float fi = smoothstep(BTIME(20.25), BTIME(20.00), TIME);
        col += fi;
        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p, pp);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_007_bounce" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 2.153;
      const float bpm    = 146.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      // License CC0: Random friday fractal
      // Result after a bit of random coding on friday afternoon

      #define PI              3.141592654
      #define TAU             (2.0*PI)
      #define TIME            time
      #define RESOLUTION      resolution
      #define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PCOS(x)         (0.5+0.5*cos(x))

      #define TOLERANCE       0.00001
      #define MAX_RAY_LENGTH  10.0
      #define MAX_RAY_MARCHES 50
      #define NORM_OFF        0.0001

      #define TBEAT           (-(TIME-bstart)*bpm/60.0)
      #define TTBEAT          (TAU*TBEAT)

      const vec3  std_gamma  = vec3(2.2);
      const float smoothing  = 0.066;

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // From: https://stackoverflow.com/a/17897228/418488
      vec3 hsv2rgb(vec3 c) {
        const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
      }

      float boxf(vec3 p, vec3 b, float e) {
        p = abs(p  )-b;
        vec3 q = abs(p+e)-e;
        return min(min(
            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
      }

      float pmin(float a, float b, float k) {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      vec3 pmin(vec3 a, vec3 b, float k) {
        vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      vec3 pabs(vec3 a, float k) {
        return -pmin(a, -a, k);
      }

      vec3 refl(vec3 p, vec3 n) {
        p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;
        return p;
      }

      float sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
          float ndbuffer = dbuffer/sph.w;
          vec3  rc = (ro - sph.xyz)/sph.w;

          float b = dot(rd,rc);
          float c = dot(rc,rc) - 1.0;
          float h = b*b - c;
          if( h<0.0 ) return 0.0;
          h = sqrt( h );
          float t1 = -b - h;
          float t2 = -b + h;

          if( t2<0.0 || t1>ndbuffer ) return 0.0;
          t1 = max( t1, 0.0 );
          t2 = min( t2, ndbuffer );

          float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
          float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
          return (i2-i1)*(3.0/4.0);
      }

      float df(vec3 p) {
        vec3 op = p;
        const float zf = 2.5;
        const int mid  = 1;
        const int end  = 3;
        const vec3 n0  = normalize(vec3(-1.0,  1.0,  1.0));
        const vec3 n1  = normalize(vec3( 1.0, -1.0,  1.0));
        const vec3 n2  = normalize(vec3( 1.0,  1.0, -1.0));
        const vec3 off = normalize(vec3(1.0, 1.0, 1.0));

        float d = 1E6;
        float z = 1.0;
        vec3  cp = off;

        mat2 rxy = ROT(0.5*time*sqrt(0.5));
        mat2 ryz = ROT(0.5*time);

        for (int i = 0; i < mid; ++i) {
          p.xy *= rxy;
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*0.33;
          p *= zf;
          z *= zf;
        }

        float sb = smoothstep(-0.75, 0.75, cos(PI+TTBEAT+4.0*length(op)+4.0*op.x));
        float rr = mix(0.24, 0.33, sb);
        for (int i = mid; i < end; ++i) {
          p.xy *= ROT(1.0);
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*rr;
          p *= zf;
          z *= zf;

          vec3 pp = p;
          float dd0 = boxf(pp, 0.1*vec3(1.0), 0.0125)-0.0125;
          float dd1 = length(pp)- 0.075;
          float dd = dd0;
          dd = min(dd, dd1);
          dd /= z;
          d = min(d, dd);
        }

        return d;
      }

      float rayMarch(vec3 ro, vec3 rd, out int iter) {
        float t = 0.0;
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          t += d;
        }
        iter = i;
        return t;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {
        const float minShadow = 0.25;
        float res = 1.0;
        float t = mint;
        for (int i=0; i<24; i++) {
          float d = df(pos + ld*t);
          res = min(res, k*d/t);
          if (ll <= t) break;
          if(res <= minShadow) break;
          t += max(mint*0.2, d);
        }
        return clamp(res,minShadow,1.0);
      }

      vec3 render(vec3 ro, vec3 rd) {
        vec3 lightPos = vec3(1.0);
        float alpha   = 0.05*TIME;

        const vec3 skyCol = vec3(0.0);

        int iter    = 0;
        float t     = rayMarch(ro, rd, iter);

        float sb    = smoothstep(-0.5, 0.5, cos(TTBEAT));
        float sr    = mix(0.4, 0.45, sb);
        vec3 gf     = mix(1.5*vec3(2., 1.0, 0.75), 3.5*vec3(1.75, 1.5, 1.5), sb);
        float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);

        vec3 gcol   = sd*gf;

        if (t >= MAX_RAY_LENGTH) {
          return gcol;
        }

        vec3 pos    = ro + t*rd;
        vec3 nor    = normal(pos);
        vec3 refl   = reflect(rd, nor);
        float ii    = float(iter)/float(MAX_RAY_MARCHES);
        float ifade = 1.0-tanh_approx(1.25*ii);
        float h     = fract(-1.0*length(pos)+0.1);
        float s     = 0.25;
        float v     = tanh_approx(0.4/(1.0+40.0*sd));
        vec3 color  = hsv2rgb(vec3(h, s, v));

        vec3 lv   = lightPos - pos;
        float ll2 = dot(lv, lv);
        float ll  = sqrt(ll2);
        vec3 ld   = lv / ll;
        float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);

        float dm  = 4.0/ll2;
        float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;
        float spe = pow(max(dot(refl, ld), 0.), 20.);
        float ao  = smoothstep(0.5, 0.1 , ii);
        float l   = mix(0.2, 1.0, dif*sha*ao);

        vec3 col = l*color + 2.0*spe*sha;
      //  return vec3(ao);
        return gcol+col*ifade;
      }

      vec3 effect3d(vec2 p, vec2 pp) {
        float z   = TIME;
        vec3 cam  = 1.2*vec3(1.0, 0.5, 0.0);
        float rt  = TAU*TIME/20.0;;
        cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);
        cam.xz   *= ROT(sin(rt)*1.0-0.75);
        vec3 la   = vec3(0.0);
        vec3 dcam = normalize(la - cam);
        vec3 ddcam= vec3(0.0);

        vec3 ro = cam;
        vec3 ww = normalize(dcam);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));
        vec3 vv = (cross(ww,uu));
        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );

        vec3 col = render(ro, rd);
        col -= (0.025*dot(pp,pp)+0.025);
        float fi = smoothstep(BTIME(24.25), BTIME(24.0), TIME);
        col = clamp(col, 0.0, 1.0);
        col += fi;
        col = sqrt(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect3d(p, pp);
        frag_color = vec4(col, 1.0);
      }


    </script>

    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        sommarhack2023__the_crew : {
          image : (gl) => document.getElementById("sommarhack2023__the_crew"),
        },
      }

      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red"    ,
            },
          ],
        },
        star_travelling_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_000_star_travelling"  ,
            },
          ],
        },
        hexler_march_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_002_hexler_march"     ,
            },
            {
              vs: "vs_default"              ,
              fs: "fs_002_hexler_march_post",
            },
          ],
        },
        hyper_space_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_003_hyper_space"      ,
            },
          ],
        },
        cables_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_004_cables"           ,
            },
          ],
        },
        the_crew_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_005_the_crew"         ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                console.log(pass.uniformLocations);
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.sommarhack2023__the_crew.texture);
                gl.uniform1i(pass.uniformLocations.the_crew, 4);
              },
            },
          ],
          uniforms: ["the_crew"],
        },
        moire_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_006_moire"            ,
            },
          ],
        },
        bounce_scene : {
          passes:[
            {
              vs: "vs_default"              ,
              fs: "fs_007_bounce"           ,
            },
          ],
        },
      };

      const bpm   = 146.0;
      const bhz   = bpm/60.0;
      const start = 2.153;
      function btime(b) {
        return (8.0*b/bhz+start);
      }

      const max_time_slots  = 128;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.star_travelling_scene ,
        },
        {
          begin       :  4                                ,
          scene       :  all_scenes.hexler_march_scene    ,
        },
        {
          begin       :  8                                ,
          scene       :  all_scenes.hyper_space_scene     ,
        },
        {
          begin       :  12                               ,
          scene       :  all_scenes.cables_scene          ,
        },
        {
          begin       :  16                               ,
          scene       :  all_scenes.the_crew_scene        ,
        },
        {
          begin       :  20                               ,
          scene       :  all_scenes.moire_scene           ,
        },
        {
          begin       :  24                               ,
          scene       :  all_scenes.bounce_scene             ,
        },
        {
          begin       :  28                               ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        if (time < start) {
          return all_scenes.red_scene;
        }
        const i = clamp(Math.floor((time-start)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function on_init_complete(width, height) {
        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.red_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="space_buddha__mental_hotline.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Sommarhack 2023</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="sommarhack2023__the_crew" src="sommarhack2023__the_crew.jpg" style="display: none"/>
  </body>
</html>