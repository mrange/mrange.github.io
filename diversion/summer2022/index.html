<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Summer 2022</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec4 v_position;
      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red_pass" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_start" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      #define TIME        time
      #define RESOLUTION  resolution
      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      #define TIME        time
      #define RESOLUTION  resolution

      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PI          3.141592654
      #define TAU         (2.0*PI)

      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;

      #define BTIME(n) ((n)*8.0/bhz+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }

      const float effect_start  = BTIME(9.0);
      const float effect_end    = BTIME(9.0+2.0*4.0);

      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 shash2(vec2 p) {
        return -1.0+2.0*hash2(p);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      vec3 rgb2hsv(vec3 c) {
        const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      float dot2(vec2 p) {
        return dot(p, p);
      }

      float heart(vec2 p) {
        p.x = abs(p.x);

        if( p.y+p.x>1.0 )
          return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;
        return sqrt(min(dot2(p-vec2(0.00,1.00)),
                        dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      // License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA
      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec3 fade(vec2 p) {
        const float z = 10.0;
        p *= z;
      #define FADE0
      #if defined(FADE0)
        const float overlap = 0.0;
        const float hoff = 0.0;
        float f0 = tanh_approx(max(p.y+overlap, 0.0)+0.1)*step(overlap, p.y);
        float f1 = tanh_approx(max(-p.y+overlap, 0.0));
        vec3 lcol0 = hsv2rgb(vec3(hoff+0.58, 0.8, 2.0*(f0)));
        vec3 lcol1 = hsv2rgb(vec3(hoff+0.05 , 0.9 , 2.0*(f1)));
        vec3 lcol2 = hsv2rgb(vec3(hoff+0.025, 0.9, mix(0.01, 0.1, beat(TIME))))/(abs(p.y)*(abs(p.x*p.x)+0.2));
        vec3 col = vec3(0.0);
        col += lcol0;
        col += lcol1;
        col += lcol2;
        return col;
      #else
        return vec3(1.0);
      #endif


      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 effect0(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        vec2 lp = p;
        float bcount = beatCount(TIME);
        int i = int(mod(floor(bcount)+2.0, 3.0));
        switch(i) {
        case 0:
          lp *= 0.26;
          lp.x -= 0.0125;
          break;
        case 1:
          lp *= 0.17;
          lp.x -= 0.033;
          break;
        case 2:
          lp *= 0.23;
          lp.x -= 0.025;
          break;
        default:
          break;
        }
        vec4 lcol = impulseText(lp, i);
        float h = max(max(lcol.x, lcol.y), lcol.z);

        vec2 hp = p;
        hp.x *= mix(1.0, 0.9, beat(TIME+0.1*hp.y-0.15));
        hp.y -= -0.5;
        float d = heart(hp);
      //  d = abs(d) - 0.02;

        vec3 col = vec3(0.1);
        vec3 fcol = fade(p);
        col += HSV2RGB(vec3(0.9, 0.8, 0.3))*exp(-4.0*max(d-0.05, 0.0));
        col = mix(col, HSV2RGB(vec3(0.5, 0.0, 1.0)), smoothstep(aa, -aa, d-0.05));
        col = mix(col, HSV2RGB(vec3(0.9, 0.66, 1.0)), smoothstep(aa, -aa, d-0.025));
        col *= 1.0-tanh_approx(length(p));
        lcol.xyz = mix(lcol.xyz, fcol, sqrt(h));
        col = mix(col, 1.0*lcol.xyz, lcol.w);
        col += hsv2rgb(vec3(0.025, 0.5, 0.15))*beat(TIME)/dot2(p);
        col += 2.0*smoothstep(7.0, 7.5, bcount);
        return col;
      }


      float df(vec2 p) {
        const float hz = .25;
        p /= hz;
        vec2 hp0 = p;
        vec2 hn0 = hextile(hp0);
        vec2 hsn0= shash2(hn0);
        hp0 += 0.25*hsn0;
        float d0 = length(hp0) - mix(0.01, 0.2, abs(hsn0.y));

        vec2 hp1 = p;
        hp1 += vec2(1.0, sqrt(1.0/3.0));
        vec2 hn1 = hextile(hp1);
        vec2 hsn1= shash2(hn1);
        hp1 += 0.25*hsn1;
        float d1 = length(hp1) - mix(0.01, 0.2, abs(hsn1.y));

        float d = d0;
        d = min(d, d1);

        return -d*hz;
      }

      vec3 effect1(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        float bcount = beatCount(TIME);

        vec3 hsv = vec3(0.0);

        float fi0 = smoothstep(0.0, 1.0, bcount);
        float fi1 = smoothstep(1.0, 2.0, bcount);
        float fi2 = smoothstep(2.0, 3.0, bcount);
        float fo3 = smoothstep(4.0, 3.5, bcount);

        p *= ROT(mix(3.0*PI/12.0, PI/6.0, fi0));
        vec2 lp = p;
        const float lw = 0.75;
        float ln = mod1(lp.y, lw);

        float fp1 = 0.5*lp.x+lp.y;
        fp1 = fract(fp1/0.1);

        int i = 0;
        if (ln == 1.0) {
          i = 1;
          lp *= 0.2;
          lp.x += mix(-0.75, 0.0, fi1);
          hsv = vec3(0.0, 0.0, fi1*fi1);
        } else if (ln == 0.0) {
          i = 9;
          lp *= mix(0.1, 0.25, fi0);
          hsv = vec3(0.15, .0, 0.0);
        } else if (ln == -1.0) {
          i = 12;
          lp *= 0.29;
          lp.x += mix(0.75, 0.0, fi2);
          hsv = vec3(0.6, fi2, fi2*fi2);
        } else {
          return vec3(0.0);
        }

        vec3 flash = hsv2rgb(vec3(0.6, 0.75, 2.0))*smoothstep(0.5, 0.0, fract(bcount))/dot(p, p);

        vec3 col = vec3(0.);
        float d = df(p);
        col = hsv2rgb(hsv)*smoothstep(aa, -aa, d);

        vec4 lcol = impulseLogoCenter(lp, i);

        col = mix(col, lcol.xyz, lcol.w);
        col *= fi0;
        if (ln == 1.0 && floor(bcount) == 1.0) {
          col += flash;
        } else if (ln == 0.0 && floor(bcount) == 0.0) {
          col += flash;
        } else if (ln == -1.0 && floor(bcount) == 2.0) {
          col += flash;
        } else {
        }

        col *= fo3;

        return col;
      }


      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = vec3(0.0);
        float bcount = beatCount(TIME);
      //    col = effect0(p);
        if (bcount < 0.0) {
          col = vec3(0.0);
        } else if (bcount < 4.0 && bcount >= 0.0) {
          col = effect1(p);
        } else if (bcount < 7.0 && bcount >= 4.0) {
          col = effect0(p);
        } else {
          col = vec3(1.0);
        }
        col = aces_approx(col);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

<script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
        "impulseAsset_logos",
        "impulseAsset_texts",
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        impulse_asset__logos : {
          image : (gl) => document.getElementById("impulse_asset__logos"),
        },
        impulse_asset__texts : {
          image : (gl) => document.getElementById("impulse_asset__texts"),
        },
      }

      // List all scenes, all scenes have a vertex shader (often shared)
      //  and a fragment shader
      //  It's possible to reuse and tweak fragment shaders by using defines
      //  Can also register extra uniforms
      //  Default uniforms always includes time and resolution
      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red_pass",
            }
          ]
        },
        start_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_000_start",
            }
          ]
        },
      };

      // Called after initialization of all shaders are complete
      function on_init_complete() {
        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
        gl.activeTexture(gl.TEXTURE4);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__logos.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_logos, 4);

        gl.activeTexture(gl.TEXTURE5);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__texts.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_texts, 5);
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const scene = all_scenes.start_scene;
        return all_scenes.start_scene;
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="ultrasyd__new_things.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Summer 2022</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="impulse_asset__logos" src="impulse_asset__logos.png" style="display: none"/>
    <img id="impulse_asset__texts" src="impulse_asset__texts.png" style="display: none"/>
  </body>
</html>