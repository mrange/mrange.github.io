<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Summer 2022</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec4 v_position;
      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_start" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 shash2(vec2 p) {
        return -1.0+2.0*hash2(p);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      vec3 rgb2hsv(vec3 c) {
        const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      float dot2(vec2 p) {
        return dot(p, p);
      }

      float heart(vec2 p) {
        p.x = abs(p.x);

        if( p.y+p.x>1.0 )
          return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;
        return sqrt(min(dot2(p-vec2(0.00,1.00)),
                        dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      // License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA
      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec3 fade(vec2 p) {
        const float z = 10.0;
        p *= z;
      #define FADE0
      #if defined(FADE0)
        const float overlap = 0.0;
        const float hoff = 0.0;
        float f0 = tanh_approx(max(p.y+overlap, 0.0)+0.1)*step(overlap, p.y);
        float f1 = tanh_approx(max(-p.y+overlap, 0.0));
        vec3 lcol0 = hsv2rgb(vec3(hoff+0.58, 0.8, 2.0*(f0)));
        vec3 lcol1 = hsv2rgb(vec3(hoff+0.05 , 0.9 , 2.0*(f1)));
        vec3 lcol2 = hsv2rgb(vec3(hoff+0.025, 0.9, mix(0.01, 0.1, beat(TIME))))/(abs(p.y)*(abs(p.x*p.x)+0.2));
        vec3 col = vec3(0.0);
        col += lcol0;
        col += lcol1;
        col += lcol2;
        return col;
      #else
        return vec3(1.0);
      #endif


      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 effect0(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        vec2 lp = p;
        float bcount = beatCount(TIME);
        int i = int(mod(floor(bcount)+2.0, 3.0));
        switch(i) {
        case 0:
          lp *= 0.26;
          lp.x -= 0.0125;
          break;
        case 1:
          lp *= 0.17;
          lp.x -= 0.033;
          break;
        case 2:
          lp *= 0.23;
          lp.x -= 0.025;
          break;
        default:
          break;
        }
        vec4 lcol = impulseText(lp, i);
        float h = max(max(lcol.x, lcol.y), lcol.z);

        vec2 hp = p;
        hp.x *= mix(1.0, 0.9, beat(TIME+0.1*hp.y-0.15));
        hp.y -= -0.5;
        float d = heart(hp);
      //  d = abs(d) - 0.02;

        vec3 col = vec3(0.1);
        vec3 fcol = fade(p);
        col += HSV2RGB(vec3(0.9, 0.8, 0.3))*exp(-4.0*max(d-0.05, 0.0));
        col = mix(col, HSV2RGB(vec3(0.5, 0.0, 1.0)), smoothstep(aa, -aa, d-0.05));
        col = mix(col, HSV2RGB(vec3(0.9, 0.66, 1.0)), smoothstep(aa, -aa, d-0.025));
        col *= 1.0-tanh_approx(length(p));
        lcol.xyz = mix(lcol.xyz, fcol, sqrt(h));
        col = mix(col, 1.0*lcol.xyz, lcol.w);
        col += hsv2rgb(vec3(0.025, 0.5, 0.15))*beat(TIME)/dot2(p);
        col += 2.0*smoothstep(7.0, 7.5, bcount);
        return col;
      }


      float df(vec2 p) {
        const float hz = .25;
        p /= hz;
        vec2 hp0 = p;
        vec2 hn0 = hextile(hp0);
        vec2 hsn0= shash2(hn0);
        hp0 += 0.25*hsn0;
        float d0 = length(hp0) - mix(0.01, 0.2, abs(hsn0.y));

        vec2 hp1 = p;
        hp1 += vec2(1.0, sqrt(1.0/3.0));
        vec2 hn1 = hextile(hp1);
        vec2 hsn1= shash2(hn1);
        hp1 += 0.25*hsn1;
        float d1 = length(hp1) - mix(0.01, 0.2, abs(hsn1.y));

        float d = d0;
        d = min(d, d1);

        return -d*hz;
      }

      vec3 effect1(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        float bcount = beatCount(TIME);

        vec3 hsv = vec3(0.0);

        float fi0 = smoothstep(0.0, 1.0, bcount);
        float fi1 = smoothstep(1.0, 2.0, bcount);
        float fi2 = smoothstep(2.0, 3.0, bcount);
        float fo3 = smoothstep(4.0, 3.5, bcount);

        p *= ROT(mix(3.0*PI/12.0, PI/6.0, fi0));
        vec2 lp = p;
        const float lw = 0.75;
        float ln = mod1(lp.y, lw);

        float fp1 = 0.5*lp.x+lp.y;
        fp1 = fract(fp1/0.1);

        int i = 0;
        if (ln == 1.0) {
          i = 1;
          lp *= 0.2;
          lp.x += mix(-0.75, 0.0, fi1);
          hsv = vec3(0.0, 0.0, fi1*fi1);
        } else if (ln == 0.0) {
          i = 9;
          lp *= mix(0.1, 0.25, fi0);
          hsv = vec3(0.15, .0, 0.0);
        } else if (ln == -1.0) {
          i = 12;
          lp *= 0.29;
          lp.x += mix(0.75, 0.0, fi2);
          hsv = vec3(0.6, fi2, fi2*fi2);
        } else {
          return vec3(0.0);
        }

        vec3 flash = hsv2rgb(vec3(0.6, 0.75, 2.0))*smoothstep(0.5, 0.0, fract(bcount))/dot(p, p);

        vec3 col = vec3(0.);
        float d = df(p);
        col = hsv2rgb(hsv)*smoothstep(aa, -aa, d);

        vec4 lcol = impulseLogoCenter(lp, i);

        col = mix(col, lcol.xyz, lcol.w);
        col *= fi0;
        if (ln == 1.0 && floor(bcount) == 1.0) {
          col += flash;
        } else if (ln == 0.0 && floor(bcount) == 0.0) {
          col += flash;
        } else if (ln == -1.0 && floor(bcount) == 2.0) {
          col += flash;
        } else {
        }

        col *= fo3;

        return col;
      }


      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = vec3(0.0);
        float bcount = beatCount(TIME);
      //    col = effect0(p);
        if (bcount < 0.0) {
          col = vec3(0.0);
        } else if (bcount < 4.0 && bcount >= 0.0) {
          col = effect1(p);
        } else if (bcount < 7.0 && bcount >= 4.0) {
          col = effect0(p);
        } else {
          col = vec3(1.0);
        }
        col = aces_approx(col);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_001_crew" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------


      /*
      #define REPEAT

      #define GLIMGLAM
      #define JEZ
      #define LANCE
      #define LONGSHOT
      */
      #define TIME        time
      #define RESOLUTION  resolution

      #define COLORBURN
      #define SKYDOME

      #define PI            3.141592654
      #define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))

      const int   bars     = 7;
      const mat2  trans    = ROT(PI/9.0);
      const float twist    = 1.0;
      const float dist     = 0.5;
      const float rounding = 0.125;

      const float raymarchFactor = 0.8;

      #define TAU         (2.0*PI)
      #define TIME        time
      #define RESOLUTION  resolution

      #define MAX_RAY_LENGTH  15.0
      #define MAX_RAY_MARCHES 70
      #define TOLERANCE       0.001
      #define NORM_OFF        0.005

      #if defined(REPEAT)
      const float effect_start  = BTIME(16.0);
      const float effect_fadein = BTIME(16.0+0.125);
      const float effect_oops_fi= BTIME(17.0+3.0*0.125);
      const float effect_oops_fo= BTIME(17.0+4.0*0.125);
      const float effect_fadeout= BTIME(18.0-0.25);
      const float effect_end    = BTIME(18.0);
      const float effect_period = BTIME(18.0)-BTIME(16.0);
      #else
      const float effect_start  = BTIME(1.0);
      const float effect_fadein = BTIME(1.0+0.125);
      const float effect_fadeout= BTIME(9.0-0.5);
      const float effect_end    = BTIME(9.0);
      const float effect_period = BTIME(3.0)-BTIME(1.0);
      #endif

      int g_hit     = 0;

      // -----------------------------------------------------------------------------
      // Licenses
      //  CC0     - https://creativecommons.org/share-your-work/public-domain/cc0/
      //  MIT     - https://mit-license.org/
      //  WTFPL   - https://en.wikipedia.org/wiki/WTFPL
      //  Unknown - No license identified, does not mean public domain
      // -----------------------------------------------------------------------------

      // Glimglam distance field font

      const float glimglam_corner0 = 0.02;
      const float glimglam_corner1 = 0.075;
      const float glimglam_topy    = 0.0475+glimglam_corner0*0.5;
      const float glimglam_smoother= 0.0125;

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float corner(vec2 p) {
        vec2 v = min(p, vec2(0));
        return length(max(p, vec2(0))) + max(v.x, v.y);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float roundedBox(vec2 p, vec2 b, vec4 r) {
          r.xy = (p.x>0.0)?r.xy : r.zw;
          r.x  = (p.y>0.0)?r.x  : r.y;
          vec2 q = abs(p)-b+r.x;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_bar(vec2 p) {
        vec2 pbar = p;
        pbar.y -= glimglam_topy;
        return abs(pbar.y)-glimglam_corner0;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_a(vec2 p) {
        p.x = abs(p.x);
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));
        float dc = corner(p-vec2(0.045, -0.07))-glimglam_corner0;

        float d = db;
        d = max(d, -dc);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_c(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));
        p.x = abs(p.x);
        float dc = corner(p-vec2(0.05, glimglam_topy))-glimglam_corner0;

        float d = db;
        d = max(d, -dc);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_e(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_g(vec2 p) {
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner0, glimglam_corner1, glimglam_corner1, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.045, -0.055)));
        dc = abs(dc) - glimglam_corner0;
        float dd = max(p.x-0.065, p.y-glimglam_topy);
        float d = db;
        d = max(d, -max(dc, dd));
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_h(vec2 p) {
        p.x = abs(p.x);
        float da = roundedBox(p-vec2(0.13, 0.0), vec2 (0.066, 0.166), vec4(glimglam_corner0));
        float db = roundedBox(p, vec2 (0.16, 0.05), vec4(glimglam_corner0));
        float d = da;
        d = min(d, db);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_i(vec2 p) {
        return roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_j(vec2 p) {
        p.x = -p.x;
        float db = roundedBox(p, vec2 (0.15, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.007, -0.055)))-glimglam_corner0;
        float d = db;
        d = max(d, -dc);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_l(vec2 p) {
        float db = roundedBox(p, vec2 (0.175, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.027, -0.055)))-glimglam_corner0;
        float d = db;
        d = max(d, -dc);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_m(vec2 p) {
        float db = roundedBox(p, vec2 (0.255, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));
        p.x = abs(p.x);
        float dl = abs(p.x-0.095)-glimglam_corner0*2.0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -max(dl,dt));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_n(vec2 p) {
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));

        float dl = abs(p.x)-0.07;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -max(dl,dt));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_o(vec2 p) {
        const float sz = 0.05;
        float db = roundedBox(p, vec2(0.19, 0.166)-sz, vec4(glimglam_corner1, glimglam_corner1, glimglam_corner1, glimglam_corner1)-sz);
        db = abs(db)-sz;

        float d = db;

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_s(vec2 p) {
        p.x = -p.x;
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        vec2 pc = p;
        pc.x *= sign(pc.y);
        pc.y = abs(pc.y);
        float cr = glimglam_corner1*1.3;
        pc -=vec2(-0.055, 0.20);
        pc.x = -pc.x;
        float dc = corner(pc+cr)-cr;
        vec2 pk = p;
        pk = -abs(pk);
        float dk = pk.x+glimglam_topy;
        dc = min(dk, dc);

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));
        d = pmax(d, dc, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_t(vec2 p) {
        float da = roundedBox(p-vec2(0.0, 0.12), vec2 (0.166, 0.05), vec4(glimglam_corner0));
        float db = roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));
        float d = da;
        d = min(d, db);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_z(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));
        vec2 pc = p;
        pc.x *= sign(pc.y);
        pc.y = abs(pc.y);
        float cr = glimglam_corner1*1.3;
        pc -=vec2(-0.055, 0.20);
        pc.x = -pc.x;
        float dc = corner(pc+cr)-cr;
        vec2 pk = p;
        pk = -abs(pk);
        float dk = pk.x+glimglam_topy;
        dc = min(dk, dc);

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));
        d = pmax(d, dc, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam(vec2 p) {
        float dbar = glimglam_bar(p);

        vec2 pg = p;
        pg.x -= -0.665;
        pg.x = -abs(pg.x);
        pg.x -= -0.7475;
        pg.x *= -sign(p.x+0.665);
        float dg = glimglam_g(pg);

        vec2 pi = p;
        pi.x -= -0.746;
        float di = glimglam_i(pi);

        vec2 pl = p;
        pl.x -= -0.27;
        pl.x = -abs(pl.x);
        pl.x -= -0.745;
        pl.x *= -sign(p.x+0.27);
        float dl = glimglam_l(pl);

        vec2 pa = p;
        pa.x -= 0.87;
        float da = glimglam_a(pa);

        vec2 pm = p;
        pm.x -= 0.475;
        pm.x = abs(pm.x);
        pm.x -= 0.875;
        pm.x *= sign(p.x-0.475);
        float dm = glimglam_m(pm);

        float d = 1E6;
        d = min(d, dg);
        d = min(d, dl);
        d = min(d, di);
        d = min(d, da);
        d = min(d, dm);
        d = pmax(d, -dbar, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float lance(vec2 p) {
        p.x -= -0.810;
        float dbar = glimglam_bar(p);

        vec2 pl = p;
        float dl = glimglam_l(pl);

        vec2 pa = p;
        pa.x -= 0.39;
        float da = glimglam_a(pa);

        vec2 pn = p;
        pn.x -= 0.795;
        float dn = glimglam_n(pn);

        vec2 pc = p;
        pc.x -= 1.2;
        float dc = glimglam_c(pc);

        vec2 pe = p;
        pe.x -= 1.605;
        float de = glimglam_e(pe);

        float d = 1E6;
        d = min(d, dl);
        d = min(d, da);
        d = min(d, dn);
        d = min(d, dc);
        d = min(d, de);
        d = pmax(d, -dbar, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float jez(vec2 p) {
        p.x -= -0.401;
        float dbar = glimglam_bar(p);

        vec2 pj = p;
        float dj = glimglam_j(pj);

        vec2 pe = p;
        pe.x -= 0.36;
        float de = glimglam_e(pe);

        vec2 pz = p;
        pz.x -= 0.76;
        float dz = glimglam_z(pz);

        float d = 1E6;
        d = min(d, dj);
        d = min(d, de);
        d = min(d, dz);
        d = pmax(d, -dbar, glimglam_smoother);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float longshot(vec2 p) {
        p.x -= -1.385;
        float dbar = glimglam_bar(p);

        vec2 pl = p;
        float dl = glimglam_l(pl);

        vec2 po = p;
        po -= vec2(1.395, 0.0);
        po.x = abs(po.x);
        po -= vec2(1.0125, 0.0);
        float do_ = glimglam_o(po);

        vec2 pn = p;
        pn -= vec2(0.785, 0.0);
        float dn = glimglam_n(pn);

        vec2 pg = p;
        pg -= vec2(1.185, 0.0);
        float dg = glimglam_g(pg);

        vec2 ps = p;
        ps -= vec2(1.585, 0.0);
        float ds = glimglam_s(ps);

        vec2 ph = p;
        ph -= vec2(1.995, 0.0);
        float dh = glimglam_h(ph);

        vec2 pt = p;
        pt -= vec2(2.78, 0.0);
        float dt = glimglam_t(pt);

        float d = 1E6;
        d = min(d, dl);
        d = min(d, do_);
        d = min(d, dn);
        d = min(d, dg);
        d = min(d, ds);
        d = min(d, dh);
        d = min(d, dt);
        d = pmax(d, -dbar, glimglam_smoother);
        return d;
      }


      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 band_color(float ny) {
        vec3 hsv = vec3(0.0);
        float ramp = 1.0/abs(ny);
        if (abs(ny) < 4.0) {
          hsv = vec3(0.0, 0.0, 0.);
        } else if (ny > 0.0) {
          hsv = vec3(0.88, 2.5*ramp,0.8);
        } else {
          hsv = vec3(0.53, 4.0*ramp, 0.8);
        }

        return hsv2rgb(hsv);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b, vec4 r) {
        r.xy = (p.x>0.0)?r.xy : r.zw;
        r.x  = (p.y>0.0)?r.x  : r.y;
        vec2 q = abs(p)-b+r.x;
        return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
      }

      float fadeIn(float x) {
        return mix(-0.1, 1.0, smoothstep(-0.9, -0.5, -cos(-0.1*x+TAU*(TIME-effect_start)/effect_period)));
      }

      float df_bars1(vec3 p) {
        float tm = TIME+2.0;
        p.y += dist*sin(0.5*p.x+0.5*p.z+tm);
        vec2 bp = p.zy;

        float d = 1E6;

        float bs = 0.25*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);

        for (int i = 0; i < bars; ++i) {
          float ii = float(i);
          vec2 pp = bp;
          float a = -tm+0.5*ii;
          float b = ii+p.x-2.0*tm;
          pp.y += sin(a);
          mat2 rot = ROT(-PI/4.0*cos(a+twist*b));
          pp.x -= bsz.x*sqrt(2.0)*ii;
          pp *= rot;
          float dd = box(pp, bsz, brd);
          if (dd < d) {
            g_hit = i;
            d = dd;
          }
        }

        return d;
      }

      float df_bars2(vec3 p) {
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        vec2 p2 = p.yz;
        p2 *= ROT(TIME+p.x);
        vec2 s2 = sign(p2);
        p2 = abs(p2);
        p2 -= 0.4;
        g_hit = 3+int(s2.y+2.0*s2.x)-1;
        float bs = 0.35*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        return length(p2)-bs;
      }

      float df_bars3(vec3 p) {
        const float r = 0.25;
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        mat2 rot = ROT(TIME+p.x);
        vec2 p2 = p.yz;
        vec2 s2 = vec2(0.0);

        p2 *= rot;
        s2 += 2.0*sign(p2);
        p2 = abs(p2);
        p2 -= 2.0*r;

        p2 *= rot;
        s2 += 1.0*sign(p2);
        p2 = abs(p2);
        p2 -= 1.0*r;

        g_hit = 3+int(s2.y+2.0*s2.x)-1;

        float bs = (0.9*r)*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        float d0 = length(p2)-bs;
        float d1 = box(p2, bsz, brd);
        float d = d0;
        return d;
      }

      float df_bars4(vec3 p) {
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        vec2 p2 = p.yz;
        p2 *= ROT(TIME+p.x);
        vec2 s2 = sign(p2);
        p2 = abs(p2);
        p2 -= 0.4;
        g_hit = 3+int(s2.y+2.0*s2.x)-1;

        float bs = 0.35*fadeIn(p.x);

        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        return box(p2, bsz, brd);
      }

      float df(vec3 p) {
        p.xy *= trans;
      #if defined(GLIMGLAM)
        return df_bars2(p);
      #elif defined(LONGSHOT)
        return df_bars4(p);
      #elif defined(JEZ)
        return df_bars3(p);
      #elif defined(LANCE)
        return df_bars1(p);
      #elif defined(REPEAT)
        return df_bars3(p);
      #else
        return length(p) - 0.5;
      #endif
      }

      float rayMarch(vec3 ro, vec3 rd, float ti) {
        float t = ti;
        int i = 0;
        vec2 dti = vec2(1e10,0.0);
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          if (d<dti.x) { dti=vec2(d,t); }
          t += raymarchFactor*d;
        }
        if(i==MAX_RAY_MARCHES) { t=dti.y; }
        return t;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      const vec3 lightPos = vec3(2.0, 3.0, -5.0);
      const vec3 lightCol = vec3(HSV2RGB(vec3(0.53, 0.5, 1.0)));
      const vec3 overCol  = vec3(HSV2RGB(vec3(0.88, 0.25, 0.8)));

      vec3 skyColor(vec3 ro, vec3 rd) {
        vec3  ld    = normalize(lightPos - ro);
        float dif   = max(dot(ld, rd), 0.0);

        vec3  col   = vec3(0.0);

        if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) {
          col = 2.0*overCol*rd.y;
        }
        float rb = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;

        col += overCol*pow(clamp(1.0 - rb*0.5, 0.0, 1.0), 6.0);
        col += lightCol*pow(dif, 8.0);
        col += 4.0*lightCol*pow(dif, 40.0);
        return col;
      }

      vec3 effect(vec2 p) {
        vec3 ro = vec3(0.0, 0.0, -5.0);
        vec3 la = vec3(0.0, 0.0, 0.0);
        vec3 ww = normalize(la-ro);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));
        vec3 vv = normalize(cross(ww,uu));
        const float fov = 3.0;
        vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );

        g_hit = -1;
        float t = rayMarch(ro, rd, 3.0);
        int hit = g_hit;

        vec3 col = vec3(1.0);
        vec3 bcol = band_color(-4.0*float(hit-(bars-1)/2));
        bcol *= bcol;
        if (t < MAX_RAY_LENGTH) {
          vec3 p = ro + rd*t;
          vec3 n = normal(p);
          vec3 r = reflect(rd, n);
          vec3 ld= normalize(lightPos-p);

          float dif = max(dot(ld, n), 0.0);
          col = bcol*mix(0.5, 1.0, dif);
      #ifdef SKYDOME
          vec3 rs= skyColor(p, r);
          float fre = 1.0+dot(rd, n);
          fre *= fre;
          float rf  = mix(0.05, 1.0, fre);
          col += rf*rs;
      #else
          float spe = pow(max(dot(ld, r), 0.0), 30.0);
          col += spe;
      #endif
        }

      #if defined(REPEAT)
        vec2 tp = p;
        float fi = smoothstep(effect_oops_fo, effect_oops_fi, TIME);
        tp.y += 4.0*sign(p.x)*fi;
        tp *= 0.2;
        vec4 tcol = impulseText(tp, 3);
        col = mix(col, vec3(fi), step(effect_oops_fi, TIME));
        col = mix(col, mix(vec3(0.5, 0.5, 0.5), vec3(1.0), tcol.xyz), tcol.w);

      #else
        float aa = 2.0/RESOLUTION.y;
      #if defined(GLIMGLAM)
        float ld = glimglam(p);
      #elif defined(LONGSHOT)
        float ld = longshot(p);
      #elif defined(JEZ)
        float ld = jez(p);
      #elif defined(LANCE)
        float ld = lance(p);
      #else
        float ld = length(p) - 0.25;
      #endif

        col = mix(col, vec3(1.0), smoothstep(aa, -aa, ld));
      #endif

        return col;
      }


      void main() {
        vec2 q = v_texcoord;
        vec2 p  = -1. + 2. * q;
        p.x     *= RESOLUTION.x/RESOLUTION.y;

        vec3 col  = vec3(0.0);
        col = effect(p);

      #if defined(COLORBURN)
        col -= vec3(0.2, 0.3, 0.2);
      #endif
        col += smoothstep(effect_fadein, effect_start, TIME);
      #if defined(REPEAT)
        col *= smoothstep(effect_end, effect_fadeout, TIME);
        col = aces_approx(col);
      #else
        col = aces_approx(col);
        col += smoothstep(effect_fadeout, effect_end, TIME);
      #endif
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_002_hexler_march" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      const float planeDist = 1.0-0.33;

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))


      // License: Unknown, author: Unknown, found: don't remember
      vec4 alphaBlend(vec4 back, vec4 front) {
        float w = front.w + back.w*(1.0-front.w);
        vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;
        return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec3 alphaBlend(vec3 back, vec4 front) {
        return mix(back, front.xyz, front.w);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(in vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      vec3 offset(float z) {
        float a = z;
        vec2 p = -0.2*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.05;
        return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.05;
        return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toPolar(vec2 p) {
        return vec2(length(p), atan(p.y, p.x));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 toRect(vec2 p) {
        return vec2(p.x*cos(p.y), p.x*sin(p.y));
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec4 effect(vec2 p, float aa, float h) {
        vec2 hhn = hextile(p);
        const float w = 0.02;
        vec2 pp = toPolar(p);
        float a = pp.y;
        float hn = mod1(pp.y, TAU/6.0);
        vec2 hp = toRect(pp);
        float hd = hp.x-(w*10.0);

        float x = hp.x-0.5*w;
        float n = mod1(x, w);
        float d = abs(x)-(0.5*w-aa);

        float h0 = hash(10.0*hhn+2.0*h+n);
        float h1 = fract(8667.0*h0);
        float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));
        const float coln = 6.0;
        float t = smoothstep(aa, -aa, d)*smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*time+h1*TAU))*exp(-150.0*abs(x));
        vec3 col = hsv2rgb(vec3(floor(h0*coln)/coln, 0.8, 1.0))*t*2.0;

        t = mix(0.9, 1.0, t);
        t *= smoothstep(aa, -aa, -hd);
        if (hd < 0.0) {
          col = vec3(0.0);
          t = 15.*dot(p, p);
        }
        return vec4(col, t);
      }

      vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {
        float h0 = hash(n);
        float h1 = fract(8667.0*h0);

        vec3 hn;
        vec2 p  = (pp-off*vec3(1.0, 1.0, 0.0)).xy;
        p *= ROT(TAU*h0);
        p.x -= 0.25*(pp.z-ro.z)*sin(0.1*n);
        const float z = 0.5;
        p /= z;
        float aa = distance(pp,npp)*sqrt(1.0/3.0)/z;
        vec4 col = effect(p, aa, h1);

        return col;
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        return vec3(0.0);
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        float lp = length(p);
        vec2 np = p + 2.0/RESOLUTION.y;
        float rdd = (2.5-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions
      //  float rdd = 2.5;

        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);

        const int furthest = 5;
        const int fadeFrom = max(furthest-2, 0);

        const float fadeDist = planeDist*float(furthest - fadeFrom);
        float nz = floor(ro.z / planeDist);

        vec3 skyCol = skyColor(ro, rd);


        vec4 acol = vec4(0.0);
        const float cutOff = 0.95;
        bool cutOut = false;

        float maxpd = 0.0;

        // Steps from nearest to furthest plane and accumulates the color
        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          if (pd > 0.0 && acol.w < cutOff) {
            vec3 pp = ro + rd*pd;
            maxpd = pd;
            vec3 npp = ro + nrd*pd;

            vec3 off = offset(pp.z);

            vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);
            float fadeOut = smoothstep(0.0, planeDist*0.1, nz);
      //      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
            pcol.w *= fadeOut*fadeIn;
            pcol = clamp(pcol, 0.0, 1.0);

            acol = alphaBlend(pcol, acol);
          } else {
            cutOut = true;
            acol.w = acol.w > cutOff ? 1.0 : acol.w;
            break;
          }

        }

        vec3 col = alphaBlend(skyCol, acol);
      // To debug cutouts due to transparency
      //  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);
        return col;
      }

      vec3 effect(vec2 p, vec2 q) {
        float tm  = planeDist*TIME*0.25*bhz;
        vec3 ro   = offset(tm);
        vec3 dro  = doffset(tm);
        vec3 ddro = ddoffset(tm);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
        vec3 vv = cross(ww, uu);

        vec3 col = color(ww, uu, vv, ro, p);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, q);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_002_hexler_march_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame         ;
      uniform sampler2D prev_pass          ;

      const float effect_start  = BTIME(9.0);
      const float effect_fadein = BTIME(9.0+0.375);

      const float logo_fadein_b = BTIME(10.0);
      const float logo_fadein_e = BTIME(10.0+0.125);

      const float effect_fadeout= BTIME(13.0-0.25);
      const float effect_end    = BTIME(13.0);


      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))


      const mat2 brot = ROT(2.399);
      //  simplyfied version of Dave Hoskins blur
      vec3 dblur(vec2 q,float rad) {
        vec3 acc=vec3(0);
        const float m = 0.0025;
        vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);
        vec2 angle=vec2(0,rad);
        rad=1.;
        const int iter = 30;
        for (int j=0; j<iter; ++j) {
          rad += 1./rad;
          angle*=brot;
          vec4 col=texture(prev_frame,q+pixel*(rad-1.)*angle);
          col.xyz*=col.xyz;
          acc+=col.xyz;
        }
        return acc*(1.0/float(iter));
      }

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec4 pcol = texture(prev_pass,q);
        vec3 bcol = dblur(q, .75);

        vec3 col = pcol.xyz;
        col += vec3(0.9, .8, 1.2)*mix(0.5, 0.8, length(p))*(vec3(0.05)+bcol);

        float fo = smoothstep(effect_fadeout, effect_end, TIME);

        vec2 lp = p;
        lp.x *= RESOLUTION.x/RESOLUTION.y;
        lp -= vec2(-0.75, -0.66)+vec2(0.0, -1.0)*(smoothstep(logo_fadein_e, logo_fadein_b, TIME)+fo);
        lp *= 0.33;
        float b = beat(TIME);
        lp *= ROT(0.1*b*(1.0+lp.x*-6.0));
        vec4 lcol = impulseLogoCenter(lp, 10);

        const vec3 fcol = HSV2RGB(vec3(0.05, 0.95, 0.25));
        float pp = dot(p, p);
        col += b*pp*fcol;
        col = mix(col, lcol.xyz, lcol.w);
        col += smoothstep(effect_fadein, effect_start, TIME+0.5*pp);
        col += fo;
        col = sRGB(col);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_003_monterey" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      const float effect_start  = BTIME(13.0);
      const float effect_flare  = BTIME(13.0+0.25);
      const float effect_fadein = BTIME(13.0+0.875);
      const float effect_end    = BTIME(15.0);

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: Unknown, found: don't remember
      vec4 alphaBlend(vec4 back, vec4 front) {
        float w = front.w + back.w*(1.0-front.w);
        vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;
        return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec3 alphaBlend(vec3 back, vec4 front) {
        return mix(back, front.xyz, front.w);
      }

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 p) {
        float a = dot (p, vec2 (127.1, 311.7));
        return fract(sin(a)*43758.5453123);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr
      float vnoise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);

        vec2 u = f*f*(3.0-2.0*f);

        float a = hash(i + vec2(0.0,0.0));
        float b = hash(i + vec2(1.0,0.0));
        float c = hash(i + vec2(0.0,1.0));
        float d = hash(i + vec2(1.0,1.0));

        float m0 = mix(a, b, u.x);
        float m1 = mix(c, d, u.x);
        float m2 = mix(m0, m1, u.y);

        return m2;
      }

      float heightFactor(vec2 p) {
        return 2.0*smoothstep(0.0, 1.25, abs(p.x)-0.05)+1.0;
      }

      float hifbm(vec2 p) {
        float hf = heightFactor(p);
        const float aa = 0.5;
        const float pp = 2.0-0.;

        float sum = 0.0;
        float a   = 1.0;

        for (int i = 0; i < 5; ++i) {
          sum += a*vnoise(p);
          a *= aa;
          p *= pp;
        }

        return hf*sum;
      }

      float lofbm(vec2 p) {
        float hf = heightFactor(p);
        const float aa = 0.5;
        const float pp = 2.0-0.;

        float sum = 0.0;
        float a   = 1.0;

        for (int i = 0; i < 2; ++i) {
          sum += a*vnoise(p);
          a *= aa;
          p *= pp;
        }

        return hf*sum;
      }

      vec3 offset(float z) {
        float a = z*0.5;
        vec2 p = vec2(0.33, 0.1)*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
      //  vec2 p = vec2(0.0, 0.0);
        return vec3(p, z);
      }

      vec3 doffset(float z) {
        float eps = 0.1;
        return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);
      }

      vec3 ddoffset(float z) {
        float eps = 0.1;
        return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);
      }

      float hiheight(vec2 p) {
        return hifbm(p)-1.8;
      }

      float loheight(vec2 p) {
        return lofbm(p)-2.15;
      }

      vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {
        vec2 p = (pp-off*2.0*vec3(1.0, 1.0, 0.0)).xy;

        const vec2 stp = vec2(0.5, 0.33);
        float he    = hiheight(vec2(p.x, pp.z)*stp);
        float lohe  = loheight(vec2(p.x, pp.z)*stp);

        float d = p.y-he;
        float lod = p.y - lohe;

        float aa = distance(pp, npp)*sqrt(1.0/3.0);

        float df = tanh_approx(max(0.225*distance(ro, pp)-0.4, 0.));
        float hf = mix(0.66, 1.05, df);
        float gf = tanh_approx(exp(-2.0*lod));
        float yf = smoothstep(2.5, -1.0, pp.y);
        vec3 acol = hsv2rgb(vec3(hf +0.1, 1.0, mix(0.2, 1.0, df)));
        vec3 gcol = hsv2rgb(vec3(hf, 1.0, 1.0-gf));

        float t = smoothstep(aa, -aa, d);
        t *= mix(1.0, yf, sqrt(df));
        t = max(t, gf*yf*yf);
        vec3 col = vec3(0.0);
        col += acol;
        col += 0.5*gcol;

        return vec4(col, t);
      }

      const vec3 skyCol = HSV2RGB(vec3(0.66, 0.2, 1.0));

      vec3 skyColor(vec3 ro, vec3 rd, vec3 nrd) {
        return skyCol;
      }

      vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
        vec2 np = p + 2.0/RESOLUTION.y;
        const float rdd = 2.0;
        vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);

        const float planeDist = 1.0-0.4;
        const int furthest = 12;
        const int fadeFrom = max(furthest-3, 0);

        const float fadeDist = planeDist*float(fadeFrom);
        const float maxDist  = planeDist*float(furthest);
        float nz = floor(ro.z / planeDist);

        vec3 skyCol = skyColor(ro, rd, nrd);

        vec4 acol = vec4(0.0);
        const float cutOff = 0.995;
        bool cutOut = false;

        for (int i = 1; i <= furthest; ++i) {
          float pz = planeDist*nz + planeDist*float(i);

          float pd = (pz - ro.z)/rd.z;

          vec3 pp = ro + rd*pd;

          if (pd > 0.0 && acol.w < cutOff) {
            vec3 npp = ro + nrd*pd;

            vec3 off = offset(pp.z);

            vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));

            float nz = pp.z-ro.z;
            float fadeIn = smoothstep(maxDist, fadeDist, pd);
            float fadeOut = smoothstep(0.0, planeDist, pd);
            pcol.w *= fadeIn;
            pcol.w *= fadeOut;

            acol = alphaBlend(pcol, acol);
          } else {
            cutOut = true;
            acol.w = acol.w > cutOff ? 1.0 : acol.w;
            break;
          }

        }

        vec3 col = alphaBlend(skyCol, acol);
      // To debug cutouts due to transparency
      //  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);
        return col;
      }

      vec3 effect(vec2 p, vec2 q) {
        const mat2 rot = ROT(0.1);
        float z  = TIME*0.5;
        vec3 ro   = offset(z);
        vec3 dro  = doffset(z);
        vec3 ddro = ddoffset(z);
        dro.zy *= rot;
        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+2.*ddro), ww));
        vec3 vv = cross(ww, uu);

        vec3 col = color(ww, uu, vv, ro, p);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = vec3(0.0);
        col = effect(p, q);
        col += skyCol*smoothstep(effect_fadein, effect_start, TIME+length(p));
        col = mix(col, vec3(1.0), smoothstep(effect_flare, effect_start, TIME));
      //  col = aces_approx(col);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_004_beats" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      #define TOLERANCE       0.0001
      #define MAX_RAY_LENGTH  10.0
      #define MAX_RAY_MARCHES 50
      #define NORM_OFF        0.0001

      const float effect_start  = BTIME(18.0);
      const float effect_fadein = BTIME(18.0+0.25);
      const float effect_fadeout= BTIME(20.0-0.25);
      const float effect_end    = BTIME(20.0);

      float softBeat(float tm) {
        return smoothstep(-0.75, 0.75, cos(TAU*beatCount(tm)));
      }

      const float smoothing  = 0.066;

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      float boxf(vec3 p, vec3 b, float e) {
        p = abs(p  )-b;
        vec3 q = abs(p+e)-e;
        return min(min(
            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
      }

      float pmin(float a, float b, float k) {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      vec3 pmin(vec3 a, vec3 b, float k) {
        vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      vec3 pabs(vec3 a, float k) {
        return -pmin(a, -a, k);
      }

      vec3 refl(vec3 p, vec3 n) {
        p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;
        return p;
      }

      float sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
        float ndbuffer = dbuffer/sph.w;
        vec3  rc = (ro - sph.xyz)/sph.w;

        float b = dot(rd,rc);
        float c = dot(rc,rc) - 1.0;
        float h = b*b - c;
        if( h<0.0 ) return 0.0;
        h = sqrt( h );
        float t1 = -b - h;
        float t2 = -b + h;

        if( t2<0.0 || t1>ndbuffer ) return 0.0;
        t1 = max( t1, 0.0 );
        t2 = min( t2, ndbuffer );

        float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
        float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
        return (i2-i1)*(3.0/4.0);
      }

      float df(vec3 p) {
        vec3 op = p;
        const float zf = 2.5;
        const int mid  = 1;
        const int end  = 3;
        const vec3 n0  = normalize(vec3(-1.0,  1.0,  1.0));
        const vec3 n1  = normalize(vec3( 1.0, -1.0,  1.0));
        const vec3 n2  = normalize(vec3( 1.0,  1.0, -1.0));
        const vec3 off = normalize(vec3(1.0, 1.0, 1.0));

        float z = 1.0;
        vec3  cp = off;

        mat2 rxy = ROT(0.5*time*sqrt(0.5));
        mat2 ryz = ROT(0.5*time);

        for (int i = 0; i < mid; ++i) {
          p.xy *= rxy;
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*0.33;
          p *= zf;
          z *= zf;
        }

        float sb = softBeat(TIME+(dot(op, op)+op.x)*-0.5);
        float rr = mix(0.24, 0.33, sb);
        float d = 1E6;
        for (int i = mid; i < end; ++i) {
          p.xy *= rxy;
          p.yz *= ryz;
          p = pabs(p, smoothing);
          p = refl(p, n0);
          p = refl(p, n1);
          p = refl(p, n2);
          p -= off*rr;
          p *= zf;
          z *= zf;

          vec3 pp = p;
          float dd0 = boxf(pp, 0.1*vec3(1.0), 0.0125)-0.0125;
          float dd1 = length(pp)- 0.075;
          float dd = dd0;
          dd = min(dd, dd1);
          dd /= z;
          d = min(d, dd);
        }

        return d;
      }

      float rayMarch(vec3 ro, vec3 rd, out int iter) {
        float t = 0.0;
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          t += d;
        }
        iter = i;
        return t;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {
        const float minShadow = 0.25;
        float res = 1.0;
        float t = mint;
        for (int i=0; i<24; i++) {
          float d = df(pos + ld*t);
          res = min(res, k*d/t);
          if (ll <= t) break;
          if(res <= minShadow) break;
          t += max(mint*0.2, d);
        }
        return clamp(res,minShadow,1.0);
      }

      vec3 render(vec3 ro, vec3 rd, float b) {
        vec3 lightPos = vec3(1.0);
        float alpha   = 0.05*TIME;

        const vec3 skyCol = vec3(0.0);
        const vec3 gcol0 = HSV2RGB(vec3(0.05, 0.8, 3.0));
        const vec3 gcol1 = HSV2RGB(vec3(0.05, 0.5 , 8.0));
        int iter    = 0;
        float t     = rayMarch(ro, rd, iter);

        float sb    = b;
        float sr    = mix(0.4, 0.45, sb);
        vec3 gf     = mix(gcol0, gcol1, sb);
        float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);

        vec3 gcol   = sd*gf;

        if (t >= MAX_RAY_LENGTH) {
          return gcol;
        }

        vec3 pos    = ro + t*rd;
        vec3 nor    = normal(pos);
        vec3 refl   = reflect(rd, nor);
        float ii    = float(iter)/float(MAX_RAY_MARCHES);
        float ifade = 1.0-tanh_approx(1.25*ii);
        float h     = fract(-1.0*length(pos)+0.1);
        float s     = 0.25;
        float v     = tanh_approx(0.4/(1.0+40.0*sd));
        vec3 color  = hsv2rgb(vec3(h, s, v));

        vec3 lv   = lightPos - pos;
        float ll2 = dot(lv, lv);
        float ll  = sqrt(ll2);
        vec3 ld   = lv / ll;
        float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);

        float dm  = 4.0/ll2;
        float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;
        float spe = pow(max(dot(refl, ld), 0.), 20.);
        float ao  = smoothstep(0.5, 0.1 , ii);
        float l   = mix(0.2, 1.0, dif*sha*ao);

        vec3 col = l*color + 2.0*spe*sha;
      //  return vec3(ao);
        return gcol+col*ifade;
      }

      vec3 effect(vec2 p, vec2 q) {
        float b   = beat(TIME);
        float z   = TIME;
        vec3 cam  = 1.2*vec3(1.0, 0.5, 0.0);
        float rt  = TAU*TIME/20.0;
        cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5);
        cam.xz   *= ROT(sin(rt)-0.75);
        vec3 la   = vec3(0.0);
        vec3 dcam = normalize(la - cam);
        vec3 ddcam= vec3(0.0);

        vec3 ro = cam;
        vec3 ww = normalize(dcam);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));
        vec3 vv = normalize(cross(ww,uu));
        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );

        vec3 col = vec3(0.0);
        if (dot(p,p) < 1.1) {
          col = render(ro, rd, b);
        } else {
        }

        const vec3 gcol0 = HSV2RGB(vec3(0.06, 0.5, 0.05));
        col += gcol0*b*dot(p, p);
        vec2 lp = p;
        lp += vec2(0.8, 0.7);
      //  lp *= mix(0.25, 0.2, b);
        lp.y -= 0.2*b;
        lp *= 0.25;
        vec4 lcol = impulseLogoCenter(lp, 1);
        col = mix(col, lcol.xyz, lcol.w);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, q);
        col *= smoothstep(effect_start  , effect_fadein, TIME)*smoothstep(effect_end, effect_fadeout, TIME);
        col = aces_approx(col);
        col = sRGB(col);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="vs_005_lines" type="x-shader/x-vertex">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float time;
      uniform vec2 resolution;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define PCOS(a)     (0.5+0.5*cos(a))

      const float bstart  = 0.136;
      const float bpm     = 130.0;
      const float bhz     = bpm/60.0;
      const float bperiod = 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }

      #if defined(SEGMENT0)
      #define FROM_CURVE curve3
      #define TO_CURVE   curve1
      #elif defined(SEGMENT1)
      #define FROM_CURVE curve3
      #define TO_CURVE   curve2
      #elif defined(SEGMENT2)
      #define FROM_CURVE curve4
      #define TO_CURVE   curve2
      #elif defined(SEGMENT3)
      #define FROM_CURVE curve4
      #define TO_CURVE   curve4
      #else
      #define FROM_CURVE curve4
      #define TO_CURVE   curve1
      #endif

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform mat4 mvp;

      in vec4 a_position;
      in vec3 a_normal;
      in vec2 a_texcoord;

      out vec4  v_position    ;
      out vec3  v_normal      ;
      out vec2  v_texcoord    ;
      flat out float v_ratio  ;
      flat out vec2  v_i2     ;


      vec2 path(float a) {
        return vec2(sin(a*0.2), sin(sqrt(0.5)*a));
      }


      vec2 dpath_(float a) {
        return vec2(cos(a), sqrt(0.5)*cos(sqrt(0.5)*a));
      }

      vec2 dpath(float a) {
        const float d = 0.05;
        return (path(a+d)-path(a-d))/(2.0*d);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      const vec2 dimn = 2.0*vec2(120.0, 20.0);
      vec2 i2(float i) {
        return vec2(mod(i, dimn.x)/dimn.x, floor(i/dimn.x)/dimn.y);
      }

      vec3 curve0(vec2 p) {
        p *= vec2(2.0, 2.0);
        float r = mix(1.0, 3.0, 0.5+0.5*cos(p.x*0.5));
        vec3 cp = vec3(
            r*cos(p.x)*sin(p.y)
          , r*sin(p.x)*sin(p.y)
          , r*cos(p.y)
          );
        return cp;
      }

      vec3 curve1(vec2 p) {
        p *= vec2(1.0, 4.0);
        float a = 1.0;
        float b = 2.5;
      //  p *= ROT(2.0*PI/6.0);
        vec3 cp = vec3(
            (b + a*cos(p.y))*cos(p.x)
          , (b + a*cos(p.y))*sin(p.x)
          , a*sin(p.y)
          );
        return cp;
      }

      vec3 curve2(vec2 p) {
        p *= vec2(4.0, 4.0);
        float a = 0.5;
        float b = 2.0+cos(0.25*p.x);
      //  p.x+=0.5*time;
        vec3 cp = vec3(
            (b + a*cos(p.y))*cos(p.x)
          , (b + a*cos(p.y))*sin(p.x)
          , a*sin(p.y)+2.0*sin(0.25*p.x)
          );
        return cp;
      }

      vec3 curve3(vec2 p) {
        p *= vec2(1.0, 4.0);
        float a = 0.25;
        float b = 0.75;
      //  p *= ROT(2.0*PI/6.0);
        float r = (b + a*cos(p.y));
        vec3 cp = vec3(
            r*cos(2.0*p.x)*(3.0+cos(3.0*p.x))
          , r*sin(2.0*p.x)*(3.0+cos(3.0*p.x))
          , r*sin(3.0*p.x)+PI*a*sin(p.y)
          );
        return cp;
      }

      vec3 curve4(vec2 p) {
        //http://virtualmathmuseum.org/Surface/kuen/kuen.html
        float a = 0.5*time+3.5;
        p += vec2(mix(-2.0*PI, 2.0*PI, PCOS(a)), mix(0.5*PI, 1.0*PI, PCOS(a*sqrt(0.5))));
        p *= vec2(8.0, 4.0);
        float u = p.x;
        float v = p.y;
        float id = 1.0/(cosh(v) * cosh(v) + u * u);
        vec3 cp = vec3(3.0, 3.0, 1.0)*vec3(
            2.0 * cosh(v) * (cos(u) + u * sin(u))*id
          , 2.0 * cosh(v) * (-u * cos(u) + sin(u))*id
          , v - (2.0 * sinh(v) * cosh(v))*id
          );
        return 1.5*cp;
      }

      float sqr(float x) {
        return x*x;
      }


      const vec2 dimu = vec2(-PI, PI);
      const vec2 dimv = dimu;

      const vec2 du = vec2(
          (dimu.y - dimu.x)/dimn.x
        , (dimv.y - dimv.x)/dimn.y
        );

      const vec2 dux = vec2(du.x, 0.0);
      const vec2 duy = vec2(0.0, du.y);

      vec2 uv(vec2 i2) {
        float u   = mix(dimu.x, dimu.y, i2.x);
        float v   = mix(dimv.x, dimv.y, i2.y);
        return vec2(u, v);
      }

      void main() {
        mat2 rxy = ROT(0.1*TIME);
        mat2 rxz = ROT(0.35*TIME);
        mat2 ryz = ROT(0.25*TIME);
        vec3 off =  vec3(0.0, 0.0, 4.0);

        float i   = float(gl_InstanceID);
        vec2  i2  = i2(floor(i/2.0));
        vec2 uv   = uv(i2);
        vec2 duv  = mod(i, 2.0) >= 1.0 ? dux : duy;
        vec3 p0_1 = FROM_CURVE(uv);
        vec3 p1_1 = FROM_CURVE(uv+duv);

        vec3 p0_2 = TO_CURVE(uv);
        vec3 p1_2 = TO_CURVE(uv+duv);

        const float offa = asin(0.5);
        float f   = smoothstep(-0.5, 0.5, sin(offa+TAU*(TIME-bstart)/(2.0*bperiod)));
        vec3 p0   = mix(p0_1, p0_2, f);
        vec3 p1   = mix(p1_1, p1_2, f);

        float bf = mix(1.0, 1.1, beat(TIME));
        p0.xy *= rxy;
        p0.xz *= rxz;
        p0.yz *= ryz;
        p0 *= bf;
        p0 += off;

        p1.xy *= rxy;
        p1.xz *= rxz;
        p1.yz *= ryz;
        p1 *= bf;
        p1 += off;

        const float lw = 0.175;

        vec3 c  = (p0+p1)*0.5;
        vec3 d  = p1-p0;
        float l = length(d);

        vec3 up = vec3(0.0, 0.0, -1.0);
        vec3 ww = d/l;
        vec3 uu = normalize(cross(ww, up));
        vec3 vv = cross(uu, ww);


        vec4 p = a_position;
        mat3 m = mat3(ww, uu, vv);
        p.xy *= vec2(0.5*l, lw/2.0);
      //  p.x *= 0.1;
        p.xyz *= transpose(m);
        p.xyz -= c;

        gl_Position = mvp * p;

        v_position  = p;
        v_normal    = a_normal;
        v_texcoord  = a_texcoord;
        v_ratio     = (1.0*l)/lw;
        v_i2        = i2;
      }
    </script>

    <script id="fs_005_lines" type="x-shader/x-fragment">
      precision highp float;

      uniform float time;
      uniform vec2 resolution;

      in vec4  v_position    ;
      in vec3  v_normal      ;
      in vec2  v_texcoord    ;
      flat in float v_ratio  ;
      flat in vec2  v_i2     ;

      out vec4 frag_color;

      #define PI      3.141592654
      #define PCOS(x) (0.5+0.5*cos(x))

      float segmentx(vec2 p, float w) {
        p = abs(p);
        float d0 = p.y;
        float d1 = length(p-vec2(w, 0.0));
        return p.x > w ? d1 : d0;
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      void main() {
        float originalZ = gl_FragCoord.z / gl_FragCoord.w;
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;

        float r = v_ratio;
        vec2  i2= v_i2;
        p.x *= r;

        vec3 col = vec3(0.0);
        float l = length(p);
        float h = i2.x+0.25*i2.y;
        float s = 0.25;
        vec3 gcol0 = hsv2rgb(vec3(h, 0.55, s));
        vec3 gcol1 = hsv2rgb(vec3(h, 0.9, s));
        float ds = segmentx(p, mix(0.0, 1.0, smoothstep(0.25, 1.0, cos(2.0*PI*i2.x+time)))*r); //PCOS(4.0*PI*i2.x+time)
        col += 4.0*gcol0*exp(-9.0*ds);
        col += 2.0*gcol1*exp(-6.0*ds);
        col *= 3.0/(originalZ);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_005_lines_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame;
      uniform sampler2D prev_pass;

      const float effect_start  = BTIME(20.0);
      const float effect_fadein = BTIME(20.0+0.25);
      const float effect_fadeout= BTIME(24.0-0.25);
      const float effect_end    = BTIME(24.0);


      #define PI          3.141592654
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      #define RESOLUTION  resolution

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }
      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      const mat2 brot = ROT(2.399);
      //  simplyfied version of Dave Hoskins blur
      vec3 dblur(vec2 q, float rad) {
        vec3 acc=vec3(0);
        vec2 pixel=vec2(.002*resolution.y/resolution.x,.002);
        vec2 angle=vec2(0,rad);
        rad=1.;
        const int iter = 50;
        for (int j=0; j<iter; ++j) {
          rad += 1./rad;
          angle*=brot;
          vec4 col=texture(prev_frame,q+pixel*(rad-1.)*angle);
          col.xyz*=col.xyz;
          acc+=col.xyz;
        }
        return acc*(1.0/float(iter));
      }


      void main(void) {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;

        vec4 pcol = texture(prev_pass,v_texcoord);
        vec3 col = pcol.xyz;
        vec3 bcol = vec3(0.0);
        vec2 pp = p;
        pp *= 0.9+0.075;
        vec2 pq = 0.5+0.5*pp;
        bcol = dblur(pq, 1.0);
        col = aces_approx(col);
        col += 0.55*bcol;
        col *= smoothstep(effect_start, effect_fadein, TIME)*smoothstep(effect_end, effect_fadeout, TIME);
        col = sRGB(col);

        frag_color = vec4(col, pcol.w);
      }
    </script>

    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
        "impulseAsset_logos",
        "impulseAsset_texts",
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        impulse_asset__logos : {
          image : (gl) => document.getElementById("impulse_asset__logos"),
        },
        impulse_asset__texts : {
          image : (gl) => document.getElementById("impulse_asset__texts"),
        },
      }

      // List all scenes, all scenes have a vertex shader (often shared)
      //  and a fragment shader
      //  It's possible to reuse and tweak fragment shaders by using defines
      //  Can also register extra uniforms
      //  Default uniforms always includes time and resolution
      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red"    ,
            },
          ],
        },
        start_scene : {
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_000_start",
            },
          ],
        },
        crew_glimglam_scene : {
          defines: ["GLIMGLAM"],
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_001_crew" ,
            },
          ],
        },
        crew_longshot_scene : {
          defines: ["LONGSHOT"],
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_001_crew" ,
            },
          ],
        },
        crew_jez_scene : {
          defines: ["JEZ"],
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_001_crew" ,
            },
          ],
        },
        crew_lance_scene : {
          defines: ["LANCE"],
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_001_crew" ,
            },
          ],
        },
        hexler_march_scene : {
          passes:[
            {
              vs: "vs_default"                ,
              fs: "fs_002_hexler_march"       ,
            },
            {
              vs: "vs_default"                ,
              fs: "fs_002_hexler_march_post"  ,
            },
          ],
        },
        monterey_scene : {
          passes:[
            {
              vs: "vs_default"        ,
              fs: "fs_003_monterey"   ,
            },
          ],
        },
        repeat_scene : {
          defines: ["REPEAT"],
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_001_crew" ,
            },
          ],
        },
        beats_scene : {
          passes:[
            {
              vs: "vs_default"    ,
              fs: "fs_004_beats"  ,
            },
          ],
        },
        lines_scene_0 : {
          defines: ["SEGMENT0"],
          passes:[
            {
              vs: "vs_005_lines"        ,
              fs: "fs_005_lines"        ,
            },
            {
              vs: "vs_default"          ,
              fs: "fs_005_lines_post"   ,
            },
          ],
        },
      };

      const bpm   = 130.0;
      const bhz   = bpm/60.0;
      const start = 0.136;
      function btime(b) {
        return (8.0*b/bhz+start);
      }

      const max_time_slots  = 64;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.start_scene           ,
        },
        {
          begin       :  1                                ,
          scene       :  all_scenes.crew_glimglam_scene   ,
        },
        {
          begin       :  3                                ,
          scene       :  all_scenes.crew_longshot_scene   ,
        },
        {
          begin       :  5                                ,
          scene       :  all_scenes.crew_jez_scene        ,
        },
        {
          begin       :  7                                ,
          scene       :  all_scenes.crew_lance_scene      ,
        },
        {
          begin       :  9                                ,
          scene       :  all_scenes.hexler_march_scene    ,
        },
        {
          begin       :  13                               ,
          scene       :  all_scenes.monterey_scene        ,
        },
        {
          begin       :  15                               ,
          scene       :  all_scenes.red_scene             ,
        },
        {
          begin       :  16                               ,
          scene       :  all_scenes.repeat_scene          ,
        },
        {
          begin       :  18                               ,
          scene       :  all_scenes.beats_scene           ,
        },
        {
          begin       :  20                               ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        const i = clamp(Math.floor((time-start)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function on_init_complete() {
        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
        gl.activeTexture(gl.TEXTURE4);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__logos.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_logos, 4);

        gl.activeTexture(gl.TEXTURE5);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__texts.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_texts, 5);
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.red_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="ultrasyd__new_things.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Summer 2022</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="impulse_asset__logos" src="impulse_asset__logos.png" style="display: none"/>
    <img id="impulse_asset__texts" src="impulse_asset__texts.png" style="display: none"/>
  </body>
</html>