<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Summer 2022</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec4 v_position;
      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red_pass" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_000_start" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;

      #define BTIME(n) ((n)*8.0/bhz+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      const float effect_start  = BTIME(9.0);
      const float effect_end    = BTIME(9.0+2.0*4.0);

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      vec2 shash2(vec2 p) {
        return -1.0+2.0*hash2(p);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      vec3 rgb2hsv(vec3 c) {
        const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      float dot2(vec2 p) {
        return dot(p, p);
      }

      float heart(vec2 p) {
        p.x = abs(p.x);

        if( p.y+p.x>1.0 )
          return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;
        return sqrt(min(dot2(p-vec2(0.00,1.00)),
                        dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(vec2 co) {
        return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
      }

      // License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA
      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec3 fade(vec2 p) {
        const float z = 10.0;
        p *= z;
      #define FADE0
      #if defined(FADE0)
        const float overlap = 0.0;
        const float hoff = 0.0;
        float f0 = tanh_approx(max(p.y+overlap, 0.0)+0.1)*step(overlap, p.y);
        float f1 = tanh_approx(max(-p.y+overlap, 0.0));
        vec3 lcol0 = hsv2rgb(vec3(hoff+0.58, 0.8, 2.0*(f0)));
        vec3 lcol1 = hsv2rgb(vec3(hoff+0.05 , 0.9 , 2.0*(f1)));
        vec3 lcol2 = hsv2rgb(vec3(hoff+0.025, 0.9, mix(0.01, 0.1, beat(TIME))))/(abs(p.y)*(abs(p.x*p.x)+0.2));
        vec3 col = vec3(0.0);
        col += lcol0;
        col += lcol1;
        col += lcol2;
        return col;
      #else
        return vec3(1.0);
      #endif


      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 effect0(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        vec2 lp = p;
        float bcount = beatCount(TIME);
        int i = int(mod(floor(bcount)+2.0, 3.0));
        switch(i) {
        case 0:
          lp *= 0.26;
          lp.x -= 0.0125;
          break;
        case 1:
          lp *= 0.17;
          lp.x -= 0.033;
          break;
        case 2:
          lp *= 0.23;
          lp.x -= 0.025;
          break;
        default:
          break;
        }
        vec4 lcol = impulseText(lp, i);
        float h = max(max(lcol.x, lcol.y), lcol.z);

        vec2 hp = p;
        hp.x *= mix(1.0, 0.9, beat(TIME+0.1*hp.y-0.15));
        hp.y -= -0.5;
        float d = heart(hp);
      //  d = abs(d) - 0.02;

        vec3 col = vec3(0.1);
        vec3 fcol = fade(p);
        col += HSV2RGB(vec3(0.9, 0.8, 0.3))*exp(-4.0*max(d-0.05, 0.0));
        col = mix(col, HSV2RGB(vec3(0.5, 0.0, 1.0)), smoothstep(aa, -aa, d-0.05));
        col = mix(col, HSV2RGB(vec3(0.9, 0.66, 1.0)), smoothstep(aa, -aa, d-0.025));
        col *= 1.0-tanh_approx(length(p));
        lcol.xyz = mix(lcol.xyz, fcol, sqrt(h));
        col = mix(col, 1.0*lcol.xyz, lcol.w);
        col += hsv2rgb(vec3(0.025, 0.5, 0.15))*beat(TIME)/dot2(p);
        col += 2.0*smoothstep(7.0, 7.5, bcount);
        return col;
      }


      float df(vec2 p) {
        const float hz = .25;
        p /= hz;
        vec2 hp0 = p;
        vec2 hn0 = hextile(hp0);
        vec2 hsn0= shash2(hn0);
        hp0 += 0.25*hsn0;
        float d0 = length(hp0) - mix(0.01, 0.2, abs(hsn0.y));

        vec2 hp1 = p;
        hp1 += vec2(1.0, sqrt(1.0/3.0));
        vec2 hn1 = hextile(hp1);
        vec2 hsn1= shash2(hn1);
        hp1 += 0.25*hsn1;
        float d1 = length(hp1) - mix(0.01, 0.2, abs(hsn1.y));

        float d = d0;
        d = min(d, d1);

        return -d*hz;
      }

      vec3 effect1(vec2 p) {
        float aa = 2.0/RESOLUTION.y;
        float bcount = beatCount(TIME);

        vec3 hsv = vec3(0.0);

        float fi0 = smoothstep(0.0, 1.0, bcount);
        float fi1 = smoothstep(1.0, 2.0, bcount);
        float fi2 = smoothstep(2.0, 3.0, bcount);
        float fo3 = smoothstep(4.0, 3.5, bcount);

        p *= ROT(mix(3.0*PI/12.0, PI/6.0, fi0));
        vec2 lp = p;
        const float lw = 0.75;
        float ln = mod1(lp.y, lw);

        float fp1 = 0.5*lp.x+lp.y;
        fp1 = fract(fp1/0.1);

        int i = 0;
        if (ln == 1.0) {
          i = 1;
          lp *= 0.2;
          lp.x += mix(-0.75, 0.0, fi1);
          hsv = vec3(0.0, 0.0, fi1*fi1);
        } else if (ln == 0.0) {
          i = 9;
          lp *= mix(0.1, 0.25, fi0);
          hsv = vec3(0.15, .0, 0.0);
        } else if (ln == -1.0) {
          i = 12;
          lp *= 0.29;
          lp.x += mix(0.75, 0.0, fi2);
          hsv = vec3(0.6, fi2, fi2*fi2);
        } else {
          return vec3(0.0);
        }

        vec3 flash = hsv2rgb(vec3(0.6, 0.75, 2.0))*smoothstep(0.5, 0.0, fract(bcount))/dot(p, p);

        vec3 col = vec3(0.);
        float d = df(p);
        col = hsv2rgb(hsv)*smoothstep(aa, -aa, d);

        vec4 lcol = impulseLogoCenter(lp, i);

        col = mix(col, lcol.xyz, lcol.w);
        col *= fi0;
        if (ln == 1.0 && floor(bcount) == 1.0) {
          col += flash;
        } else if (ln == 0.0 && floor(bcount) == 0.0) {
          col += flash;
        } else if (ln == -1.0 && floor(bcount) == 2.0) {
          col += flash;
        } else {
        }

        col *= fo3;

        return col;
      }


      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = vec3(0.0);
        float bcount = beatCount(TIME);
      //    col = effect0(p);
        if (bcount < 0.0) {
          col = vec3(0.0);
        } else if (bcount < 4.0 && bcount >= 0.0) {
          col = effect1(p);
        } else if (bcount < 7.0 && bcount >= 4.0) {
          col = effect0(p);
        } else {
          col = vec3(1.0);
        }
        col = aces_approx(col);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_001_crew" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D impulseAsset_logos;
      uniform sampler2D impulseAsset_texts;

      in vec4 v_position  ;
      in vec3 v_normal    ;
      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 0.136;
      const float bpm    = 130.0;
      const float bhz    = bpm/60.0;

      #define BTIME(n) ((n)*8.0/bhz+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        const float off = asin(0.5);
        return smoothstep(0.5, 1.0, sin(off+TAU*beatCount(tm)));
      }
      const float impulseAsset_count = 15.0;

      const float[15] impulseLogo_centerOffset = float[](
          0.2725
        , 0.245
        , 0.2295
        , 0.199
        , 0.167
        , 0.16
        , 0.165
        , 0.163
        , 0.1455
        , 0.141
        , 0.148
        , 0.141
        , 0.135
        , 0.103
        , -0.0075
        );

      vec4 impulseAsset(sampler2D sampler, vec2 p, int i) {
        const vec2 dim = vec2(1504.0, 3960.0);
        p.y *= dim.x/dim.y;
        p += vec2(0.5, 1.0-0.5/impulseAsset_count);
        p.y = 1.0-p.y;
        float t = step(p.y, 1.0/impulseAsset_count)*step(0.0/impulseAsset_count, p.y);
        p.y += (1.0/impulseAsset_count)*float(i);
        vec4 lcol = texture(sampler, p);
        lcol.w *= t;
        return lcol;
      }

      vec4 impulseLogo(vec2 p, int i) {
        return impulseAsset(impulseAsset_logos, p, i);
      }

      vec4 impulseLogoCenter(vec2 p, int i) {
        return impulseLogo(p - vec2(impulseLogo_centerOffset[i], 0.0), i);
      }

      vec4 impulseText(vec2 p, int i) {
        return impulseAsset(impulseAsset_texts, p, i);
      }
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      /*
      #define GLIMGLAM
      #define JEZ
      #define LANCE
      #define LONGSHOT
      */
      #define TIME        time
      #define RESOLUTION  resolution

      #define COLORBURN
      #define SKYDOME

      #define PI            3.141592654
      #define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))

      const int   bars     = 7;
      const mat2  trans    = ROT(PI/9.0);
      const float twist    = 1.0;
      const float dist     = 0.5;
      const float rounding = 0.125;

      const float raymarchFactor = 0.8;

      #define TAU         (2.0*PI)
      #define TIME        time
      #define RESOLUTION  resolution

      #define MAX_RAY_LENGTH  15.0
      #define MAX_RAY_MARCHES 70
      #define TOLERANCE       0.001
      #define NORM_OFF        0.005

      const float effect_start  = BTIME(1.0);
      const float effect_end    = BTIME(1.0+2.0*4.0);
      const float effect_period = BTIME(3.0)-BTIME(1.0);


      int g_hit     = 0;

      // -----------------------------------------------------------------------------
      // Licenses
      //  CC0     - https://creativecommons.org/share-your-work/public-domain/cc0/
      //  MIT     - https://mit-license.org/
      //  WTFPL   - https://en.wikipedia.org/wiki/WTFPL
      //  Unknown - No license identified, does not mean public domain
      // -----------------------------------------------------------------------------

      // Glimglam distance field font

      const float glimglam_corner0 = 0.02;
      const float glimglam_corner1 = 0.075;
      const float glimglam_topy    = 0.0475+glimglam_corner0*0.5;
      const float glimglam_smoother= 0.0125;

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      float corner(vec2 p) {
        vec2 v = min(p, vec2(0));
        return length(max(p, vec2(0))) + max(v.x, v.y);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float roundedBox(vec2 p, vec2 b, vec4 r) {
          r.xy = (p.x>0.0)?r.xy : r.zw;
          r.x  = (p.y>0.0)?r.x  : r.y;
          vec2 q = abs(p)-b+r.x;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_bar(vec2 p) {
        vec2 pbar = p;
        pbar.y -= glimglam_topy;
        return abs(pbar.y)-glimglam_corner0;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_a(vec2 p) {
        p.x = abs(p.x);
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));
        float dc = corner(p-vec2(0.045, -0.07))-glimglam_corner0;

        float d = db;
        d = max(d, -dc);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_c(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner1, glimglam_corner0));
        p.x = abs(p.x);
        float dc = corner(p-vec2(0.05, glimglam_topy))-glimglam_corner0;

        float d = db;
        d = max(d, -dc);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_e(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_g(vec2 p) {
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner0, glimglam_corner1, glimglam_corner1, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.045, -0.055)));
        dc = abs(dc) - glimglam_corner0;
        float dd = max(p.x-0.065, p.y-glimglam_topy);
        float d = db;
        d = max(d, -max(dc, dd));
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_h(vec2 p) {
        p.x = abs(p.x);
        float da = roundedBox(p-vec2(0.13, 0.0), vec2 (0.066, 0.166), vec4(glimglam_corner0));
        float db = roundedBox(p, vec2 (0.16, 0.05), vec4(glimglam_corner0));
        float d = da;
        d = min(d, db);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_i(vec2 p) {
        return roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_j(vec2 p) {
        p.x = -p.x;
        float db = roundedBox(p, vec2 (0.15, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.007, -0.055)))-glimglam_corner0;
        float d = db;
        d = max(d, -dc);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_l(vec2 p) {
        float db = roundedBox(p, vec2 (0.175, 0.166), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        float dc = corner(-(p-vec2(-0.027, -0.055)))-glimglam_corner0;
        float d = db;
        d = max(d, -dc);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_m(vec2 p) {
        float db = roundedBox(p, vec2 (0.255, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));
        p.x = abs(p.x);
        float dl = abs(p.x-0.095)-glimglam_corner0*2.0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -max(dl,dt));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_n(vec2 p) {
        float db = roundedBox(p, vec2 (0.19, 0.166), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner0));

        float dl = abs(p.x)-0.07;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -max(dl,dt));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_o(vec2 p) {
        const float sz = 0.05;
        float db = roundedBox(p, vec2(0.19, 0.166)-sz, vec4(glimglam_corner1, glimglam_corner1, glimglam_corner1, glimglam_corner1)-sz);
        db = abs(db)-sz;

        float d = db;

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_s(vec2 p) {
        p.x = -p.x;
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner1, glimglam_corner0, glimglam_corner0, glimglam_corner1));
        vec2 pc = p;
        pc.x *= sign(pc.y);
        pc.y = abs(pc.y);
        float cr = glimglam_corner1*1.3;
        pc -=vec2(-0.055, 0.20);
        pc.x = -pc.x;
        float dc = corner(pc+cr)-cr;
        vec2 pk = p;
        pk = -abs(pk);
        float dk = pk.x+glimglam_topy;
        dc = min(dk, dc);

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));
        d = pmax(d, dc, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_t(vec2 p) {
        float da = roundedBox(p-vec2(0.0, 0.12), vec2 (0.166, 0.05), vec4(glimglam_corner0));
        float db = roundedBox(p, vec2 (0.066, 0.166), vec4(glimglam_corner0));
        float d = da;
        d = min(d, db);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam_z(vec2 p) {
        p = -p.yx;
        float db = roundedBox(p, vec2 (0.166, 0.19), vec4(glimglam_corner0, glimglam_corner0, glimglam_corner0, glimglam_corner0));
        vec2 pc = p;
        pc.x *= sign(pc.y);
        pc.y = abs(pc.y);
        float cr = glimglam_corner1*1.3;
        pc -=vec2(-0.055, 0.20);
        pc.x = -pc.x;
        float dc = corner(pc+cr)-cr;
        vec2 pk = p;
        pk = -abs(pk);
        float dk = pk.x+glimglam_topy;
        dc = min(dk, dc);

        float dl = abs(p.x-(0.075-glimglam_corner0))-glimglam_corner0;
        float dt = p.y-glimglam_topy;

        float d = db;
        d = max(d, -pmax(dl,dt, glimglam_smoother));
        d = pmax(d, dc, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float glimglam(vec2 p) {
        float dbar = glimglam_bar(p);

        vec2 pg = p;
        pg.x -= -0.665;
        pg.x = -abs(pg.x);
        pg.x -= -0.7475;
        pg.x *= -sign(p.x+0.665);
        float dg = glimglam_g(pg);

        vec2 pi = p;
        pi.x -= -0.746;
        float di = glimglam_i(pi);

        vec2 pl = p;
        pl.x -= -0.27;
        pl.x = -abs(pl.x);
        pl.x -= -0.745;
        pl.x *= -sign(p.x+0.27);
        float dl = glimglam_l(pl);

        vec2 pa = p;
        pa.x -= 0.87;
        float da = glimglam_a(pa);

        vec2 pm = p;
        pm.x -= 0.475;
        pm.x = abs(pm.x);
        pm.x -= 0.875;
        pm.x *= sign(p.x-0.475);
        float dm = glimglam_m(pm);

        float d = 1E6;
        d = min(d, dg);
        d = min(d, dl);
        d = min(d, di);
        d = min(d, da);
        d = min(d, dm);
        d = pmax(d, -dbar, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float lance(vec2 p) {
        p.x -= -0.810;
        float dbar = glimglam_bar(p);

        vec2 pl = p;
        float dl = glimglam_l(pl);

        vec2 pa = p;
        pa.x -= 0.39;
        float da = glimglam_a(pa);

        vec2 pn = p;
        pn.x -= 0.795;
        float dn = glimglam_n(pn);

        vec2 pc = p;
        pc.x -= 1.2;
        float dc = glimglam_c(pc);

        vec2 pe = p;
        pe.x -= 1.605;
        float de = glimglam_e(pe);

        float d = 1E6;
        d = min(d, dl);
        d = min(d, da);
        d = min(d, dn);
        d = min(d, dc);
        d = min(d, de);
        d = pmax(d, -dbar, glimglam_smoother);

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float jez(vec2 p) {
        p.x -= -0.401;
        float dbar = glimglam_bar(p);

        vec2 pj = p;
        float dj = glimglam_j(pj);

        vec2 pe = p;
        pe.x -= 0.36;
        float de = glimglam_e(pe);

        vec2 pz = p;
        pz.x -= 0.76;
        float dz = glimglam_z(pz);

        float d = 1E6;
        d = min(d, dj);
        d = min(d, de);
        d = min(d, dz);
        d = pmax(d, -dbar, glimglam_smoother);
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float longshot(vec2 p) {
        p.x -= -1.385;
        float dbar = glimglam_bar(p);

        vec2 pl = p;
        float dl = glimglam_l(pl);

        vec2 po = p;
        po -= vec2(1.395, 0.0);
        po.x = abs(po.x);
        po -= vec2(1.0125, 0.0);
        float do_ = glimglam_o(po);

        vec2 pn = p;
        pn -= vec2(0.785, 0.0);
        float dn = glimglam_n(pn);

        vec2 pg = p;
        pg -= vec2(1.185, 0.0);
        float dg = glimglam_g(pg);

        vec2 ps = p;
        ps -= vec2(1.585, 0.0);
        float ds = glimglam_s(ps);

        vec2 ph = p;
        ph -= vec2(1.995, 0.0);
        float dh = glimglam_h(ph);

        vec2 pt = p;
        pt -= vec2(2.78, 0.0);
        float dt = glimglam_t(pt);

        float d = 1E6;
        d = min(d, dl);
        d = min(d, do_);
        d = min(d, dn);
        d = min(d, dg);
        d = min(d, ds);
        d = min(d, dh);
        d = min(d, dt);
        d = pmax(d, -dbar, glimglam_smoother);
        return d;
      }


      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(vec3 t) {
        return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      vec3 band_color(float ny) {
        vec3 hsv = vec3(0.0);
        float ramp = 1.0/abs(ny);
        if (abs(ny) < 4.0) {
          hsv = vec3(0.0, 0.0, 0.);
        } else if (ny > 0.0) {
          hsv = vec3(0.88, 2.5*ramp,0.8);
        } else {
          hsv = vec3(0.53, 4.0*ramp, 0.8);
        }

        return hsv2rgb(hsv);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b, vec4 r) {
        r.xy = (p.x>0.0)?r.xy : r.zw;
        r.x  = (p.y>0.0)?r.x  : r.y;
        vec2 q = abs(p)-b+r.x;
        return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
      }

      float fadeIn(float x) {
        return mix(-0.1, 1.0, smoothstep(-0.9, -0.5, -cos(-0.1*x+TAU*(TIME-effect_start)/effect_period)));
      }

      float df_bars1(vec3 p) {
        float tm = TIME+2.0;
        p.y += dist*sin(0.5*p.x+0.5*p.z+tm);
        vec2 bp = p.zy;

        float d = 1E6;

        float bs = 0.25*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);

        for (int i = 0; i < bars; ++i) {
          float ii = float(i);
          vec2 pp = bp;
          float a = -tm+0.5*ii;
          float b = ii+p.x-2.0*tm;
          pp.y += sin(a);
          mat2 rot = ROT(-PI/4.0*cos(a+twist*b));
          pp.x -= bsz.x*sqrt(2.0)*ii;
          pp *= rot;
          float dd = box(pp, bsz, brd);
          if (dd < d) {
            g_hit = i;
            d = dd;
          }
        }

        return d;
      }

      float df_bars2(vec3 p) {
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        vec2 p2 = p.yz;
        p2 *= ROT(TIME+p.x);
        vec2 s2 = sign(p2);
        p2 = abs(p2);
        p2 -= 0.4;
        g_hit = 3+int(s2.y+2.0*s2.x)-1;
        float bs = 0.35*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        return length(p2)-bs;
      }

      float df_bars3(vec3 p) {
        const float r = 0.25;
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        mat2 rot = ROT(TIME+p.x);
        vec2 p2 = p.yz;
        vec2 s2 = vec2(0.0);

        p2 *= rot;
        s2 += 2.0*sign(p2);
        p2 = abs(p2);
        p2 -= 2.0*r;

        p2 *= rot;
        s2 += 1.0*sign(p2);
        p2 = abs(p2);
        p2 -= 1.0*r;

        g_hit = 3+int(s2.y+2.0*s2.x)-1;

        float bs = (0.9*r)*fadeIn(p.x);
        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        float d0 = length(p2)-bs;
        float d1 = box(p2, bsz, brd);
        float d = d0;
        return d;
      }

      float df_bars4(vec3 p) {
        p.y += 0.5*dist*sin(-0.9*p.x+TIME);
        vec2 p2 = p.yz;
        p2 *= ROT(TIME+p.x);
        vec2 s2 = sign(p2);
        p2 = abs(p2);
        p2 -= 0.4;
        g_hit = 3+int(s2.y+2.0*s2.x)-1;

        float bs = 0.35*fadeIn(p.x);

        vec2 bsz = vec2(bs);
        vec4 brd = vec4(bs*rounding);
        return box(p2, bsz, brd);
      }

      float df(vec3 p) {
        p.xy *= trans;
      #if defined(GLIMGLAM)
        return df_bars2(p);
      #elif defined(LONGSHOT)
        return df_bars4(p);
      #elif defined(JEZ)
        return df_bars3(p);
      #elif defined(LANCE)
        return df_bars1(p);
      #else
        return length(p) - 0.5;
      #endif
      }

      float rayMarch(vec3 ro, vec3 rd, float ti) {
        float t = ti;
        int i = 0;
        vec2 dti = vec2(1e10,0.0);
        for (i = 0; i < MAX_RAY_MARCHES; i++) {
          float d = df(ro + rd*t);
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;
          if (d<dti.x) { dti=vec2(d,t); }
          t += raymarchFactor*d;
        }
        if(i==MAX_RAY_MARCHES) { t=dti.y; }
        return t;
      }

      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      const vec3 lightPos = vec3(2.0, 3.0, -5.0);
      const vec3 lightCol = vec3(HSV2RGB(vec3(0.53, 0.5, 1.0)));
      const vec3 overCol  = vec3(HSV2RGB(vec3(0.88, 0.25, 0.8)));

      vec3 skyColor(vec3 ro, vec3 rd) {
        vec3  ld    = normalize(lightPos - ro);
        float dif   = max(dot(ld, rd), 0.0);

        vec3  col   = vec3(0.0);

        if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) {
          col = 2.0*overCol*rd.y;
        }
        float rb = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;

        col += overCol*pow(clamp(1.0 - rb*0.5, 0.0, 1.0), 6.0);
        col += lightCol*pow(dif, 8.0);
        col += 4.0*lightCol*pow(dif, 40.0);
        return col;
      }

      vec3 effect(vec2 p) {
        vec3 ro = vec3(0.0, 0.0, -5.0);
        vec3 la = vec3(0.0, 0.0, 0.0);
        vec3 ww = normalize(la-ro);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));
        vec3 vv = normalize(cross(ww,uu));
        const float fov = 3.0;
        vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );

        g_hit = -1;
        float t = rayMarch(ro, rd, 3.0);
        int hit = g_hit;

        vec3 col = vec3(1.0);
        vec3 bcol = band_color(-4.0*float(hit-(bars-1)/2));
        bcol *= bcol;
        if (t < MAX_RAY_LENGTH) {
          vec3 p = ro + rd*t;
          vec3 n = normal(p);
          vec3 r = reflect(rd, n);
          vec3 ld= normalize(lightPos-p);

          float dif = max(dot(ld, n), 0.0);
          col = bcol*mix(0.5, 1.0, dif);
      #ifdef SKYDOME
          vec3 rs= skyColor(p, r);
          float fre = 1.0+dot(rd, n);
          fre *= fre;
          float rf  = mix(0.05, 1.0, fre);
          col += rf*rs;
      #else
          float spe = pow(max(dot(ld, r), 0.0), 30.0);
          col += spe;
      #endif
        }

        float aa = 2.0/RESOLUTION.y;
      #if defined(GLIMGLAM)
        float ld = glimglam(p);
      #elif defined(LONGSHOT)
        float ld = longshot(p);
      #elif defined(JEZ)
        float ld = jez(p);
      #elif defined(LANCE)
        float ld = lance(p);
      #else
        float ld = length(p) - 0.25;
      #endif

        col = mix(col, vec3(1.0), smoothstep(aa, -aa, ld));

        return col;
      }


      void main() {
        vec2 q = v_texcoord;
        vec2 p  = -1. + 2. * q;
        p.x     *= RESOLUTION.x/RESOLUTION.y;

        vec3 col  = vec3(0.0);
        col = effect(p);

      #if defined(COLORBURN)
        col -= vec3(0.2, 0.3, 0.2);
      #endif
        col = aces_approx(col);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
        "impulseAsset_logos",
        "impulseAsset_texts",
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        impulse_asset__logos : {
          image : (gl) => document.getElementById("impulse_asset__logos"),
        },
        impulse_asset__texts : {
          image : (gl) => document.getElementById("impulse_asset__texts"),
        },
      }

      // List all scenes, all scenes have a vertex shader (often shared)
      //  and a fragment shader
      //  It's possible to reuse and tweak fragment shaders by using defines
      //  Can also register extra uniforms
      //  Default uniforms always includes time and resolution
      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red_pass",
            }
          ]
        },
        start_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_000_start",
            }
          ]
        },
        crew_glimglam_scene : {
          defines: ["GLIMGLAM"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_001_crew",
            }
          ]
        },
        crew_longshot_scene : {
          defines: ["LONGSHOT"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_001_crew",
            }
          ]
        },
        crew_jez_scene : {
          defines: ["JEZ"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_001_crew",
            }
          ]
        },
        crew_lance_scene : {
          defines: ["LANCE"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_001_crew",
            }
          ]
        },
      };

      const bpm   = 130.0;
      const bhz   = bpm/60.0;
      const start = 0.136;
      function btime(b) {
        return (8.0*b/bhz+start);
      }

      const max_time_slots  = 64;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.start_scene           ,
        },
        {
          begin       :  1                                ,
          scene       :  all_scenes.crew_glimglam_scene   ,
        },
        {
          begin       :  3                                ,
          scene       :  all_scenes.crew_longshot_scene   ,
        },
        {
          begin       :  5                                ,
          scene       :  all_scenes.crew_jez_scene        ,
        },
        {
          begin       :  7                                ,
          scene       :  all_scenes.crew_lance_scene      ,
        },
        {
          begin       :  9                                ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        const i = clamp(Math.floor((time-start)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function on_init_complete() {
        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
        // Texture 0-3 is reserved
        gl.activeTexture(gl.TEXTURE4);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__logos.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_logos, 4);

        gl.activeTexture(gl.TEXTURE5);
        gl.bindTexture(gl.TEXTURE_2D, all_textures.impulse_asset__texts.texture);
        gl.uniform1i(pass.uniformLocations.impulseAsset_texts, 5);
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.red_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="ultrasyd__new_things.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Summer 2022</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="impulse_asset__logos" src="impulse_asset__logos.png" style="display: none"/>
    <img id="impulse_asset__texts" src="impulse_asset__texts.png" style="display: none"/>
  </body>
</html>