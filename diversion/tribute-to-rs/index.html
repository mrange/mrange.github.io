<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Our tribute to Red Sector</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_moody" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame    ;
      uniform sampler2D image  ;

      uniform sampler2D texts  ;

      const float TextHeight = 1.0/8.0;

      vec3 imageCol(vec3 col, vec2 p) {
        p *= 0.5;
        vec2 ap = abs(p);
        vec2 sp = step(ap, vec2(0.5));
        p += 0.5;
        p.y = 1.0-p.y;
        vec4 tcol = texture(image, p);
        col = mix(col, tcol.xyz*tcol.xyz, tcol.w*sp.x*sp.y);
        return col;
      }


      float textsT(vec2 p, float iz, float n) {
        p *= iz;
        p *= 0.5;
        if (abs(p.y) > 0.5*TextHeight) {
          return 0.0;
        }
        p += 0.5;
        p.y -= TextHeight*0.5;
        p.y -= (n-4.0)*TextHeight;
        p.y = 1.0-p.y;
        vec4 tcol = texture(texts, p);

        float off = 0.033*iz;
        return smoothstep(0.75-off, 0.75+off, tcol.x);
      }

      const mat2 brot = ROT(2.399);
      //  simplyfied version of Dave Hoskins blur
      vec3 dblur(vec2 q,float rad) {
        vec3 acc=vec3(0);
        const float m = 0.002;
        vec2 pixel=vec2(m*resolution.y/resolution.x,m);
        vec2 angle=vec2(0,rad);
        rad=1.;
        const int iter = 24;
        for (int j=0; j<iter; ++j) {
          rad += 1./rad;
          angle*=brot;
          vec4 col=texture(prev_frame,q+pixel*(rad-1.)*angle);
          col.xyz*=col.xyz;
          acc+=col.xyz;
        }
        return acc*(1.0/float(iter));
      }

      void main(void) {
        const float botz  = 2.0;
        const float top   = (1.0-4.0*TextHeight);
        const float bot   = (-1.0+2.0*botz*TextHeight*1.25);
        const float mid   = (top+bot)*0.5;

        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec2 pp = p;
        float r = RESOLUTION.x/RESOLUTION.y;
        p.x *= r;
        vec2 zp = 0.95*p;
        zp.x /= r;
        vec2 zq = 0.5+0.5*zp;
        vec3 col = vec3(0.0);
        col = imageCol(col, p);
        float ftm = TAU*TIME*0.5;
        float flash = smoothstep(-0.5, 0.5, sin(ftm+p.x)*sin(sqrt(0.5)*ftm+p.y)*sin(sqrt(3.0)*ftm+p.x+p.y));
        col = min(col, mix(0.33, 1.0, flash*step(mid, p.y)));
        vec2 sp = 40.0*p+TAU*TIME/5.0;
        float rad = 2.0*mix(0.5, 1.5, 0.5+0.5*sin(sp.x)*sin(sp.y));

        float fade = smoothstep(top*1.1, top, p.y)*smoothstep(1.125*bot, bot, p.y);

        vec3 bcol = dblur(zq, rad);
        bcol = tanh(2.0*bcol);
        if (p.y > mid) {
          bcol *= bcol.z;
          bcol *= 2.0/3.0*vec3(0.25, 0.5, 1.0);
        } else {
          bcol *= bcol.x;
          bcol *= 2.0/3.0*vec3(1.0, 0.75, 0.5);
        }
        bcol *= fade;
        col += bcol;
        col *= smoothstep(1.5, 0.5, length(pp));

        vec2 p0 = p;
        p0.y -= -1.0+1.25*TextHeight*botz;
        float t0 = textsT(p0, 1.0/botz, 1.0);

        vec2 p1 = p;
        p1.y -= 1.0-TextHeight;
        float t1 = textsT(p1, 1.0, 2.0);

        vec2 p2 = p;
        p2.y -= 1.0-TextHeight*3.0;
        float t2 = textsT(p2, 1.0, 3.0);

        float fi = smoothstep(6.0, 14.0, TIME+4.0*p.y-4.0-2.0*p.x*p.x);
        const vec3 lcol = vec3(2.0/3.0);

        col = mix(col, lcol, fi*t0);
        col = mix(col, lcol, fi*t1);
        col = mix(col, lcol, fi*t2);
        col *= smoothstep(bstart, bstart-1.0, TIME);
        col *= smoothstep(0.0, 6.0, TIME);
        col = sqrt(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_intro" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_frame  ;
      uniform sampler2D almost_mono ;
      uniform sampler2D red_sector  ;
      uniform sampler2D texts       ;

      const float TextHeight = 1.0/8.0;

      float textsT(vec2 p, float iz, float n) {
        p *= iz;
        p *= 0.5;
        if (abs(p.y) > 0.5*TextHeight) {
          return (0.0);
        }
        p += 0.5;
        p.y -= TextHeight*0.5;
        p.y -= (n-4.0)*TextHeight;
        p.y = 1.0-p.y;
        vec4 tcol = texture(texts, p);

        float off = 0.033*iz;
        return smoothstep(0.75-off, 0.75+off, tcol.x);
      }

      vec3 clampedCol(sampler2D sampler, vec3 col, vec2 p) {
        p *= 0.5;
        vec2 ap = abs(p);
        vec2 sp = step(ap, vec2(0.5));
        p += 0.5;
        p.y = 1.0-p.y;
        vec4 tcol = texture(sampler, p);
        col = mix(col, tcol.xyz*tcol.xyz, tcol.w*sp.x*sp.y);
        return col;
      }

      const float btime0    = BTIME(0.0);
      const float btime1    = BTIME(1.0);
      const float btime1_nxt= BTIME(1.5);
      const float btime1_fo = BTIME(1.75);
      const float btime2    = BTIME(2.0);
      const float btime2_fi = BTIME(2.5);
      const float btime3    = BTIME(3.0);

      vec3 effect0(vec3 col, vec2 p, float ratio) {
        vec2 p0 = p;
        float t0 = textsT(p0, 1.0/ratio, mix(0.0, 4.0, step(btime1_nxt, TIME)));
        vec2 p1 = p;
        p1 /= ratio+0.0125*(TIME-btime0);
        p1.y -= -0.3-0.005*(TIME-btime0);
        col = clampedCol(almost_mono, col, p1);
        col = mix(col, vec3(1.0), t0*step(btime1, TIME));

        vec2 p2 = p;
        p2.y -= -0.05;
        float d3 = abs(p2.y)+abs(p2.x*0.125);
        const vec3 gcol = vec3(1.0, 0.71, 0.5).xzy;
        float gf = 0.0;
        gf += step(btime1, TIME)*smoothstep(btime1+bperiod/4.0, btime1,TIME);
        gf += step(btime1_nxt, TIME)*smoothstep(btime1_nxt+bperiod/4.0, btime1_nxt,TIME);
        col += (gcol/3.0)/max(d3, 0.025)*gf;
        vec2 p4 = p;
        p4.y -= 0.85;
        col *= smoothstep(btime0, btime1, TIME-length(p4));
        col *= smoothstep(btime2, btime1_fo, TIME);
        return col;
      }

      // License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA
      vec2 hextile(inout vec2 p) {
        // See Art of Code: Hexagonal Tiling Explained!
        // https://www.youtube.com/watch?v=VmrIDyYiJBA
        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        n -= vec2(0.5);
        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)*0.5;
      }

      vec3 effect1(vec3 col, vec2 p, float ratio) {
        float aa = 4.0/RESOLUTION.y;
        vec2 p0 = p;
        float fade = smoothstep(btime2, btime2_fi, TIME-0.5*length(p-vec2(0.0, 1.0)));
        float z0 = mix(0.5, aa, sqrt(fade));
        p0 /= z0;
        vec2 n0 = hextile(p0);
        vec2 c0 = n0*z0*vec2(-1.0, -sqrt(3.0));
        float d0 = length(p-c0) - 0.25*z0;
        float d1 = length(p0) - 0.125;
        d1 *= z0;
        vec2 p1 = p;
        col = mix(vec3(0.0), clampedCol(red_sector, col, c0), fade);
        return col;
      }

      void main(void) {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        float ratio = RESOLUTION.x/RESOLUTION.y;
        p.x *= ratio;

        vec3 col = vec3(0.0);
        if (TIME > btime2) {
          col = effect1(col, p, ratio);
        } else {
          col = effect0(col, p, ratio);
        }
        col = sqrt(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_beatbox" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------


      #define TOLERANCE       0.0001
      #define MAX_RAY_LENGTH  24.0
      #define MAX_RAY_MARCHES 70
      #define NORM_OFF        0.001

      #define DF0
      //#define FLAIR
      //#define BOXY

      const float Nop   = 0.0;
      const float Drum  = 1.0;
      const float Hey   = -1.0;

      const float[] track4 = float[64*3]
      (
        Drum  // 0
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop   // 8
      , Nop
      , Drum
      , Nop
      , Nop
      , Nop
      , Drum
      , Nop
      , Drum  // 16
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop // 24
      , Nop
      , Drum
      , Nop
      , Nop
      , Nop
      , Drum
      , Nop
      , Nop // 32
      , Nop
      , Drum
      , Nop
      , Drum
      , Nop
      , Nop
      , Nop
      , Nop // 40
      , Nop
      , Drum
      , Nop
      , Nop
      , Nop
      , Drum
      , Nop
      , Drum // 48
      , Nop
      , Nop
      , Nop
      , Nop
      , Nop
      , Drum
      , Nop
      , Nop // 56
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Drum // 0 - break
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 8
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Drum // 16
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 24
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Nop // 32
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 40
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Drum // 48
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Drum
      , Drum
      , Nop // 56
      , Drum
      , Drum
      , Nop
      , Hey
      , Nop
      , Hey
      , Nop
      , Drum // 0 -break
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 8
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Drum // 16
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 24
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Nop // 32
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      , Nop // 40
      , Nop
      , Drum
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Drum // 48
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Drum
      , Nop
      , Drum // 56
      , Nop
      , Nop
      , Nop
      , Hey
      , Nop
      , Nop
      , Nop
      );

      const int[] track4_twist = int[64*3]
      (
        0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0   // 8
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0  // 16
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0 // 24
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0 // 32
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0 // 40
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0 // 48
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0
      , 0 // 56
      , 0
      , 0
      , 0
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 0 - break
      , 1
      , 1
      , 1
      , 0 // Hey
      , 0
      , 0
      , 0
      , 0 // 8
      , 0
      , 0
      , 0
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 16
      , 1
      , 1
      , 1
      , 0 // Hey
      , 0
      , 0
      , 0
      , 0 // 24
      , 0
      , 0
      , 0
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 32
      , 1
      , 1
      , 1
      , 2 // Hey
      , 2
      , 2
      , 2
      , 2 // 40
      , 2
      , 2
      , 2
      , 0 // Hey
      , 0
      , 0
      , 0
      , 0 // 48
      , 0
      , 0
      , 0
      , 2 // Hey
      , 2
      , 2
      , 2
      , 2 // 56
      , 2
      , 2
      , 2
      , 1 // Hey
      , 1 //
      , 0 // Hey
      , 0
      , 0 // 0 -break
      , 0
      , 0
      , 0
      , 2 // Hey
      , 2
      , 2
      , 2
      , 2 // 8
      , 2
      , 2
      , 2
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 16
      , 1
      , 1
      , 1
      , 0 // Hey
      , 0
      , 0
      , 0
      , 0 // 24
      , 0
      , 0
      , 0
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 32
      , 1
      , 1
      , 1
      , 2 // Hey
      , 2
      , 2
      , 2
      , 2 // 40
      , 2
      , 2
      , 2
      , 0 // Hey
      , 0
      , 0
      , 0
      , 0 // 48
      , 0
      , 0
      , 0
      , 1 // Hey
      , 1
      , 1
      , 1
      , 1 // 56
      , 1
      , 1
      , 1
      , 0 // Hey
      , 0
      , 0
      , 0
      );

      const float btime3    = BTIME(3.0);
      const float btime_fi  = BTIME(3.0+0.125);
      const float btime_fo  = BTIME(9.0-0.125);
      const float btime9    = BTIME(9.0);

      float funkyBeat(float time, out int from, out int to, out float anim) {
        const float diff   = btime9-btime3;
        const float len    = float(track4.length());
        const float beat   = diff/len;
        float tm = time-btime3;
        float lt = mod(tm, beat)/beat;
        float bt = 1.0-lt;
        float idx = floor(tm/beat);
        anim = lt;
        if (idx >= 0.0 && idx < len) {
          int i = int(idx);
          float effect = track4[i];
          from = track4_twist[max(i-1, 0)];
          to = track4_twist[i];
          return effect*(bt);
        } else {
          return Nop;
        }
      }

      float g_funkyBeat0;
      float g_funkyBeat1;

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      const float hoff      = 0.;
      const vec3 skyCol     = HSV2RGB(vec3(hoff+0.75, 0.70, 0.25));
      const vec3 glowCol0   = HSV2RGB(vec3(hoff+0.025, 0.85, 0.00125));
      const vec3 glowCol1   = HSV2RGB(vec3(hoff+0.95, 0.85, 0.05));
      const vec3 glowCol2   = HSV2RGB(vec3(hoff+0.95, 0.70, 8.0));
      const vec3 sunCol1    = HSV2RGB(vec3(hoff+0.55, 0.50, 0.5));
      const vec3 sunCol2    = HSV2RGB(vec3(hoff+0.95, 0.75, 25.0));
      const vec3 diffCol    = HSV2RGB(vec3(hoff+0.40, 0.75, 0.125));
      const vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      #define ROTY(a)               \
        mat3(                       \
          +cos(a) , 0.0 , +sin(a)   \
        , 0.0     , 1.0 , 0.0       \
        , -sin(a) , 0.0 , +cos(a)   \
        )

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      #define ROTZ(a)               \
        mat3(                       \
          +cos(a) , +sin(a) , 0.0   \
        , -sin(a) , +cos(a) , 0.0   \
        , 0.0     , 0.0     , 1.0   \
        )

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      #define ROTX(a)               \
        mat3(                       \
          1.0 , 0.0     , 0.0       \
        , 0.0 , +cos(a) , +sin(a)   \
        , 0.0 , -sin(a) , +cos(a)   \
        )


      float torus( vec3 p, vec2 t ) {
        vec2 q = vec2(length(p.xz)-t.x,p.y);
        return length(q)-t.y;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float ref(inout vec3 p, vec3 r) {
        float d = dot(p, r);
        p -= r*min(0.0, d)*2.0;
        return d < 0.0 ? 0.0 : 1.0;
      }

      #define SCA(a)      vec2(sin(a), cos(a))

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/
      float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      float box(vec3 p, vec3 b) {
        vec3 q = abs(p) - b;
        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
      }

      float boxf(vec3 p, vec3 b, float e) {
             p = abs(p  )-b;
        vec3 q = abs(p+e)-e;
        return min(min(
            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      vec3 pmin(vec3 a, vec3 b, float k) {
        vec3 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0-h);
      }


      vec3 pabs(vec3 a, float k) {
        return -pmin(a, -a, k);
      }

      float sphere(vec3 p, float r) {
        return length(p) - r;
      }

      float sphere4(vec3 p, float r) {
        p *= p;
        return pow(dot(p, p), 0.25) - r;
      }

      float sphere8(vec3 p, float r) {
        p *= p;
        p *= p;
        return pow(dot(p, p), 0.125) - r;
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec3 mod3(inout vec3 p, vec3 size) {
        vec3 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      float bbox(vec3 p, vec3 b) {
        vec3 q = abs(p) - b;
        return (max(q.x,max(q.y,q.z)));
      }

      float df0(vec3 p, out float ogd) {
        float sz = mix(3.0, 3.25, g_funkyBeat0*g_funkyBeat0);
        vec3 p0 = p;
        float d0 = box(p0, vec3(sz));
        vec3 p1 = p;
        float d1 = boxf(p1, vec3(sz+0.01), 0.)-0.01;

        float d = d0;
        d = min(d, d1);

        ogd = d1;

        return d;
      }

      float df1(vec3 p, out float ogd) {
        float sz = mix(3.0, 3.25, g_funkyBeat0*g_funkyBeat0);
      #if defined(BOXY)
        float d0 = box(p, vec3(sz));
        float d1 = boxf(p, vec3(sz+0.01), 0.0)-0.01;
      #else
        float d0 = sphere8(p, (sz));
      #endif

        float d3 = length(p)-(sz-0.12);

        float d = d0;
        d = pmax(d, -d3, 1.0);
        d = min(d, d3);
      #if defined(BOXY)
        d = min(d, d1);
      #endif

        float d2 = max(max(d, d3-0.4), -(d3-0.25));

        float gd = d2;
      #if defined(BOXY)
        gd = min(gd, d1);
      #endif
        gd = abs(gd);

        ogd = gd;

        return d;

      }

      float df2(vec3 p, out float ogd) {
        float sz = mix(3.0, 3.25, g_funkyBeat0*g_funkyBeat0);
      #if defined(BOXY)
        float d0 = box(p, vec3(sz));
        float d1 = boxf(p, vec3(sz+0.01), 0.0)-0.01;
      #else
        float d0 = sphere8(p, (sz));
      #endif
        vec3 p2 = p;
      #if defined(FLAIR)
        const float bsz = 6.0/(3.-1.0);
      #else
        const float bsz = 6.0/(24.0-1.0);
      #endif
        mod3(p2, vec3(bsz));
        float d2 = box(p2, vec3(0.80*bsz*0.5))-0.15*bsz*0.5;

        float d4 = sphere4(p, sz+mix(-0.005, 0.005, sqrt(g_funkyBeat0)));

        float d = d2;
        d = max(d, d0);
      #if defined(BOXY)
        d = min(d, d1);
      #endif
        d = min(d, d4);

        float gd = d4;
      #if defined(BOXY)
        gd = min(gd, d1);
      #endif
        ogd = gd;

        return d;

      }

      int g_from  ;
      int g_to    ;
      float g_anim;
      float g_gd;

      mat3 g_rot;

      float df(vec3 p, out float ogd) {
        float ogd0;
        float d0 = df0(p, ogd0);
        float ogd1;
        float d1 = df1(p, ogd1);
        ogd = ogd1;
        float ogd2;
        float d2 = df2(p, ogd2);

        float dfrom;
        float dto;
        float ogdfrom;
        float ogdto;

        int from = g_from;
        int to   = g_to;

        float anim = g_anim;

        if (from == 0) {
          dfrom = d0;
          ogdfrom = ogd0;
        } else if (from == 1) {
          dfrom = d1;
          ogdfrom = ogd1;
        } else {
          dfrom = d2;
          ogdfrom = ogd2;
        }

        if (to == 0) {
          dto = d0;
          ogdto = ogd0;
        } else if (to == 1) {
          dto = d1;
          ogdto = ogd1;
        } else {
          dto = d2;
          ogdto = ogd2;
        }

        ogd = mix(ogdfrom, ogdto, g_anim);
        return mix(dfrom, dto, g_anim);
      }

      float df(vec3 p) {
        float ogd;
        p *= g_rot;
        float d = df(p, ogd);
        g_gd = min(g_gd, ogd);
        return d;

      }
      vec3 normal(vec3 pos) {
        vec2  eps = vec2(NORM_OFF,0.0);
        vec3 nor;
        nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);
        nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);
        nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);
        return normalize(nor);
      }

      float rayMarch(vec3 ro, vec3 rd, out int iter) {
        float t = 0.0;
        const float tol = TOLERANCE;
        vec2 dti = vec2(1e10,0.0);
        int i = 0;
        for (i = 0; i < MAX_RAY_MARCHES; ++i) {
          float d = df(ro + rd*t);
          if (d<dti.x) { dti=vec2(d,t); }
          if (d < TOLERANCE || t > MAX_RAY_LENGTH) {
            break;
          }
          t += d;
        }
      #if defined(BACKSTEP)
        if(i==MAX_RAY_MARCHES) { t=dti.y; };
      #endif
        iter = i;
        return t;
      }

      vec3 render0(vec3 ro, vec3 rd) {
        vec3 col = vec3(0.0);
        float sd = max(dot(sunDir1, rd), 0.0);
        float sf = 1.0001-sd;

        float funkyBeat0 = mix(1.0, 8.0, g_funkyBeat0);
        float funkyBeat1 = mix(1.0, 2.0, g_funkyBeat1);
        float funkyBeat2 = mix(1.0, 1.25, g_funkyBeat1);
        col += funkyBeat0*clamp(vec3(1.0/abs(rd.y))*glowCol0, 0.0, 1.0);

        col += 0.75*skyCol*pow((1.0-abs(rd.y)), 8.0);
        col += 2.0*sunCol1*pow(sd, 100.0);
        col += sunCol2*pow(sd, 800.0);

        float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -6.0));

        if (tp1 > 0.0) {
          vec3 pos  = ro + tp1*rd;
          vec2 pp = pos.xz;
          float db = box(pp, funkyBeat2*vec2(5.0, 9.0))-3.0;
          vec3 pcol = vec3(0.0);
          pcol += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);
          pcol += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));
          pcol += 0.25*sqrt(skyCol)*max(-db, 0.0);
          col += pcol*funkyBeat1;
        }

        return clamp(col, 0.0, 10.0);
      }

      vec3 render1(vec3 ro, vec3 rd, vec2 sp) {

        int iter;
        g_gd = 1E3;
        float t = rayMarch(ro, rd, iter);
        vec3 ggcol = (glowCol1)*inversesqrt(max(g_gd, 0.00025));
        vec3 col = render0(ro, rd);

        vec3 p = ro+rd*t;
        vec3 n = normal(p);
        vec3 r = reflect(rd, n);
        float fre0 = 1.0+dot(rd, n);
        float fre = fre0;
        fre *= fre;
        float dif = dot(sunDir1, n);

        float ao = 1.0-float(iter)/float(MAX_RAY_MARCHES);
        float fo = mix(0.2, 1.0, ao);
        if (t < MAX_RAY_LENGTH) {
          col = vec3(0.0);
          col += sunCol1*dif*dif*diffCol*fo*1.0;
          col += mix(0.33, 1.0, fre)*render0(p, r)*fo*0.75;
        }

      //  col *= smoothstep(0.1, -0.1, cos((TAU*TIME-2.0*sp.y)/30.0));
      //  col *= 0.0;
        col += clamp(ggcol, 0.0, 4.0);
        return col;
      }
      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotX(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          1.0 , 0.0 , 0.0
        , 0.0 , +c  , +s
        , 0.0 , -s  , +c
        );
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotY(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          +c  , 0.0 , +s
        , 0.0 , 1.0 , 0.0
        , -s  , 0.0 , +c
        );
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      mat3 rotZ(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
          +c  , +s  , 0.0
        , -s  , +c  , 0.0
        , 0.0 , 0.0 , 1.0
        );
      }

      float bounce(float t, float dy, float dropOff) {
        const float g = 10.0;
        float p0 = 2.0*dy/g;

        t += p0/2.0;

        float ldo = log(dropOff);
        float yy = 1.0 - (1.0 - dropOff) * t / p0;


        if (yy > 1e-4) {
          float n  = floor(log(yy) / ldo);
          float dn = pow(dropOff, n);

          float yyy = dy * dn;
          t -= p0 * (1.0 - dn) / (1.0 - dropOff);

          return -0.5*g*t*t + yyy*t;

        }
        else {
            return 0.0;
        }
      }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }


      vec3 effect(vec2 p, vec2 pp) {
        int from;
        int to;
        float anim;
        float funkyBeat =funkyBeat(TIME, from, to, anim);
        g_funkyBeat0 = max(0.0, funkyBeat);
        g_funkyBeat1 = max(0.0, -funkyBeat);
        g_from = from;
        g_to   = to;
        g_anim = anim;
        float tm  = TIME+10.0;
        g_rot = rotX(0.333*tm)*rotZ(0.5*tm)*rotY(0.23*tm);

        vec3 ro = 1.75*vec3(5.0, 1., 0.);
        ro.xz *= ROT(-0.1*tm);
        const vec3 la = vec3(0.0, 0.0, 0.0);
        const vec3 up = normalize(vec3(0.0, 1.0, 0.0));

        vec3 ww = normalize(la - ro);
        vec3 uu = normalize(cross(up, ww ));
        vec3 vv = (cross(ww,uu));
        const float fov = tan(TAU/6.);
        vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);

        vec3 col = render1(ro, rd, p);

        col -= 0.05*length(pp);

        float gd = abs(p.y)+0.25*p.x*p.x;
        col += smoothstep(btime_fi, btime3, TIME)*glowCol2/gd;
        col *= smoothstep(btime9, btime_fo, TIME);
        col = aces_approx(col);

        col = max(col,0.0);
        col = sqrt(col);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        vec2 pp = p;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = vec3(0.0);
        col = effect(p, pp);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_dawn" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------


      #define LAYERS            5.0

      #define PI                3.141592654
      #define TAU               (2.0*PI)
      #define TIME              time
      #define RESOLUTION        resolution

      uniform sampler2D texts  ;
      const float TextHeight = 1.0/8.0;

      float textsT(vec2 p, float iz, float o, float b, float n) {
        p *= iz;
        p *= 0.5;
        if (abs(p.y) > 0.5*TextHeight) {
          return 0.0;
        }
        p += 0.5;
        p.y -= TextHeight*0.5;
        p.y -= (n-4.0)*TextHeight;
        p.y = 1.0-p.y;
        vec4 tcol = texture(texts, p);

        float off = (0.033+b)*iz;
        return smoothstep(o-off, o+off, tcol.x);
      }



      const float btime9 = BTIME(9.0);
      const float btime11 = BTIME(11.0);
      const float btime_fo = BTIME(13.0-0.125);
      const float btime13 = BTIME(13.0);

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      vec2 shash2(vec2 p) {
        return -1.0+2.0*hash2(p);
      }

      vec3 toSpherical(vec3 p) {
        float r   = length(p);
        float t   = acos(p.z/r);
        float ph  = atan(p.y, p.x);
        return vec3(r, t, ph);
      }


      // License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2
      vec3 blackbody(float Temp) {
        vec3 col = vec3(255.);
        col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;
        col.y = 100.04 * log(Temp) - 623.6;
        if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;
        col.z = 194.18 * log(Temp) - 1448.6;
        col = clamp(col, 0., 255.)/255.;
        if (Temp < 1000.) col *= Temp/1000.;
        col *= col;
        return col;
      }


      // License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr
      float noise(vec2 p) {
        // Found at https://www.shadertoy.com/view/sdlXWX
        // Which then redirected to IQ shader
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f*f*(3.-2.*f);

        float n =
               mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)),
                         dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),
                    mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)),
                         dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);

        return 2.0*n;
      }

      float fbm(vec2 p, float o, float s, int iters) {
        p *= s;
        p += o;

        const float aa = 0.5;
        const mat2 pp = 2.04*ROT(1.0);

        float h = 0.0;
        float a = 1.0;
        float d = 0.0;
        for (int i = 0; i < iters; ++i) {
          d += a;
          h += a*noise(p);
          p += vec2(10.7, 8.3);
          p *= pp;
          a *= aa;
        }
        h /= d;

        return h;
      }

      float height(vec2 p) {
        float h = fbm(p, 0.0, 5.0, 5);
        h *= 0.3;
        h += 0.0;
        return (h);
      }

      vec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {
        vec3 oc = ro - sph.xyz;
        float b = dot( oc, rd );
        float c = dot( oc, oc ) - sph.w*sph.w;
        float h = b*b - c;
        if( h<0.0 ) return vec2(-1.0);
        h = sqrt( h );
        return vec2(-b - h, -b + h);
      }

      vec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {
        vec3 col = vec3(0.0);

        const float m = LAYERS;
        hh = tanh_approx(20.0*hh);

        for (float i = 0.0; i < m; ++i) {
          vec2 pp = sp+0.5*i;
          float s = i/(m-1.0);
          vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);
          vec2 np = mod2(pp, dim);
          vec2 h = hash2(np+123.4+i);
          vec2 o = -1.0+2.0*h;
          float y = sin(sp.x);
          pp += o*dim*0.5;
          pp.y *= y;
          float l = length(pp);

          float h0 = fract(h.x);
          float h1 = fract(h0*1377.0);
          float h2 = fract(h0*1887.0);
          float h3 = fract(h0*2997.0);
          float h4 = fract(h0*8997.0);

          vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(4000.0, 30000.0, h1*h1));

          const float a = 0.1;
          float b = mix(0.0, 1.0, smoothstep(-0.9, 1.0, sin(h4*TAU+TAU*(TIME)*0.25)));
          vec3 ccol = col + b*exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;
          col = h3 < y ? ccol : col;
        }

        return col;
      }

      vec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {
        vec2 ssp = toSpherical(rd.zyx).yz;
        float ld = max(dot(normalize(lp-ro), rd),0.0);
        float y = -0.5+sp.x/PI;
        y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));
        vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));
        float fi = smoothstep(btime11, btime13, TIME);
        float ci = pow(ld, 10.0)*2.0*exp(-25.0*(y-0.2*fi*fi));
        vec3 yellow = blackbody(2000.0)*ci;
        float ci2 = pow(ld, 4.0)*2.0*exp(-mix(1.0, 2.0, smoothstep(-1.0, 0., sin(TAU*24.0*(abs(ssp.y)+0.25*(sp.y))))));
        vec3 spokes = 2.0*vec3(1.0, 0., 0.25)*ci2;
        cf = ci;
        return blue+(yellow+spokes)*fi;
      }

      vec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {
        vec2 mi = raySphere(ro, rd, md);

        vec3 p    = ro + mi.x*rd;
        vec3 n    = normalize(p-md.xyz);
        vec3 r    = reflect(rd, n);
        vec3 ld   = normalize(lp - p);
        float fre = dot(n, rd)+1.0;
        fre = pow(fre, 15.0);
        float dif = max(dot(ld, n), 0.0);
        float spe = pow(max(dot(ld, r), 0.0), 8.0);
        float i = tanh_approx(20.0*fre*spe+0.05*dif);
        vec3 col = hsv2rgb(vec3(0.6, mix(0.66, 0.0, tanh_approx(3.0*i)), i));

        float t = tanh_approx(0.25*(mi.y-mi.x));

        return vec4(vec3(col), t);
      }

      vec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {
        vec2 gp = sp;
        gp *= ROT(0.67);
        gp += vec2(-1.0, 0.5);
        float h1 = height(2.0*sp);
        float gcc = dot(gp, gp);
        float gcx = exp(-(abs(3.0*(gp.x))));
        float gcy = exp(-abs(10.0*(gp.y)));
        float gh = gcy*gcx;
        float cf = smoothstep(0.05, -0.2, -h1);
        vec3 col = vec3(0.0);
        col += blackbody(mix(300.0, 3000.0, gcx*gcy))*gcy*gcx;
        col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));
        col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);
        sf = gh*cf;
        return col;
      }

      vec3 logoCol(vec3 col, vec2 p) {
        const float iz = 0.3;
        p.x += -0.2*p.y;
        float t0 = textsT(p+0.005*vec2(-1.0, 1.0), iz, 0.75, 0.2, 6.0);
        float t1 = textsT(p, iz, 0.78, 0.0, 6.0);
        const vec3 tcol = vec3(1.0, 0.05, 0.25);
        vec3 lcol = vec3(0.0);
        lcol = mix(lcol, 0.125*sqrt(tcol), t0);
        lcol = mix(lcol, mix(vec3(0.0), tcol, smoothstep(-0.25, 0.5, p.y)), t1);

        col += lcol;
        return col;
      }

      float segmentx(vec2 p) {
        float d0 = abs(p.y);
        float d1 = length(p);
        return p.x > 0.0 ? d0 : d1;
      }

      vec3 meteorite(vec3 ro, vec3 rd, vec2 sp) {
        const float period = 6.0;
        float mtime = mod(TIME, period);
        float ntime = floor(TIME/period);
        float h0 = hash(ntime);
        float h1 = fract(1667.0*h0);
        vec2 mp = sp;
        mp.x += -1.0;
        mp.y += -0.5*h1;
        mp *= ROT(PI+mix(-PI/4.0, PI/4.0, h0));
        float m = smoothstep(0.0, 0.25, mtime/period);
        mp.x += mix(-1.0, 2.0, m);

        float d0 = length(mp);
        float d1 = segmentx(mp);

        vec3 col = vec3(0.0);

        col += exp(-mix(300.0, 600.0, smoothstep(-0.5, 0.5, sin(10.0*TAU*TIME)))*max(d0, 0.0));
        col += 0.5*exp(-4.0*max(d0, 0.0))*exp(-1000.0*max(d1, 0.0));

        col *= vec3(1.0)*smoothstep(0.2, 0.8, sp.x);

        return col;
      }

      vec3 color(vec2 p, vec3 ro, vec3 rd, vec3 lp, vec4 md) {
        vec2 sp = toSpherical(rd.xzy).yz;

        float sf = 0.0;
        float cf = 0.0;
        vec3 col = vec3(0.0);

        vec4 mcol = moon(ro, rd, sp, lp, md);
        vec3 scol = sky(ro, rd, sp, lp, cf);

        col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(10.0*cf));
        col += galaxy(ro, rd, sp, sf);
        col = mix(col, mcol.xyz, mcol.w);
        col += scol;
        col += meteorite(ro, rd, sp);


        return col;
      }

      vec3 effect(vec2 p) {

        vec3 ro = vec3(0.0, 0.0, 0.0);
        vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);
        vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);
        vec3 la = vec3(1.0, 0.5, 0.0);
        vec3 up = vec3(0.0, 1.0, 0.0);
        float tdiff = btime13-btime9;
        float a = mix(-0.8, -0.0, (TIME-btime9)/tdiff);
      //  a = 0.0;
        la.xy *= ROT(a);

        vec3 ww = normalize(la - ro);
        vec3 uu = normalize(cross(up, ww));
        vec3 vv = (cross(ww,uu));
        vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);
        vec3 col= color(p, ro, rd, lp, md);
      //  col -= 0.01*vec3(0.0, 1.0, 2.0).zyx;

        col *= smoothstep(btime9+1.0, btime9+6.0, TIME);
        col = logoCol(col, p);
        col *= smoothstep(btime9, btime9+1.0, TIME);
        col = aces_approx(col);
        float foff = 0.1*length(p-vec2(0.0, -1.0));
        col += smoothstep(btime_fo, btime13, TIME-foff);
        col = sRGB(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p);

        frag_color = vec4(col,1.0);
      }
    </script>

    <script id="fs_romeo_knight" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D image  ;
      uniform sampler2D texts  ;

      const float TextHeight = 1.0/8.0;

      float textsT(vec2 p, float iz, float n) {
        p *= iz;
        p *= 0.5;
        if (abs(p.y) > 0.5*TextHeight) {
          return 0.0;
        }
        p += 0.5;
        p.y -= TextHeight*0.5;
        p.y -= (n-4.0)*TextHeight;
        p.y = 1.0-p.y;
        vec4 tcol = texture(texts, p);

        float off = 0.033*iz;
        return smoothstep(0.75-off, 0.75+off, tcol.x);
      }

      vec3 imageCol(vec3 col, vec2 p) {
        p *= 0.5;
        vec2 ap = abs(p);
        vec2 sp = step(ap, vec2(0.5));
        p += 0.5;
        p.y = 1.0-p.y;
        vec4 tcol = texture(image, p);
        col = mix(col, tcol.xyz*tcol.xyz, tcol.w*sp.x*sp.y);
        return col;
      }

      float romeoT(vec2 p, float iz) {
        p.x -= 0.5/iz;
        float t = textsT(p, iz, 5.0);
        t *= step(p.x, 0.);
        return t;
      }

      float knightT(vec2 p, float iz) {
        p.x += 0.5/iz;
        float t = textsT(p, iz, 5.0);
        t *= step(0., p.x);
        return t;
      }
      const float btime13  = BTIME(13.0);
      const float btime_fi = BTIME(13.125);
      const float btime_b0 = BTIME(13.0);
      const float btime_e0 = BTIME(13.25);
      const float btime_b1 = BTIME(13.125);
      const float btime_e1 = BTIME(13.5);
      const float btime_fo = BTIME(14.5);
      const float btime15 = BTIME(15.0);

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float linstep(float edge0, float edge1, float x) {
        return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      }

      vec3 effect(vec2 p) {
        float fi0 = smoothstep(btime_b0, btime_e0, TIME);
        float fi1 = smoothstep(btime_b1, btime_e1, TIME);
        vec3 col = vec3(0.0);
        float ratio = RESOLUTION.x/RESOLUTION.y;
        vec2 p1 = p;
        p1.y -= -0.8;
        p1 -= 0.1-0.1*linstep(btime13, btime15, TIME);
        p1 /= ratio+0.2*linstep(btime13, btime15, TIME);
        col = imageCol(col, p1);

        float tm = TIME-btime_fo+p.y-0.5;
        tm *= 4.0;
        float np = mod(floor(p.y/0.01), 2.0)-0.5;
        p.x += 0.25*sign(np)*exp(-tm*tm);
        vec2 p2 = p;
        p2 -= vec2(-0.5, 0.);
        float t2 = romeoT(p2, mix(0.05, 0.33, fi0));
        vec2 p3 = p;
        p3 -= vec2(0.5, -0.66);
        float t3 = knightT(p3, mix(0.05, 0.33, fi1));
        col = mix(col, mix(col, vec3(1.0, 0.0, 0.), fi0), t2);
        col = mix(col, mix(col, vec3(1.0, 1.0, 1.0), fi1), t3);
        col += smoothstep(btime_fi, btime13, TIME);

        col = sqrt(col);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = effect(p);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_solo" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------


      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define L2(x)       dot(x, x)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
      #define TTIME       (TAU*TIME)
      #define PSIN(x)     (0.5+0.5*sin(x))

      const float btime15 = BTIME(15.0);
      const float btime_fi= BTIME(15.0+0.25);
      const float btime_fo= BTIME(19.0-0.125);
      const float btime19 = BTIME(19.0);

      const float corner0 = 0.02;
      const float corner1 = 0.075;
      const float topy    = 0.0475+corner0*0.5;

      float hash(vec2 co) {
        return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);
      }

      // See Art of Code: Hexagonal Tiling Explained!
      // https://www.youtube.com/watch?v=VmrIDyYiJBA
      vec2 hextile(inout vec2 p) {

        const vec2 sz       = vec2(1.0, sqrt(3.0));
        const vec2 hsz      = 0.5*sz;

        vec2 p1 = mod(p, sz)-hsz;
        vec2 p2 = mod(p - hsz, sz)-hsz;
        vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));
        vec2 n = ((p3 - p + hsz)/sz);
        p = p3;

        // Rounding to make hextile 0,0 well behaved
        return round(n*2.0)/2.0;
      }

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      float box(vec2 p, vec2 b) {
          vec2 d = abs(p)-b;
          return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      float parallelogram(vec2 p, float wi, float he, float sk) {
          vec2 e = vec2(sk,he);
          p = (p.y<0.0)?-p:p;
          vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);
          vec2  d = vec2(dot(w,w), -w.y);
          float s = p.x*e.y - p.y*e.x;
          p = (s<0.0)?-p:p;
          vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);
          d = min( d, vec2(dot(v,v), wi*he-abs(s)));
          return sqrt(d.x)*sign(-d.y);
      }

      float circle(vec2 p, float r) {
        return length(p)-r;
      }

      vec2 refl(vec2 p, vec2 n) {
        p -= n*min(0.0, dot(p, n))*2.0;
        return p;
      }

      // http://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // https://iquilezles.org/articles/smin
      float pmin(float a, float b, float k) {
          float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
          return mix( b, a, h ) - k*h*(1.0-h);
      }

      float pmax(float a, float b, float k) {
        return -pmin(-a, -b, k);
      }
      #define SCA(a)          vec2(sin(a), cos(a))

      const vec2 impulse_sca0 = SCA(0.0);

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float horseshoe(vec2 p, vec2 c, float r, vec2 w) {
        p.x = abs(p.x);
        float l = length(p);
        p = mat2(-c.x, c.y,
                  c.y, c.x)*p;
        p = vec2((p.y>0.0)?p.x:l*sign(-c.x),
                  (p.x>0.0)?p.y:l );
        p = vec2(p.x,abs(p.y-r))-w;
        return length(max(p,0.0)) + min(0.0,max(p.x,p.y));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_e(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 1.05+off;
        p -= vec2(0.5, 0.5);
        // TODO: Optimize
        return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_I(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 0.25+off;
        p -= vec2(0.125, 0.75);
        return box(p, vec2(0.125, 0.75));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_l(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 0.2+off;
        p -= vec2(0.10, 0.5);
        return box(p, vec2(0.1, 0.666));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_m(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 2.2+off;
        p -= vec2(1.1, 0.5);
        p.y = -p.y;
        p.x = abs(p.x);
        p -= vec2(0.5, 0.0);
        float d = horseshoe(p, impulse_sca0, 0.5, vec2(0.5, 0.1));
        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_n(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 1.15+off;
        p -= vec2(0.55, 0.5);
        p.y = -p.y;
        float l = horseshoe(p, impulse_sca0, 0.5, vec2(0.5, 0.1));
        return l;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_p(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 1.05+off;
        p -= vec2(0.55, 0.5);
        float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));
        float c = abs(circle(p, 0.4)) - 0.1;
        return min(b, c);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_r(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 0.6+off;
        p -= vec2(0.1, 0.5);
        float d0 = box(p-vec2(0.20, 0.4), vec2(0.3, 0.1));
        float d1 = box(p, vec2(0.1, 0.5));
        return min(d0, d1);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_s(inout vec2 pp, float off) {
        const mat2 rots1 = ROT(-PI/6.0-PI/2.0);
        const mat2 rots2 = ROT(PI);
        vec2 p = pp;
        pp.x -= 0.875+off;
        p -= vec2(0.435, 0.5);
        p *= rots1;
        float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), impulse_sca0, 0.375, vec2(0.2, 0.1));
        p *= rots2;
        float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), impulse_sca0, 0.375, vec2(0.2, 0.1));
        return min(u,l);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_u(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 1.2+off;
        p -= vec2(0.6, 0.475);
        return horseshoe(p - vec2(0.0, 0.125), impulse_sca0, 0.5, vec2(0.4, 0.1));
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_t(inout vec2 pp, float off) {
        vec2 p = pp;
        pp.x -= 0.6+off;
        p -= vec2(0.3, 0.6);
        float d0 = box(p-vec2(0.0, 0.3), vec2(0.3, 0.1));
        float d1 = box(p, vec2(0.1, 0.6));
        return min(d0, d1);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse(vec2 p, float off) {
        p += vec2(3.385+3.0*off, 0.5);

        float d = 1E6;
        d = min(d, impulse_I(p, off));
        d = min(d, impulse_m(p, off));
        d = min(d, impulse_p(p, off));
        d = min(d, impulse_u(p, off));
        d = min(d, impulse_l(p, off));
        d = min(d, impulse_s(p, off));
        d = min(d, impulse_e(p, off));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float presents(vec2 p, float off) {
        p += vec2(3.65+3.5*off, 0.5);

        float d = 1E6;
        d = min(d, impulse_p(p, off));
        d = min(d, impulse_r(p, off));
        d = min(d, impulse_e(p, off));
        d = min(d, impulse_s(p, off));
        d = min(d, impulse_e(p, off));
        d = min(d, impulse_n(p, off));
        d = min(d, impulse_t(p, off));
        d = min(d, impulse_s(p, off));

        return d;
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse_bars(vec2 p, float d) {
        float db = abs(abs(p.y)-0.1)-0.05;
        return pmax(d, -db, 0.025);
      }

      // License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets
      float impulse(vec2 p) {
        float d = impulse(p, 0.25);
        return impulse_bars(p, d);
      }
      float impulseText(vec2 p) {
        vec2 p0 = p;
        p0 += vec2(3.0, 0.33)*sin(0.6*TIME*vec2(1.0, sqrt(0.5)));
        return impulse(p0);
      }

      float omega(vec2 p) {
        const float lw = 0.07;
        const float sm = 0.066;
        p.x = abs(p.x);
        vec2 p0 = p;
        p0.y -= 0.075;
        float d0 = circle(p0, 0.36);
        d0 = abs(d0)-lw;

        vec2 p1 = p;
        p1 -= vec2(0.175, -0.445);
        p1.y = -p1.y;
        p1  = refl(p1, normalize(vec2(1.0)));
        float d1 = parallelogram(p1, 0.31, lw, 0.04);

        vec2 p2 = p;
        float d2 = p2.y+0.20;
        d1 = pmax(d1, d2, sm);

        vec2 p3 = p;
        float d3 = min(-p3.y+0.075, -p3.x+0.105);
        d0 = pmax(d0, d3, sm);

        vec2 p4 = p;
        p4 -= vec2(0.175, -0.445)-vec2(lw);
        float d4 = length(p4);
        d1 = sign(p4) == vec2(-1.0) ? d4 : d1;

        float d = d0;
        d = min(d, d1);
      //  d = min(d, d4);

        return d;
      }

      float height_(vec2 p) {
        p *= 0.25;
        vec2 p0 = p;
        vec2 n0 = hextile(p0);
        float h = hash(n0);
        p0 *= ROT(TAU*h);
        const float ss = 0.625;
        float d0 = omega(p0/ss)*ss;
        float d = d0;
        d -= 0.02;
        const float aa = 0.02;
        float a = fract(127.0*h) > 0.5 ? 0.125 : -0.25;
        return a*tanh_approx(smoothstep(aa, -aa, d));
      }

      float height(vec2 p) {
        const mat2 rot1 = ROT(1.23);
        float tm = 123.0+TTIME/320.0;
        p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));
        const float aa = -0.33;
        const mat2  pp = (1.0/aa)*rot1;
        float h = 0.0;
        float a = 1.0;
        float d = 0.0;

        float tm2 = 0.5*TIME;
        h += 1.0*sin(0.75*tm2+dot(normalize(vec2(-1.0, 1.5)), 4.0*p));
        h += 0.5*sin(tm2+dot(normalize(vec2(1.0, 1.0)), 7.0*p));
        h += 0.25*sin(1.25*tm2+dot(normalize(vec2(-2, 1.0)), 13.0*p));
        h += 1.75;
        h*= 0.2;

        for (int i = 0; i < 5; ++i) {
          h += a*height_(p);
          d += a;
          a *= aa;
          p *= pp;
        }
        const float hf = -0.125;
        return hf*(h/d)+hf;
      }

      vec3 normal(vec2 p) {
        vec2 v;
        vec2 w;
        vec2 e = vec2(4.0/RESOLUTION.y, 0);

        vec3 n;
        n.x = height(p + e.xy) - height(p - e.xy);
        n.y = 2.0*e.x;
        n.z = height(p + e.yx) - height(p - e.yx);

        return normalize(n);
      }

      float synth(vec2 p) {
        const float z = 4.0;
        const float st = 0.02;
        float dob = box(p, vec2(1.55, 0.5));
        p.x = abs(p.x);
        p.x += st*20.0;
        p /= z;
        float n = mod1(p.x, st);
        float dib = 1E6;
        const int around = 3;
        for (int i = -around; i <=around ;++i) {
          float fft = texture(frequency_data, vec2((n+float(i))*st*1.5  , 0.5)).x;
          fft *= fft;
          fft *= 2.0;
          float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));
          dib = min(dib, dibb);
        }

        float dl = p.y;
        dl = abs(dl) - 0.005;
        dl = abs(dl) - 0.0025;
        dl = abs(dl) - 0.00125;
        float d = dib;
        d = max(d, -dl);
        d = pmax(d, dob, 0.025);
        return d*z;
      }


      float beat() {
        float beat = 0.0;
        const float samples = 5.0;
        const float st = 0.01;
        for (float i = 0.0; i < samples; ++i) {
          float fft = texture(frequency_data, vec2(st*1.0+st*i, 0.5)).x;
          beat += fft;
        }
        return smoothstep(0.75, 1.0, beat/samples);
      }

      // Post processing I found somewhere on shadertoy years ago
      vec3 postProcess(vec3 col, vec2 q) {
        col = clamp(col, 0.0, 1.0);
        col = pow(col, 1.0/vec3(2.2));
        col = col*0.6+0.4*col*col*(3.0-2.0*col);
        col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);
        col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);
        return col;
      }

      float linstep(float edge0, float edge1, float x) {
        return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
      }

      vec3 effect(vec2 p, vec2 q) {
        vec2 p4 = p;
        vec2 ppp = p;
        const float s = 1.0;
        const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);
        const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);

        float aa = 2.0/RESOLUTION.y;

        float h = height(p);
        vec3  n = normal(p);

        vec3 ro = vec3(0.0, mix(-3.0, -10.0, PSIN(TIME+PI*p.x)), 0.0);
        vec3 pp = vec3(p.x, 0.0, p.y);

        vec3 po = vec3(p.x, h, p.y);
        vec3 rd = normalize(ro - po);

        vec3 ld1 = normalize(lp1 - po);
        vec3 ld2 = normalize(lp2 - po);

        float diff1 = max(dot(n, ld1), 0.0);
        float diff2 = max(dot(n, ld2), 0.0);

        vec3  rn    = n;
        vec3  ref   = reflect(rd, rn);
        float ref1  = max(dot(ref, ld1), 0.0);
        float ref2  = max(dot(ref, ld2), 0.0);

        const vec3 lcol1 = sqrt(vec3(1.25, 1.35, 2.0).zxy*0.15);
        const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;
        vec3 lpow1 = 0.15*lcol1/L2(ld1);
        vec3 lpow2 = 0.25*lcol2/L2(ld2);
        vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);
        vec3 col = vec3(0.0);
        col += dm*pow(diff1, 4.0)*lpow1;
        col += dm*pow(diff2, 4.0)*lpow2;
        vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));
        col += rm*pow(ref1, 20.0)*lcol1;
        col += rm*pow(ref2, 20.0)*lcol2;

        float ds = synth(ppp-vec2(0.0, -0.75));
        float beat = beat();
//        beat = 1.0;

        const float zp = 1.35;

        vec2 op = ppp;
        op.x += -0.25*ppp.y;
        op /= zp;
        float di = impulseText(op);
        di *= zp;
        float dio = di;
        dio -= 0.025;
        dio = abs(dio) - 0.005;
        di = pmin(di, dio, 0.025);
        di = max(di, -(ds-0.005));
        di = min(di, ds);
        float dg = di;

        beat *= 4.0*beat;
        float dc = -p.x+p.y+mix(-1.5, 1.5, linstep(btime15, btime19, TIME));
        float angle = abs(dc);
        float gmix = tanh_approx(0.1/angle);
        float gmix2 = mix(1.0, abs(1.0/(angle)), beat);
        col += -lcol2*0.25*(exp(-9.0*max(di, 0.0)));

        dg = abs(dg-0.025);
        float glow = exp(-20.0*max(dg+0., 0.0));
        vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow)*gmix2;
        col = mix(col, vec3(mix(vec3(0.9), sqrt(glowCol*0.5), gmix)), smoothstep(-aa, aa, -di));
        col += glowCol*glow*gmix;
        col += smoothstep(btime_fi, btime15, TIME);
        col *= smoothstep(btime19, btime_fo, TIME);
        col = postProcess(col, q);
        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 col = effect(p, q);

        frag_color = vec4(col,1.0);
      }
    </script>

    <script id="vs_magic" type="x-shader/x-vertex">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      uniform mat4 proj ;
      uniform mat4 view ;

      in vec4 a_position;
      in vec3 a_normal;
      in vec2 a_texcoord;

      out vec3        v_position;
      out vec3        v_normal  ;
      out vec2        v_texcoord;
      out vec2        v_uv      ;
      flat out mat4   v_imodel  ;


      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      const vec2 dimn = vec2(128.0, 128.0);

      vec2 uv(float i) {
        return vec2(mod(i, dimn.x)/dimn.x, floor(i/dimn.x)/dimn.y);
      }

      const vec2 du = vec2(
          1.0/dimn.x
        , 1.0/dimn.y
        );

      const vec2 dux = vec2(du.x, 0.0);
      const vec2 duy = vec2(0.0, du.y);

      float r(float th, vec3 n, vec3 q) {
        return pow(pow(abs(1.0/q.y*cos(q.x*th*0.25)), n.y) + pow(abs(1.0/q.z*sin(q.x*th*0.25)), n.z), -1.0/n.x);
      }

      struct Shape
      {
        float r0 ;
        vec3  r1_0;
        vec3  r1_1;
        vec3  r2_0;
        vec3  r2_1;
      };

      const Shape Rose = Shape(
          5.0
        , vec3(0.2, 1.7, 1.7)
        , vec3(7.0, 1.0, 1.0)
        , vec3(0.2, 1.7, 1.7)
        , vec3(7.0, 1.0, 1.0)
        );

      const Shape Pollen = Shape(
          3.0
        , vec3(60.0 , 30.0, 30.0)
        , vec3(6.0  , 1.0 , 1.0 )
        , vec3(10.0 , 10.0, 10.0)
        , vec3(2.0  , 1.0 , 1.0 )
        );

      const Shape HexBox = Shape(
          3.0
        , vec3(60.0 , 25.0  , 25.0  )
        , vec3(6.0  , 1.0   , 1.0   )
        , vec3(250.0, 100.0 , 100.0 )
        , vec3(6.0  , 1.0   , 1.0   )
        );

      const Shape Saucer = Shape(
          6.0
        , vec3(0.2, 1.7, 1.7)
        , vec3(0.2, 1.0, 1.0)
        , vec3(0.5, 0.2, 0.2)
        , vec3(1.0, 1.0, 1.0)
        );

      const Shape Plankton = Shape(
          4.0
        , vec3(0.1, 1.0, 2.5)
        , vec3(2.6, 1.0, 1.0)
        , vec3(3.0, 0.2, 1.0)
        , vec3(3.0, 1.0, 1.0)
        );

      const Shape FlatFish = Shape(
          4.0
        , vec3(0.7  , 0.3   , 0.2 )
        , vec3(2.0  , 1.0   , 1.0 )
        , vec3(100.0, 100.0 , 20.0)
        , vec3(2.0  , 1.0   , 1.0 )
        );

      const Shape Lantern = Shape(
          8.0
        , vec3(0.2  , 1.7, 1.7)
        , vec3(20.0 , 1.0, 1.0)
        , vec3(0.5  , 0.2, 0.2)
        , vec3(6.0  , 1.0, 1.0)
        );

      const Shape Hedgehog = Shape(
          3.0
        , vec3(60.0, 25.0, 25.0)
        , vec3(100.0, 1.0, 1.0)
        , vec3(250.0, 100.0, 100.0)
        , vec3(40.0, 1.0, 1.0)
        );

      //#define SEGMENT20

      #if defined(SEGMENT19)
      #define SHAPE0 Rose
      #define SHAPE1 FlatFish
      #elif defined(SEGMENT20)
      #define SHAPE0 FlatFish
      #define SHAPE1 Saucer
      #elif defined(SEGMENT21)
      #define SHAPE0 Saucer
      #define SHAPE1 Lantern
      #elif defined(SEGMENT22)
      #define SHAPE0 Lantern
      #define SHAPE1 Lantern
      #else
      #define SHAPE0 Lantern
      #define SHAPE1 Lantern
      #endif


      vec3 supershape(vec2 p, float m1) {
        p -= 0.5;
        p *= vec2(2.0, 1.0)*PI;

        float r0    = mix(SHAPE0.r0   , SHAPE1.r0  , m1);
        vec3  r1_0  = mix(SHAPE0.r1_0 , SHAPE1.r1_0, m1);
        vec3  r1_1  = mix(SHAPE0.r1_1 , SHAPE1.r1_1, m1);
        vec3  r2_0  = mix(SHAPE0.r2_0 , SHAPE1.r2_0, m1);
        vec3  r2_1  = mix(SHAPE0.r2_1 , SHAPE1.r2_1, m1);

        float r1    = r(p.x, r1_0, r1_1);
        float r2    = r(p.y, r2_0, r2_1);

        return r0*vec3(
            r1*cos(p.x)*r2*cos(p.y)
          , r1*sin(p.x)*r2*cos(p.y)
          , r2*sin(p.y)
          );
      }

      mat3 rot_z(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
            c,s,0
          ,-s,c,0
          , 0,0,1
          );
      }

      mat3 rot_y(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
            c,0,s
          , 0,1,0
          ,-s,0,c
          );
      }

      mat3 rot_x(float a) {
        float c = cos(a);
        float s = sin(a);
        return mat3(
            1, 0,0
          , 0, c,s
          , 0,-s,c
          );
      }

      mat4 translate(vec3 t) {
        return transpose(mat4(
            1,0,0,t.x
          , 0,1,0,t.y
          , 0,0,1,t.z
          , 0,0,0,1
          ));
      }


      const vec2[6] duv0 = vec2[](
          vec2(0.0, 0.0)
        , dux
        , duy
        , duy
        , dux
        , du
        );

      const vec2[6] duv1 = vec2[](
          duv0[1]   - duv0[0]
        , duv0[2]   - duv0[1]
        , duv0[0]   - duv0[2]
        , duv0[4]   - duv0[3]
        , duv0[5]   - duv0[4]
        , duv0[3]   - duv0[5]
        );

      const vec2[6] duv2 = vec2[](
          duv0[2]   - duv0[0]
        , duv0[0]   - duv0[1]
        , duv0[1]   - duv0[2]
        , duv0[5]   - duv0[3]
        , duv0[3]   - duv0[4]
        , duv0[4]   - duv0[5]
        );


      void main() {

        float i   = float(gl_InstanceID);
        int   vid = gl_VertexID;
        vec2 uv   = uv(i);
        vec2 duv0 = duv0[vid];
        vec2 duv1 = duv1[vid];
        vec2 duv2 = duv2[vid];

        const float btime19 = BTIME(19.0);
        const float btime23 = BTIME(23.0);
        float ltm = smoothstep(0.5, 0.75, mod(TIME-btime19, bperiod)/bperiod);
        float m1 = ltm;
        //float dm = mix(1.0, 1.0-0.98, m1);
        const float dm = 0.015625;
        const float sdm = mix(0.25, 0.0, dm);
        vec2 uv0 = uv + duv0;
        vec2 uv1 = uv0 + dm*duv1 + sdm*dm*duv2;
        vec2 uv2 = uv0 + dm*duv2 + sdm*dm*duv1;

        vec3 p0  = supershape(uv0, m1);
        vec3 p1  = supershape(uv1, m1);
        vec3 p2  = supershape(uv2, m1);

        vec3 dp1  = p1-p0;
        vec3 dp2  = p2-p0;
        vec3 nor  = cross(dp1, dp2);
        nor = normalize(nor);

        vec4 ep     = vec4(p0, 1.0);

        float a = time*0.25;
        mat3 model3 = rot_y(a)*rot_z(sqrt(0.8)*a)*rot_x(sqrt(0.4)*a);
        mat4 model4 = mat4(model3);
        mat4 imodel4= mat4(transpose(model3));
        mat4 vp     = proj*view*model4;

        gl_Position = vp*ep;
        vec4 mp     = model4*ep;
        vec3 mnor   = model3*nor;

        v_position  = mp.xyz          ;
        v_normal    = mnor            ;
        v_texcoord  = a_texcoord      ;
        v_imodel    = imodel4         ;
        v_uv        = uv0             ;
      }
    </script>

    <script id="fs_magic" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec3        v_position;
      in vec3        v_normal  ;
      in vec2        v_texcoord;
      in vec2        v_uv      ;
      flat in mat4   v_imodel  ;

      out vec4 frag_color;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // http://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // http://mercury.sexy/hg_sdf/
      vec3 mod3(inout vec3 p, vec3 size) {
        vec3 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      float circle(vec2 p, float r) {
        return length(p) - r;
      }


      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
          float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
          return mix( b, a, h ) - k*h*(1.0-h);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm
      float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
      }

      float raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {
          float ndbuffer = dbuffer/sph.w;
          vec3  rc = (ro - sph.xyz)/sph.w;

          float b = dot(rd,rc);
          float c = dot(rc,rc) - 1.0;
          float h = b*b - c;
          if( h<0.0 ) return 0.0;
          h = sqrt( h );
          float t1 = -b - h;
          float t2 = -b + h;

          if( t2<0.0 || t1>ndbuffer ) return 0.0;
          t1 = max( t1, 0.0 );
          t2 = min( t2, ndbuffer );

          float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);
          float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);
          return (i2-i1)*(3.0/4.0);
      }

      vec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {
        vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes
        vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes
        vec3 k = abs(m)*boxSize;
        vec3 t1 = -n - k;
        vec3 t2 = -n + k;
        float tN = max( max( t1.x, t1.y ), t1.z );
        float tF = min( min( t2.x, t2.y ), t2.z );
        if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection
        outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
        return vec2( tN, tF );
      }

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      const vec3 lightDir1 = normalize(vec3(-0.3, 0.15, 1.0));
      const vec3 lightDir2 = normalize(vec3(-1.5,  0., -1.0));
      const vec3 glowCol   = vec3(1.0, 4.0, 1.5);

      float blobs(vec2 p) {
        // Generates a grid of dots
        vec2 bp = p;
        vec2 bn = mod2(bp, vec2(3.0));

        vec2 dp = p;
        vec2 dn = mod2(dp, vec2(0.25));
        float ddots = length(dp);

        // Blobs
        float dblobs = 1E6;
        for (int i = 0; i < 5; ++i) {
          float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);
          dblobs = pmin(dblobs, dd, 0.35);
        }

        float d = 1E6;
        d = min(d, ddots);
        // Smooth min between blobs and dots makes it look somewhat amoeba like
        d = pmin(d, dblobs, 0.35);
        return d;
      }

      const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));
      vec3 skyColor(vec3 ro, vec3 rd) {
        vec3 col = clamp(vec3(0.00125/abs(rd.y))*gcol, 0.0, 1.0);


        float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));
        float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));
        float tp = tp1;
        tp = max(tp0,tp1);
        if (tp > 0.0) {
        }


        if (tp1 > 0.0) {
          vec3 pos  = ro + tp1*rd;
          vec2 pp = pos.xz;
          float db = box(pp, vec2(6.0, 9.0))-1.0;

          col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);
          col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));
        }


        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec3 nor = v_normal;

        vec2 uv = v_uv;

        vec2 ap = abs(p);
        vec2 dpx = abs(dFdx(ap));
        vec2 dpy = abs(dFdy(ap));
        vec2 smf = dpx+dpy;
        vec2 bp = smoothstep(vec2(1.0)-smf, vec2(1.0), ap);
        vec2 fo = smoothstep(0.33, 0.0, smf);
        vec3 bcol = (0.33*gcol)*(fo.x*fo.y)*tanh_approx((bp.x+bp.y));

        vec3 ro = vec3(0.0, 3.0, 7.0);
        vec3 ri = v_position;
        vec3 rd = normalize(ri-ro);
        vec3 ref = reflect(rd, nor);
        vec3 refr= refract(rd, nor, 0.75);

        mat4 imodel = v_imodel;
        vec3 iro  = (imodel*vec4(ri, 1.0)).xyz;
        vec3 ird  = mat3(imodel)*refr;

        float diff1 = max(dot(nor, lightDir1), 0.0);
        float diff2 = max(dot(nor, lightDir2), 0.0);

        float fre  = 1.0+min(dot(rd, nor), 0.0);
        fre *= fre;

        vec3 rsky = skyColor(ri, ref);
        vec3 col = vec3(0.0);
        col += 0.5*fre*rsky*rsky;

        float gf = beat(TIME);
        float gsr = mix(2.0, 3.0, gf);
        float gd = raySphereDensity(iro, ird, vec4(vec3(0.0), gsr), 1E6);
        col += mix(0.6, 0.9, gf)*glowCol*gd*gd;

        col += bcol*diff1+bcol*diff2;
        vec3 mcol = hsv2rgb(vec3(0.5+0.25*v_uv.y, 0.95, 0.125));
      // col = abs(nor);

        frag_color = vec4(col,1.0);
      }
    </script>

    <script id="fs_magic_sky" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;

      out vec4 frag_color ;

      #define TIME        time
      #define RESOLUTION  resolution

      #define PI          3.141592654
      #define TAU         (2.0*PI)
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      const float bstart = 25.61;
      const float bpm    = 125.0;
      const float bhz    = bpm/60.0;
      const float bperiod= 8.0/bhz;

      #define BTIME(n) ((n)*bperiod+bstart)

      float beatCount(float tm) {
        return (tm-bstart)*bhz;
      }

      float beat(float tm) {
        return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------

      uniform sampler2D prev_pass   ;

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      const vec3 lightPos1 = 100.0*vec3(-0.3, 0.15, 1.0);
      const vec3 lightPos2 = 100.0*vec3(-0.33,  -0.2, -1.0);
      const vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);
      const vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);

      float saturate(in float a) { return clamp(a, 0.0, 1.0); }

      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      // http://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // http://mercury.sexy/hg_sdf/
      vec3 mod3(inout vec3 p, vec3 size) {
        vec3 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      float circle(vec2 p, float r) {
        return length(p) - r;
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
      float box(vec2 p, vec2 b) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      // License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
          float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
          return mix( b, a, h ) - k*h*(1.0-h);
      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm
      float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
      }


      vec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {
        vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes
        vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes
        vec3 k = abs(m)*boxSize;
        vec3 t1 = -n - k;
        vec3 t2 = -n + k;
        float tN = max( max( t1.x, t1.y ), t1.z );
        float tF = min( min( t2.x, t2.y ), t2.z );
        if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection
        outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
        return vec2( tN, tF );
      }

      float tanh_approx(float x) {
      //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }


      const vec3 lightDir1 = normalize(vec3(2.0, 0.5, 1.0));
      const vec3 lightDir2 = normalize(vec3(-1.5,  0., -1.0));

      float blobs(vec2 p) {
        // Generates a grid of dots
        vec2 bp = p;
        vec2 bn = mod2(bp, vec2(3.0));

        vec2 dp = p;
        vec2 dn = mod2(dp, vec2(0.25));
        float ddots = length(dp);

        // Blobs
        float dblobs = 1E6;
        for (int i = 0; i < 5; ++i) {
          float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);
          dblobs = pmin(dblobs, dd, 0.35);
        }

        float d = 1E6;
        d = min(d, ddots);
        // Smooth min between blobs and dots makes it look somewhat amoeba like
        d = pmin(d, dblobs, 0.35);
        return d;
      }

      const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));
      vec3 skyColor(vec3 ro, vec3 rd) {
        vec3 col = clamp(vec3(0.00125/abs(rd.y))*gcol, 0.0, 1.0);

        float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));
        float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));
        float tp = tp1;
        tp = max(tp0,tp1);
        if (tp > 0.0) {
          vec3 pos  = ro + tp*rd;
          const float fz = 0.25;
          const float bz = 1.0/fz;
          vec2 p2 = pos.xz;
          p2.y += -4.0*TIME;
          vec2 bpos = p2/bz;
          float db = blobs(bpos)*bz;
          db = abs(db);
          vec2 pp = p2*fz;
          float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));
          m *= m;
          m *= m;
          pp = fract(pp+0.5)-0.5;
          float dp = pmin(abs(pp.x), abs(pp.y), 0.125);
          dp = min(dp, db);
          vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);
          vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);

          float f = 1.0-tanh_approx(0.1*length(pos.xz));
          col = mix(col, pcol , f);
        }


        if (tp1 > 0.0) {
          vec3 pos  = ro + tp1*rd;
          vec2 pp = pos.xz;
          float db = box(pp, vec2(6.0, 9.0))-1.0;

          col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);
          col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));
        }


        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 ro = vec3(0.0, 3.0, 7.0);
        vec3 la = vec3(0.0, 0.0, 0.0);
        vec3 up = vec3(0.0, 1.0, 0.0);

        vec3 ww = normalize(la - ro);
        vec3 uu = normalize(cross(up, ww ));
        vec3 vv = normalize(cross(ww,uu));
        float fov = tan(TAU/6.0);
        vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);

        vec3 skyCol = skyColor(ro, rd);

        vec4 tcol = texture(prev_pass,q);
        vec3 col = skyCol;
        col = mix(col, tcol.xyz, tcol.w);
        col = sRGB(col);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script type = "text/javascript">
      const analyze_audio   = true;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [
      ];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
//          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        tribute__1989 : {
          image : (gl) => override_nearest(document.getElementById("tribute__1989")),
        },
        tribute__almost_mono : {
          image : (gl) => document.getElementById("tribute__almost_mono"),
        },
        tribute__red_sector : {
          image : (gl) => document.getElementById("tribute__red_sector"),
        },
        tribute__romeo_knight : {
          image : (gl) => document.getElementById("tribute__romeo_knight"),
        },
        tribute__texts_df : {
          image : (gl) => document.getElementById("tribute__texts_df"),
        },
      }

      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red"    ,
            },
          ],
        },
        moody_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_moody"  ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__1989.texture);
                gl.uniform1i(pass.uniformLocations.image, 4);

                gl.activeTexture(gl.TEXTURE5);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__texts_df.texture);
                gl.uniform1i(pass.uniformLocations.texts, 5);
              },
            }
          ],
          uniforms: ["image", "texts"],
        },
        intro_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_intro"  ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__almost_mono.texture);
                gl.uniform1i(pass.uniformLocations.almost_mono, 4);

                gl.activeTexture(gl.TEXTURE5);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__red_sector.texture);
                gl.uniform1i(pass.uniformLocations.red_sector, 5);

                gl.activeTexture(gl.TEXTURE6);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__texts_df.texture);
                gl.uniform1i(pass.uniformLocations.texts, 6);
              },
            }
          ],
          uniforms: ["almost_mono", "red_sector", "texts"],
        },
        beatbox_scene : {
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_beatbox"  ,
            }
          ],
        },
        dawn_scene : {
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_dawn"     ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__texts_df.texture);
                gl.uniform1i(pass.uniformLocations.texts, 4);
              },
            }
          ],
          uniforms: ["texts"],
        },
        romeo_knight_scene : {
          passes:[
            {
              vs: "vs_default"      ,
              fs: "fs_romeo_knight" ,
              pre_render: (gl, time, scene, pass) => {
                // Texture 0-3 is reserved
                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__romeo_knight.texture);
                gl.uniform1i(pass.uniformLocations.image, 4);

                gl.activeTexture(gl.TEXTURE5);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.tribute__texts_df.texture);
                gl.uniform1i(pass.uniformLocations.texts, 5);
              },
            }
          ],
          uniforms: ["image", "texts"],
        },
        solo_scene : {
          analyze_audio: true   ,
          passes:[
            {
              vs: "vs_default"  ,
              fs: "fs_solo"     ,
            }
          ],
        },
        magic_scene : {
          passes:[
            {
              vs: "vs_magic"                ,
              fs: "fs_magic"                ,
              requires_clear: true          ,
              instances: 16384              ,
              pre_render: (gl, time, scene, pass) => {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);

                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);

                gl.uniformMatrix4fv(pass.uniformLocations.proj, false, projection_magic);
                gl.uniformMatrix4fv(pass.uniformLocations.view, false, view_magic);
              },
            },
            {
              vs: "vs_default"    ,
              fs: "fs_magic_sky"  ,
              pre_render: (gl, time, scene, pass) => {
                gl.disable(gl.CULL_FACE);
                gl.disable(gl.DEPTH_TEST);
              },
            }
          ],
          uniforms: ["proj", "view"],
        },
      };

      const bstart  = 25.61;
      const bpm     = 125.0;
      const bhz     = bpm/60.0;
      function btime(b) {
        return (8.0*b/bhz+bstart);
      }

      const max_time_slots  = 128;
      const time_slots      = new Array(max_time_slots);
      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.intro_scene           ,
        },
        {
          begin       :  3                                ,
          scene       :  all_scenes.beatbox_scene         ,
        },
        {
          begin       :  9                                ,
          scene       :  all_scenes.dawn_scene            ,
        },
        {
          begin       :  13                               ,
          scene       :  all_scenes.romeo_knight_scene    ,
        },
        {
          begin       :  15                               ,
          scene       :  all_scenes.solo_scene            ,
        },
        {
          begin       :  19                               ,
          scene       :  all_scenes.magic_scene           ,
        },
        {
          begin       :  40                               ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        if (time < bstart) {
          return all_scenes.moody_scene;
        }
        const i = clamp(Math.floor((time-bstart)*bhz/8.0), 0, max_time_slots-1);
        return time_slots[i];
      }

      function handleKeyDown(event) {
        if (event.altKey && event.key === 'Enter') {
          event.preventDefault();
          const music = document.getElementById("music");
          music.play();
        }
      }

      function on_init_complete(width, height) {
        globalThis.projection_magic = projection_matrix4(Math.PI/3.0, width/height, 1, 1000);
        globalThis.view_magic       = look_at_matrix4(vector3(0,3,7), vector3(0,0,0), vector3(0,1,0));

        const label = document.getElementById("info_label");
        label.textContent = "🚀 Ready, click play to run or hit Alt+Enter";

        const music = document.getElementById("music");
        music.style.visibility = "visible";

        document.addEventListener('keydown', handleKeyDown);
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "🔄 Compiling: " + key;
      }

      function pre_render(gl, time, scene, pass) {
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        const slot = get_slot(time);
        if(slot && slot.scene) {
          return slot.scene;
        } else {
          return all_scenes.moody_scene;
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="soundlogic_-_rise_up_-_amigaremix_03445.mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>Our tribute to Red Sector</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="tribute__1989" src="tribute__1989.jpg" style="display: none"/>
    <img id="tribute__almost_mono" src="tribute__almost_mono.jpg" style="display: none"/>
    <img id="tribute__red_sector" src="tribute__red_sector.jpg" style="display: none"/>
    <img id="tribute__romeo_knight" src="tribute__romeo_knight.jpg" style="display: none"/>
    <img id="tribute__texts_df" src="tribute__texts_df.png" style="display: none"/>
  </body>
</html>