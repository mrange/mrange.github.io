<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>impulse internal 2021</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v1.js" type="text/javascript"></script>
    <link href='https://fonts.googleapis.com/css?family=Josefin Slab' rel='stylesheet'>
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs-default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;

        v_texcoord = a_texcoord;
      }
    </script>

    <script id="fs-red-scene" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs-reine-bars-scene" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      #define PI              3.14159265358979323846
      #define TAU             (2.0*PI)
      #define BPM             120.0
      #define BTIME(n)        ((n)*60.0/BPM)

      float beat(float n) {
        return smoothstep(BTIME(n+1.0), BTIME(n), time)*step(BTIME(n), time);
      }

      float bop()
      {
        return smoothstep(0.5, 1.0, cos(time*TAU*BPM/60.0));
      }

      vec2 rot2d(vec2 uv, float angle)
      {
        uv -= 0.5;
        uv =  mat2(cos(angle),-sin(angle),sin(angle),cos(angle)) * uv;
        uv += 0.5;
        return uv;
      }

      vec3 sinebar(vec2 uv, vec3 color, float speed, float amp, float width, float inc)
      {
        float y = sin(uv.y + speed + uv.y) * amp + inc;
        uv.x += (y * 0.3) * 1.4;
        float scale = pow(1.0 - distance(y, uv.x), 22.0);
        return color * mix(scale, 2.0*scale, bop());
      }

      vec3 raster(vec2 fc)
      {
        vec2 uv = fc;
        vec2 uv1 = rot2d(uv,PI*0.11*time);
        vec2 uv2 = rot2d(uv,PI*0.12*time);
        vec2 uv3 = rot2d(uv,PI*0.13*time);
        vec2 uv4 = rot2d(uv,PI*0.14*time);
        vec3 color = vec3(0.0);
        float speed = time * 2.2;
        color += sinebar(uv1, vec3(0.7, 0.0, 0.4), speed+1.9, 0.20, 0.05, 0.7);
        color += sinebar(uv2, vec3(0.7, 0.4, 0.0), speed+1.2, 0.31, 0.24, 0.6);
        color += sinebar(uv3, vec3(1.0, 0.0, 0.0), speed+0.5, 0.12, 0.17, 0.8);
        color += sinebar(uv4, vec3(1.0, 0.7, 0.0), speed+0.3, 0.16, 0.12, 0.8);
        return color;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 color = raster(v_texcoord);
        color += smoothstep(BTIME(4.0), 0.0, time);
        frag_color = vec4(color, 1.);
      }
    </script>

    <script id="fs-reine-metaballs-scene" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      #define PI              3.14159265358979323846
      #define TAU             (2.0*PI)
      #define BPM             120.0
      #define BTIME(n)        ((n)*60.0/BPM)

      float beat(float n) {
        return smoothstep(BTIME(n+1.0), BTIME(n), time)*step(BTIME(n), time);
      }

      float bop()
      {
        return smoothstep(0.5, 1.0, cos(time*TAU*BPM/60.0));
      }

      //--------------------------------------------------------
      // Basic metaballs with distance field
      //
      // v1.0 - 2021-03-28 - Initial version
      // Thanks to mrange for improvements
      //--------------------------------------------------------


      float circle(vec2 pos, float r) {
        return length(pos) - r;
      }

      // Polynominal smooth min, https://www.iquilezles.org/www/articles/smin/smin.htm
      float pmin(float a, float b, float k) {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
      }

      float df(vec2 p) {
        float d = 1E6;
        for (int i = 0; i < 6; ++i) {
          float a = 1.2*(time + 2.0*float(i));
          float d0 = circle(p - vec2(cos(a), sin(a*sqrt(0.2))), 0.63);
          d = pmin(d, d0, 0.15);
        }
        for (int i = 0; i < 4; ++i) {
          d = abs(d) - 0.0005/d;
        }
        return d;
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        p.x *= resolution.x/resolution.y;
        float aa = 2.0/resolution.y;
        vec3 col = vec3(0.2,0.2,0.2);
        float d = df(p);
        col = mix(col, vec3(1.0,0.2,0.0), smoothstep(-aa, aa, -d));
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs-reine-cube-scene" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;

      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;

      in vec2 v_texcoord  ;
      out vec4 frag_color ;

      #define PI              3.14159265358979323846
      #define TAU             (2.0*PI)
      #define BPM             120.0
      #define BTIME(n)        ((n)*60.0/BPM)

      float beat(float n) {
        return smoothstep(BTIME(n+1.0), BTIME(n), time)*step(BTIME(n), time);
      }

      float bop()
      {
        return smoothstep(0.5, 1.0, cos(time*TAU*BPM/60.0));
      }

      //--------------------------------------------------------
      // Plain old retro wirecube with a distance field twist
      //
      // v1.0 - 2021-03-21 - Initial version
      // Thanks to mrange for improvements
      //--------------------------------------------------------

      mat4 model = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);

      vec2 Project(vec3 p0) {
        vec3 viewport = vec3(0.0,-2.0,0.0);
        p0 -= viewport;
        return length(viewport) * p0.xz / p0.y;
      }

      mat4 Scale(vec3 v) {
        return mat4(vec4(v.x,0,0,0), vec4(0,v.y,0,0), vec4(0,0,v.z,0), vec4(0,0,0,1));
      }

      mat4 Rotate(vec3 u, float a) {
        float c = cos(a);
        float s = sin(a);
        vec3 c0 = vec3(c + (u.x*u.x) * (1.0-c), (u.y*u.x) * (1.0-c) + (u.z*s), (u.z*u.x) * (1.0-c) - (u.y*s));
        vec3 c1 = vec3((u.x*u.y) * (1.0-c) - (u.z*s), c + (u.y*u.y) * (1.0-c), (u.z*u.y) * (1.0-c) + (u.x*s));
        vec3 c2 = vec3((u.x*u.z) * (1.0-c) + (u.y*s), (u.y*u.z) * (1.0-c) - (u.x*s), c + (u.z*u.z) * (1.0-c));
        return mat4(mat3(c0,c1,c2));
      }

      mat4 Translate(vec3 v) {
        return mat4(vec4(1.0,0,0,v.x), vec4(0,1.0,0,v.y), vec4(0,0,1.0,v.z), vec4(0,0,0,1.0));
      }


      float DistanceToLine(vec3 p0,vec3 p1,vec2 uv) {
        p0 = (vec4(p0,1.0) * model).xyz;
        p1 = (vec4(p1,1.0) * model).xyz;
        p0.xy = Project(p0);
        p1.xy = Project(p1);
        vec2 d = normalize(p1.xy - p0.xy);
        uv = (uv - p0.xy) * mat2(d.x, d.y, -d.y, d.x);
        float dist = distance(uv, clamp(uv, vec2(0.0), vec2(distance(p0.xy, p1.xy), 0.0)));
        return dist;
      }

      float pmin(float a, float b, float k) {
        float h = clamp( 0.5+0.7*(b-a)/k, 0.0, 1.0);
        return mix(b,a,h) - k*h*(1.0-h);
      }

      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {

        vec2 uv = v_texcoord;
        uv.x *= resolution.x/resolution.y;
        uv = uv - vec2(1.0, 0.5);
        uv *= 2.5;
        float time = time;

        model *= Scale(vec3(0.3));
        model *= Rotate(vec3(1.0, 0, 0.0), 1.2*time);
        model *= Rotate(vec3(0.0, 1.0, 0.0), 1.2*time);
        model *= Rotate(vec3(0.0, 0, 1.0), 1.2*time);
        model *= Translate(vec3(0.6*sin(time), 0.2*cos(time)-0.73, 0.18*cos(time)+0.1));

        vec3 cube[8];
        cube[0] = vec3(-1,-1,-1);
        cube[1] = vec3( 1,-1,-1);
        cube[2] = vec3(-1, 1,-1);
        cube[3] = vec3( 1, 1,-1);
        cube[4] = vec3(-1,-1, 1);
        cube[5] = vec3( 1,-1, 1);
        cube[6] = vec3(-1, 1, 1);
        cube[7] = vec3( 1, 1, 1);

        float dist = 1E6;
        const float sm = 0.3;
        dist = pmin(dist, DistanceToLine(cube[0],cube[1], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[1],cube[3], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[3],cube[2], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[2],cube[0], uv), sm);

        dist = pmin(dist, DistanceToLine(cube[4],cube[5], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[5],cube[7], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[7],cube[6], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[6],cube[4], uv), sm);

        dist = pmin(dist, DistanceToLine(cube[0],cube[4], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[5],cube[1], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[2],cube[6], uv), sm);
        dist = pmin(dist, DistanceToLine(cube[7],cube[3], uv), sm);

        vec3 linecube = vec3(0);
        linecube = mix(linecube, vec3(0,0,1), smoothstep(5.0/resolution.y, 0.0, dist));
        linecube += sin(0.5*dist*vec3(290.0, 0.0, 3.0));
        frag_color = vec4(linecube,0.0);
      }
    </script>

    <script type = "text/javascript">
      const analyze_audio   = false;
      const demo_system     = new DemoSystemV1(analyze_audio);

      const global_uniforms = [];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        retro_font : {
          image : () => override_nearest(document.getElementById("retro-font")),
        },
        the_return : {
          image : () => document.getElementById("the-return"),
        },
        young_reine : {
          image : () => document.getElementById("young-reine"),
        },
      };

      const all_scenes = {
        red_scene : {
          vs: "vs-default"  ,
          fs: "fs-red-scene"
        },
        reine_bars_scene : {
          vs: "vs-default"          ,
          fs: "fs-reine-bars-scene"
        },
        reine_metaballs_scene : {
          vs: "vs-default"          ,
          fs: "fs-reine-metaballs-scene"
        },
        reine_cube_scene : {
          vs: "vs-default"          ,
          fs: "fs-reine-cube-scene"
        },
      };

      const bpm   = 120.0;
      const beat  = 60.0/bpm;
      const start = 0.0*beat;
      function btime(b) {
        return (b*beat-start);
      }

      const max_time_slots  = 400;
      const time_slots      = new Array(max_time_slots);

      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.reine_bars_scene      ,
        },
        {
          begin       :  16                               ,
          scene       :  all_scenes.reine_metaballs_scene ,
        },
        {
          begin       :  32                               ,
          scene       :  all_scenes.reine_cube_scene      ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        const i = clamp(Math.floor(time/beat), 0, max_time_slots-1);
        return time_slots[i];
      }

      // Called after initialization of all shaders are complete
      function on_init_complete() {
        const label = document.getElementById("info-label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }

      function on_loading_scene(key) {
        const label = document.getElementById("info-label");
        label.textContent = "Compiling: " + key;
      }

      function on_select_scene(gl, time) {
        if (time > start) {
          const gtime = time - start;
          const slot = get_slot(gtime);
          if(slot && slot.scene) {
            return slot.scene;
          } else {
            return all_scenes.red_scene;
          }
        } else {
          return all_scenes.red_scene;
        }
      }

      function on_set_uniforms(gl, time, scene) {
        if (scene.set_uniforms) {
          scene.set_uniforms(gl, time, scene);
        }
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="SommarHack_2020_-_Neon_Workout_[VixaTunes.COM].mp3"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>impulse internal 2021</h1>

      <p>Music <a target="_blank" href="https://soundcloud.com/no-om-uo-n/sommarhack-2020">SommarHack 2020</a> by <a target="_blank" href="https://soundcloud.com/no-om-uo-n">Neon Workout</a>.</p>

      <p id="info-label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="glcanvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <canvas id="offscreen-canvas" width="512" height="512" style="display: none"></canvas>
    <img id="retro-font"  src="retro-font.png"  style="display: none"/>
    <img id="the-return"  src="the-return.png"  style="display: none"/>
    <img id="young-reine" src="young-reine.png" style="display: none"/>
    <imy>
</html>