<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>In memory of...</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="demo-system-v2.js" type="text/javascript"></script>
    <script src="tiny-sdf.js" type="module"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Slab&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Josefin Slab';
            font-size: 2vw;
            color: white;
            background-color: black;
        }
        a:link {
          text-decoration: none;
          color: #FF8240;
        }
        a:visited {
          text-decoration: none;
          color: #FF8240;
        }
        a:hover {
          text-decoration: underline;
          color: #DFF180;
        }
        a:active {
          text-decoration: underline;
          color: #DFF180;
        }
        canvas.gl {
          position:fixed;
          z-index:-1;
          top:0;
          left: 0;
          height: 100%;
          width: 100%;
          background-color: black;
        }
        div.center-flex {
          display: flex;
          align-items: center;
          justify-content: center;
        }
    </style>

    <script id="vs_default" type="x-shader/x-vertex">
      precision highp float;

      in vec4 a_position;
      in vec3 a_normal  ;
      in vec2 a_texcoord;

      out vec2 v_texcoord;

      void main(void) {
        gl_Position = a_position;
        v_texcoord  = a_texcoord;
      }
    </script>

    <script id="fs_red_pass" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      void main(void) {
        vec3 col = vec3(1.0, 0.0, 0.0);

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_night_sky" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      uniform sampler2D in_memory_of;
      uniform sampler2D motorbike;

      #define LAYERS            5.0

      #define PI                3.141592654
      #define TAU               (2.0*PI)
      #define TIME              time
      #define TTIME             (TAU*TIME)
      #define RESOLUTION        resolution
      #define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }

      // License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
      vec2 mod2(inout vec2 p, vec2 size) {
        vec2 c = floor((p + size*0.5)/size);
        p = mod(p + size*0.5,size) - size*0.5;
        return c;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      vec2 shash2(vec2 p) {
        return -1.0+2.0*hash2(p);
      }

      vec3 toSpherical(vec3 p) {
        float r   = length(p);
        float t   = acos(p.z/r);
        float ph  = atan(p.y, p.x);
        return vec3(r, t, ph);
      }


      // License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2
      vec3 blackbody(float Temp) {
        vec3 col = vec3(255.);
        col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;
        col.y = 100.04 * log(Temp) - 623.6;
        if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;
        col.z = 194.18 * log(Temp) - 1448.6;
        col = clamp(col, 0., 255.)/255.;
        if (Temp < 1000.) col *= Temp/1000.;
        return col;
      }


      // License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr
      float noise(vec2 p) {
        // Found at https://www.shadertoy.com/view/sdlXWX
        // Which then redirected to IQ shader
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f*f*(3.-2.*f);

        float n =
               mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)),
                         dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),
                    mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)),
                         dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);

        return 2.0*n;
      }

      float fbm(vec2 p, float o, float s, int iters) {
        p *= s;
        p += o;

        const float aa = 0.5;
        const mat2 pp = 2.04*ROT(1.0);

        float h = 0.0;
        float a = 1.0;
        float d = 0.0;
        for (int i = 0; i < iters; ++i) {
          d += a;
          h += a*noise(p);
          p += vec2(10.7, 8.3);
          p *= pp;
          a *= aa;
        }
        h /= d;

        return h;
      }

      float height(vec2 p) {
        float h = fbm(p, 0.0, 5.0, 5);
        h *= 0.3;
        h += 0.0;
        return (h);
      }

      vec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {
        vec3 oc = ro - sph.xyz;
        float b = dot( oc, rd );
        float c = dot( oc, oc ) - sph.w*sph.w;
        float h = b*b - c;
        if( h<0.0 ) return vec2(-1.0);
        h = sqrt( h );
        return vec2(-b - h, -b + h);
      }

      vec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {
        const float period = 4.0;
        float mtime = mod(TIME, period)/period;
        vec3 col = vec3(0.0);

        const float m = LAYERS;
        hh = tanh_approx(20.0*hh);

        for (float i = 0.0; i < m; ++i) {
          vec2 pp = sp+0.5*i;
          float s = i/(m-1.0);
          vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);
          vec2 np = mod2(pp, dim);
          vec2 h = hash2(np+127.0+i);
          vec2 o = -1.0+2.0*h;
          float y = sin(sp.x);
          pp += o*dim*0.5;
          pp.y *= y;
          float l = length(pp);

          float h1 = fract(h.x*1667.0);
          float h2 = fract(h.x*1887.0);
          float h3 = fract(h.x*2997.0);
          float h4 = fract(h.x*8997.0);

          vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));

          const float a = 0.1;
          float b = mix(1.0, 0.3, smoothstep(0.95, 1.0, sin(TAU*(mtime+h4))));
          vec3 ccol = col + b*exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;
          col = h3 < y ? ccol : col;
        }

        return col;
      }

      vec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {
        float ld = max(dot(normalize(lp-ro), rd),0.0);
        float y = -0.5+sp.x/PI;
        y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));
        vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));
        float ci = pow(ld, 10.0)*2.0*exp(-25.0*y);
        vec3 yellow = blackbody(1500.0)*ci;
        cf = ci;
        return blue+yellow;
      }

      vec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {
        vec2 mi = raySphere(ro, rd, md);

        vec3 p    = ro + mi.x*rd;
        vec3 n    = normalize(p-md.xyz);
        vec3 r    = reflect(rd, n);
        vec3 ld   = normalize(lp - p);
        float fre = dot(n, rd)+1.0;
        fre = pow(fre, 15.0);
        float dif = max(dot(ld, n), 0.0);
        float spe = pow(max(dot(ld, r), 0.0), 8.0);
        float i = tanh_approx(20.0*fre*spe+0.05*dif);
        vec3 col = hsv2rgb(vec3(0.6, mix(0.66, 0.0, tanh_approx(3.0*i)), i));

        float t = tanh_approx(0.25*(mi.y-mi.x));

        return vec4(vec3(col), t);
      }


      vec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {
        vec2 gp = sp;
        gp *= ROT(0.67);
        gp += vec2(-1.0, 0.5);
        float h1 = height(2.0*sp);
        float gcc = dot(gp, gp);
        float gcx = exp(-(abs(3.0*(gp.x))));
        float gcy = exp(-abs(10.0*(gp.y)));
        float gh = gcy*gcx;
        float cf = smoothstep(0.05, -0.2, -h1);
        vec3 col = vec3(0.0);
        col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;
        col += hsv2rgb(vec3(0.6, 0.5, 0.00125/gcc));
        col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);
        sf = gh*cf;
        return col;
      }

      vec3 grid(vec3 ro, vec3 rd, vec2 sp) {
        const float m = 1.0;

        const vec2 dim = vec2(1.0/8.0*PI);
        vec2 pp = sp;
        vec2 np = mod2(pp, dim);

        vec3 col = vec3(0.0);

        float y = sin(sp.x);
        float d = min(abs(pp.x), abs(pp.y*y));

        float aa = 2.0/RESOLUTION.y;

        col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));

        return 0.25*tanh(col);
      }


      float segmentx(vec2 p) {
        float d0 = abs(p.y);
        float d1 = length(p);
        return p.x > 0.0 ? d0 : d1;
      }

      vec3 meteorite(vec3 ro, vec3 rd, vec2 sp) {
        const float period = 6.0;
        float mtime = mod(TIME, period);
        float ntime = floor(TIME/period);
        float h0 = hash(ntime);
        float h1 = fract(1667.0*h0);
        vec2 mp = sp;
        mp.x += -1.0;
        mp.y += -0.5*h1;
        mp *= ROT(PI+mix(-PI/4.0, PI/4.0, h0));
        float m = smoothstep(0.0, 0.25, mtime/period);
        mp.x += mix(-1.0, 2.0, m);

        float d0 = length(mp);
        float d1 = segmentx(mp);

        vec3 col = vec3(0.0);

        col += exp(-mix(300.0, 600.0, smoothstep(-0.5, 0.5, sin(10.0*TTIME)))*max(d0, 0.0));
        col += 0.5*exp(-4.0*max(d0, 0.0))*exp(-1000.0*max(d1, 0.0));

        col *= vec3(1.0)*smoothstep(0.2, 0.8, sp.x);

        return col;
      }

      vec4 tombstone(vec3 ro, vec3 rd) {
        vec2 sp = toSpherical(rd).yz;
        vec2 p = sp;
        p += vec2(-PI/2.0, -PI/2.3);
        p *= 2.0;
        p += 0.5;
        p.y = 1.0-p.y;
        return texture(in_memory_of, p);
      }

      // http://mercury.sexy/hg_sdf/
      float mod1(inout float p, float size) {
        float halfsize = size*0.5;
        float c = floor((p + halfsize)/size);
        p = mod(p + halfsize, size) - halfsize;
        return c;
      }

      // https://iquilezles.org/articles/intersectors
      vec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {
          vec3  oc = ro - cb;
          float card = dot(ca,rd);
          float caoc = dot(ca,oc);
          float a = 1.0 - card*card;
          float b = dot( oc, rd) - caoc*card;
          float c = dot( oc, oc) - caoc*caoc - cr*cr;
          float h = b*b - a*c;
          if( h<0.0 ) return vec2(-1.0); //no intersection
          h = sqrt(h);
          return vec2(-b-h,-b+h)/a;
      }

      vec3 skyColor(vec3 ro, vec3 rd) {
        const vec3 l = normalize(vec3(0.0, 0.0, 0.1));
        const vec3 baseCol = vec3(0.5, 0.66, 1.0);
        return 1.25*baseCol*pow(max(dot(l, normalize(rd*vec3(1.0, 0.33, 1.0))), 0.0), 300.0);
      }

      vec3 starEffect(vec2 p) {
        float tm  = TIME;
        vec3 ro   = vec3(0.0, 0, tm);
        vec3 dro  = normalize(vec3(0.20, 0.2, 1.0));

        dro.xz *= ROT(0.2*sin(0.05*tm));
        dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));
        vec3 up = vec3(0.0,1.0,0.0);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(up, ww));
        vec3 vv = normalize(cross(ww, uu));
      //  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions
        float rdd = 2.0;
        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);

        vec3 skyCol = skyColor(ro, rd);

        float aa = TIME*0.125;
        rd.yx *= ROT(aa);
        float a = atan(rd.y, rd.x);

        vec3 col = skyCol;
        const float mm = 5.0;
        for(float i = 0.0; i < mm; ++i) {
          float ma = a;
          float ii = i/(mm-1.0);
          float sz = 31.0+i*64.0;
          float slices = TAU/sz;
          float na = mod1(ma, slices);

          float hh = hash(na+113.0*i);
          float h1 = hh;
          float h2 = fract(hh*113.0);
          float h3 = fract(hh*127.0);

          float tr = mix(0.25, 2.0, h1);
          vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);
          vec3 tcp = ro + tc.y*rd;
          vec2 tcp2 = vec2(tcp.z+h2*2.0, atan(tcp.y, tcp.x));

          float sx = mix(0.75, 1.5, h3);
          vec2 tnp2 = mod2(tcp2, vec2(sx, slices));
          tcp2.y *= tr*PI;
          float h4 = hash(tnp2.x+hh);
          float h5 = fract(113.0*h4);
          tcp2.x += 0.4*sx*h4;
          float d = length(tcp2)-0.001;

          float si = exp(-(100.0+1.4*sz)*max(d, 0.0));

          vec3 hsv = vec3(-0.0-0.4*h4, mix(0.4, 0.00, ii), 1.0);
          vec3 bcol = hsv2rgb(hsv)*3.0;
          vec4 scol = vec4(bcol*sqrt(si), sqrt(si)*exp(-0.05*tc.y*tc.y));

          col = mix(col, scol.xyz, scol.w);
        }

        return col;
      }

      vec4 bike(vec2 p, vec3 ro, vec3 rd, float mtime) {
        vec2 sp = toSpherical(rd).yz;
        vec2 bp = sp;
        float fi = smoothstep(0.75, 0.95, mtime);
        bp += vec2(mix(-PI/2.0-1.0, -PI/2.0+1.6, fi), mix(0.0, -0.9, fi));
        bp *= mix(2.0, 0.5, fi);
        bp += 0.5;
        bp.y = 1.0-bp.y;
        vec3 ocol = hsv2rgb(vec3(fract(sp.y*8.0), 0.33, 0.9));
        vec3 scol = starEffect(p);
        vec4 bcol = texture(motorbike, bp);
        float l = max(max(bcol.x, bcol.y), bcol.z);
        bcol.xyz = mix(bcol.xyz, ocol, tanh_approx(2.0*l));
        return vec4(mix(scol, bcol.xyz, l), bcol.w);
      }

      vec3 color(vec2 p, vec3 ro, vec3 rd, vec3 lp, vec4 md, float mtime) {
        vec2 sp = toSpherical(rd.xzy).yz;

        float sf = 0.0;
        float cf = 0.0;
        vec3 col = vec3(0.0);

        vec4 mcol = moon(ro, rd, sp, lp, md);
        vec3 scol = sky(ro, rd, sp, lp, cf);
        vec4 tcol = tombstone(ro, rd);
        vec4 bcol = bike(p, ro, rd, mtime);

        col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(10.0*cf));
        col += galaxy(ro, rd, sp, sf);
        col = mix(col, mcol.xyz, mcol.w);
        col += scol;
        col += meteorite(ro, rd, sp);

      //  col += grid(ro, rd, sp);
        col *= smoothstep(0.1, 0.15, mtime);

        col = mix(col, tcol.xyz, tcol.w);
        col = mix(col, bcol.xyz, bcol.w);


        return col;
      }

      void main() {
        const float period = 30.0;
        vec2 q = v_texcoord;
        vec2 p = -1.0 + 2.0*q;
        p.x *= RESOLUTION.x/RESOLUTION.y;

        vec3 ro = vec3(0.0, 0.0, 0.0);
        vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);
        vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);
        vec3 la = vec3(1.0, 0.5, 0.0);
        vec3 up = vec3(0.0, 1.0, 0.0);
        float mtime = mod(TIME, 30.0)/30.0;
        la.xy *= ROT(-0.8*(0.9-mtime));

        vec3 ww = normalize(la - ro);
        vec3 uu = normalize(cross(up, ww));
        vec3 vv = normalize(cross(ww,uu));
        vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);
        vec3 col= color(p, ro, rd, lp, md, mtime);

        col *= smoothstep(0.0, 0.05, mtime);
      //  col *= smoothstep(1.0, 0.9, mtime);
      //  col = starEffect(p);
        col = aces_approx(col);
        col = sRGB(col);

        frag_color = vec4(col,1.0);
      }
    </script>

    <script id="fs_nihon" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      uniform sampler2D perlin;

      #define RESOLUTION  resolution
      #define TIME        time
      #define PI          3.141592654
      #define TAU         (2.0*PI)

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      const vec3 sunPos     = 1E7*vec3(1.0,0.25,-1.0);
      const vec3 skyDir     = normalize(vec3(-1.0,0.25,1.0));
      const vec4 moonDim    = vec4(1E5*vec3(-0.2175,0.1525,-1.0), 9000.0);
      const vec3 sunDir     = normalize(sunPos);
      const vec3 sunCol0    = HSV2RGB(vec3(0.15, 0.66, 1.0));
      const vec3 sunCol1    = HSV2RGB(vec3(0.5*0.15, 0.95, 1.0));
      const vec3 skyCol     = HSV2RGB(vec3(0.6, 0.6, 0.6));
      const vec3 morningDir = normalize(vec3(0.65,0.4,-1.0));

      const float iceHeightFactor = -0.0125;

      // License: Unknown, author: Unknown, found: don't remember
      float tanh_approx(float x) {
        //  Found this somewhere on the interwebs
        //  return tanh(x);
        float x2 = x*x;
        return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
      }

      vec3 toSpherical(vec3 p) {
        float r   = length(p);
        float t   = acos(p.z/r);
        float ph  = atan(p.y, p.x);
        return vec3(r, t, ph);
      }

      float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
      }

      float noise(vec2 p) {
        vec2 n = fract(floor(p)*0.5)*2.0;
        p = fract(p);
        p = mix(p, 1.0 - p, n);
        return texture(perlin, p).x;
      }

      // License: Unknown, author: Unknown, found: don't remember
      vec2 hash2(vec2 p) {
        p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));
        return fract(sin(p)*43758.5453123);
      }

      float parabola(vec2 pos, float k) {
        pos.x = abs(pos.x);
        float ik = 1.0/k;
        float p = ik*(pos.y - 0.5*ik)/3.0;
        float q = 0.25*ik*ik*pos.x;
        float h = q*q - p*p*p;
        float r = sqrt(abs(h));
        float x = (h>0.0) ?
            pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :
            2.0*cos(atan(r,q)/3.0)*sqrt(p);
        return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);
      }

      float vesica(vec2 p, vec2 sz) {
        if (sz.x < sz.y) {
          sz = sz.yx;
        } else {
          p  = p.yx;
        }
        vec2 sz2 = sz*sz;
        float d  = (sz2.x-sz2.y)/(2.0*sz.y);
        float r  = sqrt(sz2.x+d*d);
        float b  = sz.x;
        p = abs(p);
        return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))
                                 : length(p-vec2(-d,0.0))-r;
      }

      vec3 voronoi(vec2 p) {
        vec2 op = p;
        vec2 g = floor(p), o; p -= g;
        vec3 d = vec3(1); // 1.4, etc. "d.z" holds the distance comparison value.

        vec2 mp;

        for(int y = -1; y <= 1; y++) {
          for(int x = -1; x <= 1; x++) {
            o = vec2(x, y);
            o += hash2(g + o) - p;

            d.z = dot(o, o);
            // More distance metrics.
            //o = abs(o);
            //d.z = max(o.x*.8666 + o.y*.5, o.y);//
            //d.z = max(o.x, o.y);
            //d.z = (o.x*.7 + o.y*.7);

            d.y = max(d.x, min(d.y, d.z));
            if (d.z < d.x) {
              d.x = d.z;
              mp = op+o;
            }
            d.x = min(d.x, d.z);

          }
        }

          return vec3(max(d.y/1.2 - d.x*1.-0., 0.), mp);
          //return d.y - d.x; // return 1.-d.x; // etc.

      }

      // License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm
      vec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {
        vec3 oc = ro - sph.xyz;
        float b = dot( oc, rd );
        float c = dot( oc, oc ) - sph.w*sph.w;
        float h = b*b - c;
        if( h<0.0 ) return vec2(-1.0);
        h = sqrt( h );
        return vec2(-b - h, -b + h);
      }


      vec3 skyColor(vec3 ro, vec3 rd) {
        vec3 srd = toSpherical(rd.xzy);
        vec3 col = vec3(0.0);

        float morningd = clamp(dot(morningDir,rd), 0.0, 1.0 );
        float sund = clamp(dot(sunDir,rd), 0.0, 1.0 );

        vec2 mi = raySphere(ro, rd, moonDim);

        float sy = max(-(srd.y-PI/2.0), 0.0);
        sy = exp(-5.*sy);
        col += hsv2rgb(vec3(0.6, mix(0.8, 0.5, sy), sy));

        const float sh = 0.15;
        col += 8.0*sunCol0*pow(sund, 1000.0);
        col += 1.0*sunCol1*pow(sund, 100.0);
        col += 2.0*HSV2RGB(vec3(sh, 0.66, 1.0))*pow(morningd, 2000000.0);

        vec3 mpos = ro + mi.x*rd;
        vec3 mnor = normalize(mpos-moonDim.xyz);
        vec3 mref = reflect(rd, mnor);
        vec3 mld  = normalize(sunPos - mpos);
        float mdif= pow(max(dot(mnor,mld), 0.0), 2.0);
        float mspe= pow(max(dot(mnor,mld), 0.0), 5.0);
        vec3 mcol = vec3(0.005);
        mcol += 0.9*mspe;
        mcol += 0.5*mdif;
        col += mcol*tanh_approx(0.0005*max((mi.y - mi.x), 0.0));

        return col;
      }

      float iceHeight(vec2 p, float aa) {
        vec2 vp = p;
        float vz = 1.0;

        float gh = 0.0;
        float hh = 0.0;


        // Recursive voronois
        {
          vec3 c = voronoi(vp);
          gh = (0.125*max(abs(c.y+8.0*sin(0.025*c.z)+2.0*sin(0.1*c.z))-mix(10.0, 30.0, 0.0*smoothstep(-0.5, 0.5, cos(0.01*c.z))), 0.));
          hh = smoothstep(-aa, aa, c.x-2.0*aa*smoothstep(1.0, 0.75, gh));
          if (gh > 0.75) {
            return iceHeightFactor*tanh_approx(hh+0.5*(gh-0.75));
          }

          vz *= 0.5;
          vp = vp * 2.0 + c.yz;
        }

        {
          vec3 c = voronoi(vp);
          hh = hh*smoothstep(-aa, aa, vz*c.x-3.0*aa*smoothstep(1.0, 0.5, gh));
          if (gh > 0.5) {
            return 0.75*iceHeightFactor*hh;
          }

          vz *= 0.5;
          vp = vp * 2.0 + c.yz;
        }

        {
          vec3 c = voronoi(vp);
          hh = hh*smoothstep(-aa, aa, vz*c.x-2.0*aa*smoothstep(0.9, 0.25, gh));
          if (gh > 0.25) {
            return 0.5*iceHeightFactor*hh;
          }
        }

        return 0.0;
      }

      vec3 iceNormal(vec2 p, float aa, float eps) {
        vec2 v;
        vec2 w;
        vec2 e = vec2(eps, 0);

        vec3 n;
        n.x = iceHeight(p + e.xy, aa) - iceHeight(p - e.xy, aa);
        n.y = 2.0*e.x;
        n.z = iceHeight(p + e.yx, aa) - iceHeight(p - e.yx, aa);

        return normalize(n);
      }

      vec4 iceColor(vec3 ro, vec3 rd, vec3 pos, float t, float aa) {
        vec2 pp = pos.xz;
        float haa = 0.125*t*aa;
        float height  = iceHeight(pp, haa);
        vec3 nor      = iceNormal(pp, haa, 1.0*haa);
        vec3 ref      = reflect(rd, nor);
        float fre = 1.0+dot(nor, rd);
        fre *= fre;
        fre *= fre;
        fre *= fre;

        float dif0    = max(dot(nor, sunDir), 0.0);
        float spe0    = pow(max(dot(ref, sunDir), 0.0), 10.0);
        float dif1    = max(dot(nor, skyDir), 0.0);

      //  dif = sqrt(dif);
        vec3 col = vec3(0.0);
        col += 3.0*dif0;
        col += 4.0*fre*spe0;
        col += 4.0*dif1*skyCol;
        return vec4(col, smoothstep(0.3*iceHeightFactor, 0.6*iceHeightFactor, height));
      }

      float seaHeight(vec2 p) {
        float lo = noise(0.005*p);
        lo *= lo;
        float hi = noise(0.05*p);
        hi *= hi;
        return -0.01*hi*mix(0.5, 1.0, lo);
      }


      vec3 seaNormal(vec2 p, float eps) {
        vec2 v;
        vec2 w;
        vec2 e = vec2(eps, 0);

        vec3 n;
        n.x = seaHeight(p + e.xy) - seaHeight(p - e.xy);
        n.y = 2.0*e.x;
        n.z = seaHeight(p + e.yx) - seaHeight(p - e.yx);

        return normalize(n);
      }

      vec3 shipColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, float aa) {
        const float ys = -6.0+0.3;
        vec2 pp   = pos.xz;

        vec2 sp = pp;
        vec2 spo = vec2(0.0, -27.0-TIME);
        sp -= spo;

        vec3 ppp = vec3(spo.x, ys, spo.y);
        float ss = length(pos - ppp);
        vec3 pnor= normalize(ro-ppp);
        vec4 ppl = vec4(pnor, -dot(ppp, pnor));
        float pd = rayPlane(ro, rd, ppl);
        vec3 plp = ro + pd*rd-ppp;

        const vec3 pup = normalize(vec3(0.0, 1.0, 0.0));
        vec3 pxx = normalize(cross(pnor, pup));
        vec3 pyy = normalize(cross(pnor, pxx));
        vec2 pp2 = vec2(dot(pxx, plp), dot(pyy, plp));
        float ld = length(pp2);

        float pm = -dot(ppp, nor);

        vec2 sbp = sp;
        sbp -= vec2(0.0, -0.4);

        vec2 spp = sp;
        spp -= vec2(0.0, 0.3);

        float sd = vesica(sp, vec2(0.1, 1.0)*0.5);
        float gd = length(sp);
        float sbd = parabola(sbp, 110.0);
        float spd = parabola(spp, 110.0);
        sbd = abs(sbd)-0.0071;

        float wrnd = smoothstep(-2.5, 0.5, sin(10.0*sbp.y)*sin(13.0*sbp.y+5.0*sbp.x));
        float sbfo = smoothstep(13.0, 0.0, sp.y)*wrnd;
        float spfo = smoothstep(4.0, 0.0, sp.y)*wrnd;

        vec3 col = vec3(0.0);
        const vec3 seaCol = HSV2RGB(vec3(0.45, 0.5, 0.1));
        vec3 shCol = vec3(mix(0.8,0.3, smoothstep(0.0, 1.0, cos(20.0*sqrt(2.0)*sp.y+1.0)*cos(20.0*sp.y))));
        col  = mix(col, shCol, smoothstep(aa, -aa, sd));
        col += smoothstep(aa, -aa, sbd*sbfo)*sbfo;
        col += 0.5*smoothstep(aa, -aa, spd*spfo)*spfo;
        float ff = smoothstep(0.5, 1.0, sin(TAU*TIME+1.0)*sin(TAU*sqrt(2.0)*TIME+2.0)*sin(TAU*sqrt(3.0)*TIME+3.0));
        col += 3.0*seaCol*exp(-mix(0.25, 0.275, ff)*gd);
        col += 1.0*exp(-mix(10.0, 20.0, ff)*ld);

        return col;
      }

      vec3 render(vec3 ro, vec3 rd, vec3 nrd) {
        vec3 skyCol = skyColor(ro, rd);

        const float ys = -6.0;
        float tb = (ys-ro.y)/rd.y;

        if (tb < 0.0) {
          return skyCol;
        }

        vec3 pos  = ro +  tb*rd;
        vec3 npos = ro +  tb*nrd;
        float baa = length(pos.xz - npos.xz);

        vec3 nor = seaNormal(pos.xz, baa);
        vec3 ref = reflect(rd, nor);
        vec3 rskyCol = skyColor(ro, ref);
        float fre = 1.0+dot(nor, rd);
        fre *= fre;
        fre *= fre;

        vec3 col = HSV2RGB(vec3(0.45, 0.5, 0.1));
        col += shipColor(ro, rd, pos, nor, baa);
        col += fre*rskyCol;
      #if defined(ICE_SHEET)
        vec4 iceCol  = iceColor(ro, rd, pos, tb, baa);
        col = mix(col, iceCol.xyz, iceCol.w);
      #endif

        col = mix(skyCol, col, exp(-0.0125*max(tb-60.0, 0.0)));

        return col;
      }

      vec3 color(vec2 p, vec2 q) {
        float z = -TIME;
        vec3 ro   = vec3(0.0, 0.0, z);
        vec3 dro  = normalize(vec3(0.0, 0., -1.0));

        vec2 np   = vec2(p+2.0/RESOLUTION.y);

        vec3 ww = normalize(dro);
        vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));
        vec3 vv = cross(ww, uu);
        const float rdd = 2.0;
        vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);
        vec3 nrd= normalize(np.x*uu + np.y*vv + rdd*ww);;

        vec3 col = render(ro, rd, nrd);

        return col;
      }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1. + 2.*q;
        p.x *= RESOLUTION.x/RESOLUTION.y;
        vec3 col = color(p, q);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_nihon_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      #define RESOLUTION resolution

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      // License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/
      vec3 aces_approx(vec3 v) {
        v = max(v, 0.0);
        v *= 0.6f;
        float a = 2.51f;
        float b = 0.03f;
        float c = 2.43f;
        float d = 0.59f;
        float e = 0.14f;
        return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);
      }

      void main() {
        vec2 q = v_texcoord;

      #ifdef POST_BLUR
        const int c = 3;

        vec2 pq = q;
        vec2 aa = 4.0/RESOLUTION.xy;
        vec2 start = pq-float(c)*aa;
        vec3 bcol = vec3(0.0);
        for (int y = -c; y <= c; ++y) {
          vec2 pp = start;
          for (int x = -c; x <= c; ++x) {
            vec4 fcol = texture(prev_frame, pp);
            bcol += fcol.xyz*fcol.xyz;
            pp.x += aa.x;
          }
          start.y += aa.y;
        }

        bcol /= float((2*c+1)*(2*c+1));
        float l = max(max(bcol.x, bcol.y), bcol.z);
        bcol *= smoothstep(0.2, 1.0, l);

        vec4 pcol = texture(prev_pass, q);
        vec3 col = pcol.xyz;
        col = aces_approx(col);
        col += 0.25*bcol;
        col = sRGB(col);
      #else
        vec4 bcol = texture(prev_frame, q);
        bcol *= bcol;
        float l = max(max(bcol.x, bcol.y), bcol.z);

        vec4 pcol = texture(prev_pass,q);
        vec3 col = pcol.xyz;
        col = aces_approx(col);
        col += 0.25*bcol.xyz*smoothstep(0.2, 1.0, l);
        col = sRGB(col);
      #endif

        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="vs_glowing_tree" type="x-shader/x-vertex">
      precision highp float;

      uniform float time;
      uniform mat4 mvp;

      in vec4 a_position;
      in vec3 a_normal;
      in vec2 a_texcoord;

      out vec2  v_texcoord    ;
      flat out float v_lf     ;
      flat out float v_ratio  ;
      flat out int   v_level  ;

      #define PI          3.141592654
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      // License: Unknown, author: Unknown, found: don't remember

      void tree3D(int i, out int level, out float lw, out vec3 p0, out vec3 p1) {
        vec3 p  = vec3(0.0, 2.0,0.0);
        float a = 0.085*sin(time*0.75);
      //  a = 0.1;
        vec3 d  = vec3(0.0, -0.9, 0.0);
      //  d.xz *= ROT(time);
        const float fa = PI/8.0;

        float fs = mix(0.5, 0.8, 0.5+0.5*sin(time*sqrt(0.5)));
        fs = 0.85;
        mat2 lr = 1.0*fs*ROT(fa+a);
        mat2 rr = 0.90*fs*ROT(-fa+a);
        mat2 fr = 1.0*fs*ROT(fa);
        mat2 nr = 0.9*fs*ROT(-fa);
        int ii  = i - 1;
        float l = 0.2;
        int lvl = 0;
        int c = int(ceil(log(3.0*(float(i+1)))/log(4.0)-1.0));
        for(int j = 0; j < c; ++j) {
          ++lvl;
          p += d;
          int di = ii & 3;
          switch(di) {
          case 0:
            d.xy *= lr;
            break;
          case 1:
            d.xy *= rr;
            break;
          case 2:
            d.zy *= fr;
            break;
          case 3:
            d.zy *= nr;
            break;
          }
          ii = ii >> 2;
          l *= (fs);
        }

        level = lvl;
        lw = l;
        p0 = p;
        p1 = p + d;
      }

      // License: Unknown, author: Unknown, found: don't remember
      float hash(float co) {
        return fract(sin(co*12.9898) * 13758.5453);
      }

      void main() {
        int  level= 0;
        float lw  = 0.0;
        vec3 p0   = vec3(0.0, 0.0, 0.0);
        vec3 p1   = vec3(0.0, 0.0, 0.0);

        tree3D(gl_InstanceID, level, lw, p0, p1);
        const float period = 20.0;
        float h0  = hash(float(gl_InstanceID)+123.4);
        float h1  = fract(h0*1667.0);
        float st  = h0*period;
        float te  = mod(time-st, period);
        float ef  = smoothstep(0.0, 10.0, te);
        float doff = 0.25*sin(h1*20.0*ef)*ef;
        vec3 woff = vec3(5.0*ef+doff, 10.0*ef*ef, doff)*step(te, 5.0);
        if (level > 6) {
          p0 += woff;
          p1 += woff;
        }
        mat2 r = ROT(3.5);
        vec3 off = vec3(0.0, 0.0, 2.0);
        p0.xz *= r;
        p1.xz *= r;
        p0 += off;
        p1 += off;
        vec3 c  = (p0+p1)*0.5;
        vec3 d  = p1-p0;
        float l = length(d);

        vec3 up = vec3(0.0, 0.0, -1.0);
        vec3 ww = d/l;
      //  vec3 uu = normalize(cross(ww, up));
        // Bug, should be like above
        vec3 uu = (cross(ww, up));
        vec3 vv = cross(uu, ww);

        vec4 p = a_position;
        mat3 m = mat3(ww, uu, vv);
        float lf = step(float(level), 6.0);
        float gl = min(l*lf+lw,l);
        vec2 rr= vec2(gl, lw);
        p.xy  *= 0.5*rr;
        p.xyz *= transpose(m);
        p.xyz -= c;

        gl_Position = mvp * p;

        v_texcoord  = a_texcoord;
        v_lf        = lf;
        v_ratio     = rr.x/rr.y;
        v_level     = level;
      }
    </script>

    <script id="fs_glowing_tree" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      flat in float v_lf     ;
      flat in float v_ratio  ;
      flat in int   v_level  ;

      #define PI      3.141592654
      #define PCOS(x) (0.5+0.5*cos(x))

      float segmentx(vec2 p, float w) {
        p = abs(p);
        float d0 = p.y;
        float d1 = length(p-vec2(w, 0.0));
        return p.x > w ? d1 : d0;
      }

      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 hsv2rgb(vec3 c) {
        vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
        return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
      }
      // License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488
      //  Macro version of above to enable compile-time constants
      #define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))

      void main() {
        vec4 fc = gl_FragCoord;
        float originalZ = fc.z / gl_FragCoord.w;
        vec2 q = v_texcoord;
        vec2 p = -1. + 2. * q;

        float r     = v_ratio;
        int   level = v_level;
        float lf    = v_lf;
        p.x *= r;

        vec3 col = vec3(0.0);
        float l = length(p);
        float h = 0.44+float(level)/10.0;;
        float s = 1.0;
        vec3 gcol0 = hsv2rgb(vec3(h, 0.55, s));
        vec3 gcol1 = hsv2rgb(vec3(h, 0.95, s));
        float ds = segmentx(p, lf*r);
        float g = exp(-3.0*ds);
        col += 1.0*gcol0*g*g*g;
        col += 0.5*gcol1*g*g;
        col /= mix(1.0, float(level*level)+1.0, lf);
        col *= 9.0*exp(-0.5*originalZ);
        frag_color = vec4(col, 1.0);
      }
    </script>

    <script id="fs_glowing_tree_post" type="x-shader/x-fragment">
      // -----------------------------------------------------------------------------
      // PRELUDE
      // -----------------------------------------------------------------------------
      precision highp float;
      uniform float     time              ;
      uniform vec2      resolution        ;
      uniform sampler2D frequency_data    ;
      uniform sampler2D time_domain_data  ;
      uniform sampler2D prev_frame        ;
      uniform sampler2D prev_pass         ;
      in vec2 v_texcoord                  ;
      out vec4 frag_color                 ;
      // -----------------------------------------------------------------------------
      // SHADER
      // -----------------------------------------------------------------------------
      #define PI          3.141592654
      #define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))

      #define RESOLUTION  resolution

      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      float sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }
      // License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM
      vec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }

      void main() {
        vec2 q = v_texcoord;
        vec2 p = -1.0+2.0*q;
        vec2 pp = p;
        pp *= 0.9+0.05;
      //  pp.x += -0.0125;
      //  pp *= ROT(0.05);

        vec2 pq = 0.5+0.5*pp;

        const int c = 3;

        vec2 aa = 6.0/RESOLUTION.xy;
        vec2 start = pq-float(c)*aa;
        vec3 bcol = vec3(0.0);
        for (int y = -c; y <= c; ++y) {
          vec2 pp = start;
          for (int x = -c; x <= c; ++x) {
            vec4 fcol = texture(prev_frame, pp);
            bcol += fcol.xyz;
            pp.x += aa.x;
          }
          start.y += aa.y;
        }

        bcol /= float((2*c+1)*(2*c+1));

        vec4 pcol = texture(prev_pass,q);
        vec3 col = pcol.xyz;
        col = sRGB(col);
        col = mix(col, bcol, 0.6)*1.25;

        frag_color = vec4(col, pcol.w);
      }
    </script>


    <script type = "module">
      import TinySDF from "./tiny-sdf.js";
      const fontFamily  = "Josefin Slab"
      const fontSize    = 128.0;
      const fontWeight  = 400.0;
      const fontStyle   = "normal";
      const buffer      = Math.ceil(fontSize / 3);
      const radius      = Math.ceil(fontSize / 2);
      const tinySdf     = new TinySDF({fontFamily, fontSize, buffer, radius, fontWeight, fontStyle});

      const text = "Impulse! 2022!\nGlimglam!\nJez!\nLance!\nLongshot!";

      window.getFontBits = (gl) => {
        const bits    = tinySdf.drawText(text, 8, 16, 1024, 1024);
        const dbits   = tinySdf.downsample2x(bits);
        dbits.format  = gl.LUMINANCE;
        return dbits;
      };
    </script>

    <script type = "text/javascript">
      const analyze_audio   = true;
      const demo_system     = new DemoSystemV2(analyze_audio);

      const global_uniforms = [];

      function override_nearest(image) {
        return [image, (gl) => {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
        }];
      }

      const all_textures = {
        in_memory_of : {
          image : (gl) => document.getElementById("in_memory_of"),
        },
        motorbike : {
          image : (gl) => document.getElementById("motorbike"),
        },
        perlin : {
          image : (gl) => document.getElementById("perlin"),
        },
      }

      // List all scenes, all scenes have a vertex shader (often shared)
      //  and a fragment shader
      //  It's possible to reuse and tweak fragment shaders by using defines
      //  Can also register extra uniforms
      //  Default uniforms always includes time and resolution
      const all_scenes = {
        red_scene : {
          passes:[
            {
              vs: "vs_default",
              fs: "fs_red_pass"
            },
          ]
        },
        night_sky : {
          uniforms: ["in_memory_of", "motorbike"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_night_sky",
              pre_render: (gl, time, scene, pass) => {
                // Texture 0 - 3 are reserved

                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.in_memory_of.texture);
                gl.uniform1i(pass.uniformLocations.in_memory_of, 4);

                gl.activeTexture(gl.TEXTURE5);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.motorbike.texture);
                gl.uniform1i(pass.uniformLocations.motorbike, 5);
              },
            },
          ],
        },
        nihon : {
          uniforms: ["perlin"],
          passes:[
            {
              vs: "vs_default",
              fs: "fs_nihon",
              pre_render: (gl, time, scene, pass) => {
                // Texture 0 - 3 are reserved

                gl.activeTexture(gl.TEXTURE4);
                gl.bindTexture(gl.TEXTURE_2D, all_textures.perlin.texture);
                gl.uniform1i(pass.uniformLocations.perlin, 4);

              },
            },
            {
              vs: "vs_default",
              fs: "fs_nihon_post",
            },
          ],
        },
        glowing_tree : {
          uniforms: ["mvp"],
          passes:[
            {
              vs: "vs_glowing_tree",
              fs: "fs_glowing_tree",
              requires_clear: true,
              instances: 21845,
              pre_render: (gl, time, scene, pass) => {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.MAX);

                gl.uniformMatrix4fv(pass.uniformLocations.mvp, false, mvp);
              },
            },
            {
              vs: "vs_default",
              fs: "fs_glowing_tree_post",
              pre_render: (gl, time, scene, pass) => {
                gl.disable(gl.BLEND);
              }
            },
          ],
        },
      };

      const bpm   = 120.0;
      const beat  = 60.0/bpm;
      const start = 0.0*beat;
      function btime(b) {
        return (b*beat-start);
      }

      const max_time_slots  = 400;
      const time_slots      = new Array(max_time_slots);

      const script = [
        {
          begin       :  0                                ,
          scene       :  all_scenes.nihon                 ,
        },
        {
          begin       :  48                               ,
          scene       :  all_scenes.red_scene             ,
        },
      ];

      function populate_time_slots() {
        let current_script = script[0];
        let slot = 0;
        for (const idx in script) {
          const next_script = script[idx];
          while(slot < max_time_slots && slot < next_script.begin) {
            time_slots[slot] = current_script;
            ++slot;
          }
          current_script = next_script;
        }
        while(slot < max_time_slots) {
            time_slots[slot] = current_script;
            ++slot;
        }
      }
      populate_time_slots();

      function get_slot(time) {
        const i = clamp(Math.floor(time/beat), 0, max_time_slots-1);
        return time_slots[i];
      }

      // Called after initialization of all shaders are complete
      function on_init_complete(width, height) {
        globalThis.projection  = projection_matrix4(Math.PI/3.0, width/height, 1, 1000);
        globalThis.view        = look_at_matrix4(vector3(0,0,3), vector3(0,0,0), vector3(0,1,0));
        globalThis.mvp         = multiply_matrix4(view, projection);

        const label = document.getElementById("info_label");
        label.textContent = "Ready, click play to run";

        const music = document.getElementById("music");
        music.style.visibility = "visible";
      }

      // Called after user clicked play
      function on_started() {
        const information = document.getElementById("information");
        information.style.display = "none";
      }
      // Called before each shader is compiled
      function on_loading_scene(key) {
        const label = document.getElementById("info_label");
        label.textContent = "Compiling: " + key;
      }

      // Called each frame to select which scene to render
      function on_select_scene(gl, time) {
        if (time > start) {
          const gtime = time - start;
          const slot = get_slot(gtime);
          if(slot && slot.scene) {
            return slot.scene;
          } else {
            return all_scenes.red_scene;
          }
        } else {
          return all_scenes.red_scene;
        }
//        return all_scenes.night_sky;
      }

    </script>
  </head>

  <body onload="demo_system.run_demo()">
    <audio id="music" style="visibility: hidden;" controls src="laleh--varens-forsta-dag.m4a"></audio>
    <div id="information" style="margin-left: 16pt;">
      <h1>In memory of...</h1>

      <p id="info_label">Please wait... </p>
    </div>
    <div class="center-flex">
      <div>
        <canvas id="screen_canvas" class="gl">
          Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
        </canvas>
      </div>
    </div>
    <img id="in_memory_of" src="in_memory_of.png" style="display: none"/>
    <img id="motorbike" src="motorbike.png" style="display: none"/>
    <img id="perlin" src="perlin.png" style="display: none"/>
  </body>
</html>